<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">9.1 编辑模式</h2>

  <p class="calibre1">　　UITableView有一个名为editing的属性，如果将editing属性设置为YES，UITableView就会进入编辑模式。在编辑模式下，用户可以管理UITableView中的表格行，例如之前提到的添加、删除和移动等操作。但是编辑模式没有提供修改行的内容的功能。</p>

  <p class="calibre1">　　首先需要更新界面，使用户可以将UITableView对象设置为编辑模式。本章是为UITableView对象的表头视图（header view）增加一个按钮，然后通过点击按钮使UITableView对象进入或退出编辑模式。表头视图是指UITableView对象可以在其表格上方显示的特定视图，适合放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意的UIView对象。</p>

  <p class="calibre1">　　表头视图有两种，分别针对表格段和表格。类似地，还有表尾视图（footer view），也具有表格段和表格两种（见图9-2）。</p>

  <p class="calibre7"><img alt="tu9-2" src="../Images/image00490.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-2 针对表格段的表头视图和表尾视图</p>

  <p class="calibre1">　　接下来创建一个针对表格的表头视图。这个表头视图包含两个UIButton对象，其中一个负责切换UITableView对象的编辑模式，另一个负责创建新的BNRItem对象并加入UITableView对象。可以使用代码创建这个表头视图及其包含的子视图，但是本章将使用XIB文件创建它们。之后，BNRItemsViewController对象在需要显示表头视图时会加载相应的XIB文件。</p>

  <p class="calibre1">　　首先需要编写一些代码。重新打开第8章中的Homepwner.xcodeproj，在BNRItemsViewController.m中添加<span class="calibre10">BNRItemsViewController</span>的类扩展，然后声明一个插座变量并添加两个新方法，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　@interface BNRItemsViewController ()</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property (nonatomic, strong) IBOutlet UIView *headerView;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@end</span><br class="calibre2"/></p>

  <p class="calibre1">　　@implementation BNRItemsViewController</p>

  <p class="calibre1">　　// 这里省略了其他方法</p>

  <p class="calibre1"><span class="calibre10">　　- (IBAction)addNewItem:(id)sender</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　- (IBAction)toggleEditingMode:(id)sender</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　载入XIB文件后，headerView会指向XIB文件中的顶层对象，并且是强引用。指向顶层对象的插座变量必须声明为强引用；相反，当插座变量指向顶层对象所拥有的对象（例如顶层对象的子视图）时，应该使用弱引用。</p>

  <p class="calibre1">　　下面创建一个新的XIB文件。和本书之前创建的XIB文件不同，这个XIB文件和视图控制器的视图无关（BNRItemsViewController作为UITableViewController的子类，可以自行创建其视图）。通常情况下，可以用XIB文件来创建某个视图控制器的视图。但是，也可以在XIB文件中随意创建多个视图并设置层级结构和布局，然后在运行应用时按需载入。</p>

  <p class="calibre1">　　选择File菜单中的New菜单项，然后选择File…选中窗口左侧iOS部分的User Interface，然后选中窗口右侧的Empty模板，最后单击Next按钮（见图9-3）。</p>

  <p class="calibre7"><img alt="tu9-3" src="../Images/image00491.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-3 创建新的XIB文件</p>

  <p class="calibre1">　　在新出现的面板中选择Device Family下拉菜单中的iPhone，单击Next按钮。Xcode会提示保存文件，将文件名设置为HeaderView.xib，单击Save按钮。</p>

  <p class="calibre1">　　选中HeaderView.xib中的File's Owner，打开标识检视面板，将Class文本框中的UIViewController修改为BNRItemsViewController（见图9-4）。</p>

  <p class="calibre7"><img alt="tu9-4" src="../Images/image00492.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-4 修改File'Owner</p>

  <p class="calibre1">　　先拖曳一个UIView对象至画布，然后再拖曳两个UIButton对象至这个UIView对象。现在需要调整UIView对象的大小，但是读者会发现UIView对象的大小被锁定了，无法调整，因此需要解除大小锁定。选中UIView对象并打开属性检视面板，在Simulated Metrics部分中点击标题为Size的选项列表，选择None（见图9-5）。</p>

  <p class="calibre7"><img alt="tu9-5" src="../Images/image00493.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-5 解除视图大小锁定</p>

  <p class="calibre1">　　现在可以调整视图大小了，请按图9-6所示调整UIView对象的大小并创建相应的关联。</p>

  <p class="calibre7"><img alt="tu9-6" src="../Images/image00494.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-6 HeaderView.xib的布局</p>

  <p class="calibre1">　　还要将UIView对象的背景颜色修改为全透明颜色。具体做法为：选中之前加入的UIView对象并打开属性检视面板。单击标题为Background的颜色的选项列表，选择Clear Color（见图9-7）。</p>

  <p class="calibre7"><img alt="tu9-7" src="../Images/image00495.jpeg" class="calibre8"/></p>

  <p class="calibre7">图9-7 将背景色设置为Clear Color</p>

  <p class="calibre1">　　本书之前所创建的XIB文件，都是通过UIViewController类的默认实现自动载入的。以第6章的BNRReminderViewController为例，因为它是UIViewController的子类，所以BNRReminderViewController对象会在需要显示其视图时，自动载入BNRReminderViewController.xib。但是对于HeaderView.xib，则需要编写特定的代码，让BNRItemsViewController对象能够“手动”载入该XIB文件。</p>

  <p class="calibre1">　　使用NSBundle类可以载入指定的XIB文件。该类是“应用程序包”和“应用程序包所包含的可执行文件”之间的接口。通过该类，应用可以访问某个程序包中的文件。向该类发送mainBundle消息可以得到指向主NSBundle对象的指针，该对象是应用在启动时创建的。</p>

  <p class="calibre1">　　得到主NSBundle对象后，就可以要求其载入应用程序包中的某个XIB文件。在BNRItemsViewController.m中实现headerView方法，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- (UIView *)headerView</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果还没有载入headerView...</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if (!_headerView) {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　// 载入HeaderView.xib</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　[[NSBundle mainBundle] loadNibNamed:@"HeaderView"</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　　　　　　　　　　　　　　　　　owner:self</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　 options:nil];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return _headerView;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　该方法使用了一种名为延迟实例化（Lazy Instantiation）的设计模式：只会在真正需要使用某个对象时再创建它。在某些情况下，这种设计模式可以显着减少内存占用。</p>

  <p class="calibre1">　　调用loadNibNamed:owner:options:时，需要传入XIB文件的文件名。文件名不需要包含后缀，NSBundle会自行判断并处理。此外，这段代码将self作为owner实参（拥有者）传给了NSBundle对象，目的是当BNRItemsViewController对象将XIB文件加载为NIB文件时，使用BNRItemsViewController对象自身替换占位符对象File's Owner。</p>

  <p class="calibre1">　　BNRItemsViewController对象会在第一次收到headerView消息时载入HeaderView.xib，然后为插座变量headerView赋值，并将其指向HeaderView.xib中的顶层UIView对象。当用户按下这个顶层UIView对象中的任何一个按钮时，BNRItemsViewController对象都会收到指定的动作消息。</p>

  <p class="calibre1">　　加载了headerView后，还需要将其设置为UITableView对象的表头视图。在BNRItemsViewController.m的viewDidLoad方法中，添加以下代码：</p>

  <p class="calibre1">　　- (void)viewDidLoad</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　[super viewDidLoad];</p>

  <p class="calibre1">　　[self.tableView registerClass:[UITableViewCell class]</p>

  <p class="calibre1">　　　　 forCellReuseIdentifier:@"UITableViewCell"];</p>

  <p class="calibre1"><span class="calibre10">　　UIView *header = self.headerView;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.tableView setTableHeaderView:header];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，UITableView对象会在列表上方显示两个按钮。</p>

  <p class="calibre1">　　XIB文件不仅可以用来创建视图控制器的视图（例如BNRReminderView- Controller.xib），也可以用来固化其他的视图层次结构（例如HeaderView.xib）。实际上，任何对象都可以通过向主NSBundle对象发送loadNibNamed:owner:options:消息手动载入XIB文件。</p>

  <p class="calibre1">　　前面介绍过，UIViewController默认已经实现了通过XIB文件载入视图的功能。其实现原理和headerView方法的相同，代码也相似。唯一的差别是，UIViewController对象会在载入XIB文件后，将插座变量view关联至XIB文件中指定的UIView对象。UIViewController的loadView方法的代码示例如下（这里列出的代码仅是举例，和UIViewController的loadView方法的实际代码不同）：</p>

  <p class="calibre1">　　- (void)loadView</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　// NIB文件位于哪个bundle中？</p>

  <p class="calibre1">　　// 是否为initWithNibName:bundle:方法传了bundle参数？</p>

  <p class="calibre1">　　NSBundle *bundle = [self nibBundle];</p>

  <p class="calibre1">　　if (!bundle) {</p>

  <p class="calibre1">　　　　// 使用默认bundle</p>

  <p class="calibre1">　　　　bundle = [NSBundle mainBundle];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　// NIB文件的名称是什么？</p>

  <p class="calibre1">　　// 是否为initWithNibName:bundle:方法传了NIB文件名参数？</p>

  <p class="calibre1">　　NSString *nibName = [self nibName];</p>

  <p class="calibre1">　　if (!nibName) {</p>

  <p class="calibre1">　　　　// 使用默认NIB文件名</p>

  <p class="calibre1">　　　　nibName = NSStringFromClass([self class]);</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　// 尝试在bundle中查找默认NIB文件</p>

  <p class="calibre1">　　NSString *nibPath = [bundle pathForResource:nibName</p>

  <p class="calibre1">　　　　ofType:@"nib"];</p>

  <p class="calibre1">　　// 该NIB文件是否存在？</p>

  <p class="calibre1">　　if (nibPath) {</p>

  <p class="calibre1">　　　　// 加载NIB文件（同时还会设置view插座变量）</p>

  <p class="calibre1">　　　　[bundle loadNibNamed:nibName owner:self options:nil];</p>

  <p class="calibre1">　　} else {</p>

  <p class="calibre1">　　　　// 如果没有NIB文件，就创建一个空白视图</p>

  <p class="calibre1">　　　　self.view = [[UIView alloc] init];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　接下来实现toggleEditingMode:。虽然可以直接通过设置UITableView对象的editing属性来切换编辑模式，但是UITableViewController也有一个从UIViewController继承而来的editing属性。当某个UITableViewController对象的editing属性发生变化时，UITableViewController对象会同步修改其UITableView对象的editing属性。</p>

  <p class="calibre1">　　向某个UIViewController对象或UIViewController子类对象发送setEditing: animated:消息，可以设置该对象的editing属性（UITableViewController覆盖了UIViewController的setEditing:animated:方法）。在BNRItemsViewController.m中实现toggleEditingMode:，代码如下：</p>

  <p class="calibre1">　　- (IBAction)toggleEditingMode:(id)sender</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1"><span class="calibre10">　　// 如果当前的视图控制对象已经处在编辑模式…</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if (self.isEditing) {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　// 修改按钮文字，提示用户当前的表格状态</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　[sender setTitle:@"Edit" forState:UIControlStateNormal];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　// 关闭编辑模式</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　[self setEditing:NO animated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　} else {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　// 修改按钮文字，提示用户当前的表格状态</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　[sender setTitle:@"Done" forState:UIControlStateNormal];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　// 开启编辑模式</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　[self setEditing:YES animated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，按下Edit按钮，UITableView对象会开启编辑模式（见图9-8）。</p>

  <p class="calibre7"><img alt="tu9-8" src="../Images/image00496.jpeg" class="calibre8"/><br class="calibre2"/></p>

  <p class="calibre7">图9-8 编辑模式下的UITableView对象</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
