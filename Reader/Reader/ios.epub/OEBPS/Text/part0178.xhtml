<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">19.4 捕获变量</h2>

  <p class="calibre1">　　Block对象可以使用其封闭作用域（enclosing scope）内的所有变量。对声明了某个Block对象的方法，该方法的作用域就是这个Block对象的封闭作用域。因此，这个Block对象可以访问该方法的所有局部变量、传入该方法的实参以及所属对象的实例变量。在上述代码中，BNRItem对象（item）和BNRItemCell对象（cell）都是actionBlock封闭作用域中的捕获变量。</p>

  <p class="calibre1">　　如果捕获变量是Objective-C对象，那么Block对象对捕获变量具有强引用。如果捕获变量也对Block对象具有强引用，就会导致强引用循环。之前在actionBlock中创建rect时，Xcode会提示警告信息：“Capturing 'cell' strongly in this block is likely to lead to a strong reference cycle（在Block对象中捕获‘cell’很可能导致强引用循环）”——BNRItemCell对actionBlock具有强引用，actionBlock对BNRItemCell也具有强引用，如图19-14所示。</p>

  <p class="calibre7"><img alt="tu19-14" src="../Images/image00628.jpeg" class="calibre8"/></p>

  <p class="calibre7">图19-14 cell和Block对象之间存在强引用循环</p>

  <p class="calibre1">　　解决问题的方法是：将actionBlock对cell的引用改为弱引用。</p>

  <p class="calibre1">　　在BNRItemsViewController.m中修改actionBlock中的代码，使其对cell具有弱引用，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　__weak *weakCell = cell;</span><br class="calibre2"/></p>

  <p class="calibre1">　　cell.actionBlock = ^{</p>

  <p class="calibre1">　　NSLog（@“Going to show the image for %@”, item）；</p>

  <p class="calibre1"><span class="calibre10">　　BNRItemCell *strongCell = weakCell;</span><br class="calibre2"/></p>

  <p class="calibre1">　　if （[UIDevice currentDevice] userInterfaceIdiom == UIUserInterfaceIdiomPad） {</p>

  <p class="calibre1">　　NSString *itemKey = item.itemKey;</p>

  <p class="calibre1">　　// 如果BNRItem对象没有图片，就直接返回</p>

  <p class="calibre1">　　UIImage *img = [[BNRImageStore sharedStore] imageForKey:imageKey];</p>

  <p class="calibre1">　　if （！img）</p>

  <p class="calibre1">　　return;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　// 根据UITableView对象的坐标系获取UIImageView对象的位置和大小</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">// 注意：这里也许会出现警告信息，下面很快就会讨论到</span></del></p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">CGRect rect = [self.viewconvertRect:cell.thumbnailView.bounds</span></del></p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">fromView:cell.thumbnailView];</span></del></p>

  <p class="calibre1"><span class="calibre10">　　CGRect rect = [self.viewconvertRect:strongCell.thumbnailView.bounds</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　fromView:strongCell.thumbnailView];</span><br class="calibre2"/></p>

  <p class="calibre1">　　// 创建BNRImageViewController对象并为image属性赋值</p>

  <p class="calibre1">　　BNRImageViewController *ivc = [[BNRImageViewController alloc] init];</p>

  <p class="calibre1">　　ivc.image = img;</p>

  <p class="calibre1">　　// 根据UIImageView对象的位置和大小</p>

  <p class="calibre1">　　// 显示一个大小为600x600点的UIPopoverController对象</p>

  <p class="calibre1">　　self.imagePopover = [[UIPopoverController alloc]</p>

  <p class="calibre1">　　initWithContentViewController:ivc];</p>

  <p class="calibre1">　　self.imagePopover.delegate = self;</p>

  <p class="calibre1">　　self.imagePopover.PopoverContentSize = CGSizeMake（600, 600）];</p>

  <p class="calibre1">　　[self.imagePopover presentPopoverFromRect:rect</p>

  <p class="calibre1">　　inView:self.view</p>

  <p class="calibre1">　　permittedArrowDirections:UIPopoverArrowDirectionAny</p>

  <p class="calibre1">　　animated:YES];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　};</p>

  <p class="calibre1">　　在Block对象执行过程中，必须保证Block对象始终可以访问cell。因此，以上代码在actionBlock内部创建了strongCell，以保持对cell的强引用。这与Block对象对捕获变量的强引用不同，strongCell只是在Block对象执行过程中对cell保持强引用。</p>

  <p class="calibre1">　　构建并运行应用，运行结果与之前相同，但是现在应用不会由于强引用循环导致内存泄露。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
