<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">14.4 项目、目标和构建设置</h2>

  <p class="calibre1">　　Xcode项目中都包含扩展名为。xcodeproj的文件，称为Xcode项目文件。文件中包含了项目设置、对项目中其他文件的引用（例如源代码、图片、框架、库等）和文件组的排列方式。TouchTracker的项目文件是TouchTracker.xcodeproj。</p>

  <p class="calibre1">　　每个Xcode项目又具有一个或多个目标（target）。构建并运行应用时，实际上并不是运行了Xcode项目，而是运行了一个目标。目标会根据项目中的文件和项目设置构建并生成一个特定的产品（product），最常见的产品就是应用，但也可能是库或者单元测试集（unit test bundle）。</p>

  <p class="calibre1">　　创建新项目时，Xcode会根据读者选择的项目模板自动创建一个目标。例如，创建TouchTracker时，读者选择的是iOS应用模板（iOS application template），因此Xcode会创建名为TouchTracker的iOS应用目标（iOS application target）。</p>

  <p class="calibre1">　　要查看目标的详细信息，可以单击项目导航面板顶部的TouchTracker项目文件，然后在编辑器区域找到用于显示/隐藏项目和目标列表的开关按钮，点击按钮显示TouchTracker的项目和目标列表，如图14-20所示。</p>

  <p class="calibre7"><img alt="tu14-20" src="../Images/image00560.jpeg" class="calibre8"/></p>

  <p class="calibre7">图14-20 TouchTracker的项目和目标列表</p>

  <p class="calibre1">　　所有的目标都会包含构建设置（build settings）。构建设置的作用是描述构建目标的方式。项目也会包含构建设置，项目的构建设置将成为其下所有目标的默认构建设置。下面介绍TouchTracker的项目构建设置。在项目和目标列表中选择TouchTracker项目，然后单击编辑器区域顶部的Build Settings标签（见图14-21）。Xcode会显示项目一级的构建设置，项目的目标会将这些设置作为默认值继承下来。通过编辑器区域右上角的搜索框，可以查找特定的设置。在查询框中输入Base SDK，Xcode会过滤显示内容并列出匹配的设置（Base SDK的作用是指定构建应用时使用的iOS SDK版本，请读者选择最新版本的iOS SDK）。</p>

  <p class="calibre7"><img alt="tu14-21" src="../Images/image00561.jpeg" class="calibre8"/></p>

  <p class="calibre7">图14-21 TouchTracker的项目构建设置</p>

  <p class="calibre1">　　在项目和目标列表中，先选择TouchTracker目标，然后选择Build Settings标签。Xcode会显示目标一级的构建设置，在设置列表上方找到并单击Levels（见图14-22）。</p>

  <p class="calibre7"><img alt="tu14-22" src="../Images/image00562.jpeg" class="calibre8"/></p>

  <p class="calibre7">图14-22 TouchTracker的目标构建设置</p>

  <p class="calibre1">　　Levels模式可以同时显示三种不同等级下的构建设置，这三种等级分别为：OS、project（项目）和target（目标）。最右侧的表格列会显示iOS Default（iOS默认）设置，即项目一级的默认设置，可以在项目一级的设置中覆盖。位于iOS Default左侧的列显示的是项目一级的设置，再往左显示的是当前目标的设置。Resolved列显示的是实际使用的设置，通常与位于表格最左侧的指定设置相同。单击不同等级中的表格单元，可以为相应等级的设置赋值。</p>

  <p class="calibre1">　　读者还可以尝试搜索static analyzer。搜索结果中的第一个设置选项是Analyze During 'Build‘。该选项默认为No，如果将其设置为Yes，Xcode会在构建应用时启动静态分析器。静态分析会增加项目的构建时间，但同时也可以帮助读者及时发现代码中的问题。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">构建配置</h3>

  <p class="calibre1">　　目标和项目还可以包含多个构建配置（build configurations），构建配置的作用是包含一组指定的构建设置。创建项目时，Xcode会创建两个构建配置：debug和release。对应debug配置的构建设置可以帮助调试应用，而对应release配置的构建设置会打开优化选项，加快应用的执行速度。</p>

  <p class="calibre1">　　下面查看TouchTracker的构建配置。选中TouchTracker项目，然后选中顶部的Info标签（见图14-23）。</p>

  <p class="calibre7"><img alt="tu14-23" src="../Images/image00563.jpeg" class="calibre8"/></p>

  <p class="calibre7">图14-23 构建配置列表</p>

  <p class="calibre1">　　Configurations区域中的表格会列出可以在项目和目标中使用的构建配置。通过表格下方的按钮可以增加或删除构建配置。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">修改构建设置</h3>

  <p class="calibre1">　　下面做一个练习，修改目标的构建设置：Preprocessor Macros（预处理宏），以巩固之前介绍的内容。预处理宏的作用之一是允许编译器根据条件编译不同的代码段。构建应用时，预处理宏会有已定义和未定义两种状态。只有当某个预处理宏是已定义时，编译器才会编译包含在该预处理指令中的代码。Xcode会在Preprocessor Macros条目中列出当前构建配置中所有已定义的预处理宏。</p>

  <p class="calibre1">　　首先在项目和目标列表中选中TouchTracker目标，然后在Build Settings面板中查找Preprocessor Macros。在Preprocessor Macros条目中，双击Debug配置行的第二列（值）。在新出现的表格中，增加一个条目：VIEW_DEBUG（见图14-24）。</p>

  <p class="calibre1">　　将VIEW_DEBUG加入Debug配置中的Preprocessor Macros后，当Xcode通过debug配置构建TouchTracker目标时，预处理宏VIEW_DEBUG就会处于已定义状态。</p>

  <p class="calibre1">　　下面为TouchTracker增加一些调试代码，并且要求Xcode只有在使用debug配置构建目标时，才能编译这些代码。UIView类有一个名为recursiveDescription的未公开方法，该方法可以向控制台输出应用的整个视图层次结构。但是Apple规定，凡是在App Store中发布的应用一律不能使用未公开的方法。因此，只有当VIEW_DEBUG是已定义的时候，才能调用该方法。</p>

  <p class="calibre7"><img alt="tu14-24" src="../Images/image00564.jpeg" class="calibre8"/></p>

  <p class="calibre7">图14-24 修改构建设置</p>

  <p class="calibre1">　　在BNRAppDelegate.m的application:didFinishLaunchingWithOptions:中加入以下代码：</p>

  <p class="calibre1">　　[self.window makeKeyAndVisible];</p>

  <p class="calibre1"><span class="calibre10">　　#ifdef VIEW_DEBUG</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSLog（@“%@”, [self.window</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　performSelector:@selector（recursiveDescription）]）；</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　#endif</span><br class="calibre2"/></p>

  <p class="calibre1">　　return YES;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　这段代码会向UIWindow对象发送recursiveDescription消息（因为recursiveDescription是未公开的方法，所以必须用performSelector:来发送消息才能避免Xcode发出警告信息）。recursiveDescription会向控制台输出当前视图（这里是UIWindow对象）的描述信息，然后是其包含的所有子视图的描述信息，接下来是子视图的子视图，依此类推。无论使用哪种配置构建目标，都可以保留这段代码。这是因为在release配置中，VIEW_DEBUG是未定义的，所以在为App Store构建应用时，Xcode不会编译调用recursiveDescription方法的这行代码。</p>

  <p class="calibre1">　　构建并运行应用，TouchTracker应该会向控制台输出当前窗口的整个视图层次结构。</p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
