<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">11.5 创建并使用键</h2>

  <p class="calibre1">　　将照片加入BNRImageStore对象时，需要针对不同的照片使用不同的键，然后将这个键赋给相应的BNRItem对象。当BNRDetailViewController对象要从BNRImageStore对象载入照片时，需要先从BNRItem对象得到照片的键，然后通过BNRImageStore对象查找相应的照片。在BNRItem.h中为BNRItem类添加itemKey属性，用来保存照片的键，代码如下：</p>

  <p class="calibre1">　　@property （nonatomic, readonly, strong） NSDate *dateCreated;</p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, copy） NSString *itemKey;</span><br class="calibre2"/></p>

  <p class="calibre1">　　照片的键不能重复，否则无法通过BNRImageStore对象中的字典对象准确地保存对象。有很多种途径可以生成无重复的字符串（unique string），本节将使用Cocoa Touch提供的一种机制，这种机制可以生成唯一标识（UUID，也称为GUID）。每一个NSUUID类的对象都表示一个唯一的UUID。UUID是基于当前时间、计数器（counter）和硬件标识（通常为无线网卡的MAC地址）等数据计算生成的。如果使用字符串表示UUID，则示例如下：</p>

  <p class="calibre1">　　4A73B5D2-A6F4-4B40-9F82-EA1E34C1DC04</p>

  <p class="calibre1">　　在BNRDetailViewController.m顶部导入BNRImageStore.h，代码如下：</p>

  <p class="calibre1">　　#import “BNRDetailViewController.h”</p>

  <p class="calibre1">　　#import “BNRItem.h”</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRImageStore.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　打开BNRItem.m，修改指定初始化方法，生成一个UUID并设置为itemKey：</p>

  <p class="calibre1">　　- （instancetype）initWithItemName:（NSString *）name</p>

  <p class="calibre1">　　valueInDollars:（int）value</p>

  <p class="calibre1">　　serialNumber:（NSString *）sNumber</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　// 调用父类的指定初始化方法</p>

  <p class="calibre1">　　self = [super init];</p>

  <p class="calibre1">　　// 父类的指定初始化方法是否成功创建了父类对象？</p>

  <p class="calibre1">　　if （self） {</p>

  <p class="calibre1">　　// 为对象变量设定初始值</p>

  <p class="calibre1">　　_itemName = name;</p>

  <p class="calibre1">　　_serialNumber = sNumber;</p>

  <p class="calibre1">　　_valueInDollars = value;</p>

  <p class="calibre1">　　// 设置_dateCreated的值为系统当前时间</p>

  <p class="calibre1">　　_dateCreated = [[NSDate alloc] init];</p>

  <p class="calibre1"><span class="calibre10">　　// 创建一个NSUUID对象，然后获取其NSString类型的值</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSUUID *uuid = [[NSUUID alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSString *key = [uuid UUIDString];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　_itemKey = key;</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　// 返回初始化后的对象的新地址</p>

  <p class="calibre1">　　return self;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　然后修改BNRDetailViewController.m中的imagePickerController:didFinish- PickingMediaWithInfo:，将UIImage对象存入BNRImageStore对象：</p>

  <p class="calibre1">　　- （void）imagePickerController:（UIImagePickerController *）picker</p>

  <p class="calibre1">　　didFinishPickingMediaWithInfo:（NSDictionary *）info</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　UIImage *image = info[UIImagePickerControllerOriginalImage];</p>

  <p class="calibre1"><span class="calibre10">　　// 以itemKey为键，将照片存入BNRImageStore对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[BNRImageStore sharedStore] setImage:image</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　forKey:self.item.itemKey];</span><br class="calibre2"/></p>

  <p class="calibre1">　　imageView.image = image;</p>

  <p class="calibre1">　　[self dismissViewControllerAnimated:YES completion:nil];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　每当BNRDetailViewController获取到UIImage对象之后，都会将其存入BNRImageStore对象。BNRImageStore对象与BNRItem对象都保存了UIImage对象的键，随时可以通过键找到需要的UIImage对象。</p>

  <p class="calibre1">　　类似地，在用户删除了某个BNRItem对象后，需要同时在BNRImageStore对象中删除对应的UIImage对象。在BNRDetailViewController.m顶部导入BNRImageStore.h，然后修改removeItem:方法，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRImageStore.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　@implementation BNRItemStore</p>

  <p class="calibre1">　　- （void）removeItem:（BNRItem *）item</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1"><span class="calibre10">　　NSString *key = item.itemKey;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[BNRImageStore sharedStore] deleteImageForKey:key];</span><br class="calibre2"/></p>

  <p class="calibre1">　　[self.privateItems removeObjectIdenticalTo:item];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　读者也许会问，为什么不直接为BNRItem添加一个属性指向UIImage对象呢？这样不就可以直接处理UIImage对象了吗？虽然目前确实可以这么做，但是当本书第18章升级Homepwner，将BNRItem对象与UIImage对象存入文件系统时，就会遇到问题。</p>

  <p class="calibre1">　　系统在创建了一个UIImage对象后，会将其保存在某块内存区域中，该内存区域有一个地址，称为内存地址。如果没有将UIImage对象从内存移动至文件系统，那么UIImage对象的内存地址将保持不变，确实可以通过添加一个UIImage属性，访问该属性指向的内存地址，找到对应的UIImage对象；但是，如果将UIImage对象存入文件系统，当应用重新启动时（第18章会详细介绍应用的生命周期），就需要将UIImage对象从文件系统载入内存，这时UIImage对象的内存地址会发生变化，无法使用之前的内存地址找到该对象。相反，如果使用键关联UIImage对象，BNRImageStore会先根据键在文件系统中找到对应的UIImage对象，然后将其载入内存，返回新的UIImage对象指针。因此，使用键可以正确地持久化保存UIImage对象。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
