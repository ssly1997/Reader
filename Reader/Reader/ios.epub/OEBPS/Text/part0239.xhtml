<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">28.5 传递数据</h2>

  <p class="calibre1">　　本书第10章介绍过，编写应用时，经常需要在视图控制器之间传递数据。为了演示如何在Storyboards中传递数据，本节将在Colorboard中添加一个颜色收藏列表，用于保存BNRColorViewController中用户选择的颜色。</p>

  <p class="calibre1">　　本节中的UITableView对象将不再使用Static Cells，而是使用Dynamic Prototypes（动态原型）。因此，接下来需要为UITableView对象实现一系列数据源方法。如果需要在数据源中返回不同类型的单元格，就可以使用动态原型。只要为不同类型的单元格分配唯一的重用标识，UITableView对象就可以根据数据源方法显示相应的单元格。</p>

  <p class="calibre1">　　在Colorboard.storyboard中，删除红色和绿色的两个视图控制器，然后选中UITableView对象，打开属性检视面板。接下来点击标题为Content的下拉菜单，改为Dynamic Prototypes，最后在画布中删除第二个UITableViewCell对象。这时storyboard看起来应该类似于图28-19。</p>

  <p class="calibre7"><img alt="tu28-19" src="../Images/image00708.jpeg" class="calibre8"/></p>

  <p class="calibre7">图28-19 动态原型</p>

  <p class="calibre1">　　下面选中唯一的UITableViewCell对象，在Identifier文本框中输入UITableViewCell（见图28-20）。</p>

  <p class="calibre7"><img alt="tu28-20" src="../Images/image00709.jpeg" class="calibre8"/></p>

  <p class="calibre7">图28-20 设置UITableViewCell对象的重用标识</p>

  <p class="calibre1">　　现在需要为Table View Controller创建对应的UITableViewController子类，以便为UITableView对象提供数据。创建一个新的NSObject子类，名为BNRPaletteView- Controller。</p>

  <p class="calibre1">　　打开BNRPaletteViewController.h，将其父类修改为UITableViewController。</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">@interface BNRPaletteViewController : NSObject</span></del></p>

  <p class="calibre1"><span class="calibre10">　　@interface BNRPaletteViewController : UITableViewController</span><br class="calibre2"/></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　再打开BNRPaletteViewController.m，导入BNRColorViewController.h，然后在类扩展中添加一个NSMutableArray属性。</p>

  <p class="calibre1">　　#import “BNRPaletteViewController.h”</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRColorViewController.h”?</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@interface BNRPaletteViewController （）</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic） NSMutableArray *colors;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@end</span><br class="calibre2"/></p>

  <p class="calibre1">　　@implementation BNRPaletteViewController</p>

  <p class="calibre1">　　接下来实现viewWillAppear:和UITableView对象的数据源方法：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillAppear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillAppear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.tableView reloadData];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　- （NSInteger）tableView:（UITableView *）tableView</p>

  <p class="calibre1">　　numberOfRowsInSection:（NSInteger）section</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　return [self.colors count];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　- （UITableViewCell *）tableView:（UITableView *）tableView</p>

  <p class="calibre1">　　cellForRowAtIndexPath:（NSIndexPath *）indexPath</p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UITableViewCell *cell =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[tableView dequeueReusableCellWithIdentifier:@“UITableViewCell”</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　forIndexPath:indexPath];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return cell;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　创建一个名为BNRColorDescription的NSObject子类，表示用户选择的颜色。</p>

  <p class="calibre1">　　打开BNRColorDescription.h，添加一个UIColor属性和NSString属性，分别表示颜色和颜色名称：</p>

  <p class="calibre1">　　@interface BNRColorDescription : NSObject</p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic） UIColor *color;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, copy） NSString *name;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　再打开BNRColorDescription.m，覆盖init方法，设置两个属性的默认值：</p>

  <p class="calibre1">　　@implementation BNRColorDescription</p>

  <p class="calibre1"><span class="calibre10">　　- （instancetype）init</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self = [super init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （self） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　_color = [UIColor colorWithRed:0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　green:0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　blue:1</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　alpha:1];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　_name = @“Blue”;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return self;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　为了测试代码是否可以正常工作，下面向BNRPaletteViewController的colors数组中添加一个BNRColorDescription对象。</p>

  <p class="calibre1">　　在BNRPaletteViewController.m中引入BNRColorDescription.h，然后覆盖colors的取方法，添加一个BNRColorDescription对象。</p>

  <p class="calibre1">　　#import “BNRPaletteViewController.h”</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRColorDescription.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　@implementation BNRPaletteViewController</p>

  <p class="calibre1"><span class="calibre10">　　- （NSMutableArray *）colors</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （！_colors） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　_colors = [NSMutableArray array];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRColorDescription *cd = [[BNRColorDescription alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[_colors addObject:cd];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return _colors;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　同时，更新数据源方法，显示颜色名称：</p>

  <p class="calibre1">　　- （UITableViewCell *）tableView:（UITableView *）tableView</p>

  <p class="calibre1">　　cellForRowAtIndexPath:（NSIndexPath *）indexPath</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　UITableViewCell *cell =</p>

  <p class="calibre1">　　[tableView dequeueReusableCellWithIdentifier:@“UITableViewCell”</p>

  <p class="calibre1">　　forIndexPath:indexPath];</p>

  <p class="calibre1"><span class="calibre10">　　BNRColorDescription *color = self.colors[indexPath.row];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　cell.textLabel.text = color.name;</span><br class="calibre2"/></p>

  <p class="calibre1">　　return cell;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用。现在应用应该可以点击UITableViewCell对象进入BNRColorViewController界面，但是存在两个问题：首先，BNRColorViewController无法显示正确的颜色；其次，BNRColorViewController会同时显示Back（返回）按钮和Done按钮，正确做法是，只有在添加新颜色以模态形式进入BNRColorViewController时才显示Done按钮。为了解决以上两个问题，需要在BNRPaletteViewController和BNRColorViewController之间传递需要的数据，包括BNRColorDescription对象以及该对象是否已经存在。</p>

  <p class="calibre1">　　打开BNRColorViewController.h，在顶部导入BNRColorDescription.h，然后添加两个新属性：第一个用于判断编辑的是新颜色还是已经存在的颜色；第二个用于表示正在编辑的颜色：</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRColorDescription.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　@interface BNRColorViewController : UIViewController</p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic） BOOL existingColor;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic） BNRColorDescription *colorDescription;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　当UIViewController对象触发UIStoryboardSegue对象时，它会收到prepareForSegue:sender:消息。prepareForSegue:sender:的两个参数分别是UIStoryboardSegue对象和动作控件。UIStoryboardSegue对象包含三个方面的信息：源视图控制器（source view controller）、目标视图控制器（destination view controller）和标识。为了区分不同的UIStoryboardSegue对象，下面为两个UIStoryboardSegue对象设置不同的标识。</p>

  <p class="calibre1">　　重新打开Colorboard.storyboard，选中modal样式的UIStoryboardSegue对象，然后打开属性检视面板，在Identifier文本框中输入NewColor（新颜色）；同样，选中push样式的UIStoryboardSegue对象，设置其Identifier为ExistingColor（已经存在的颜色），如图28-21所示。</p>

  <p class="calibre7"><img alt="tu28-21" src="../Images/image00710.jpeg" class="calibre8"/></p>

  <p class="calibre7">图28-21 为两个UIStoryboardSegue对象设置标识</p>

  <p class="calibre1">　　现在，两个UIStoryboardSegue对象都具有标识，因此，可以在程序中根据标识判断用户是正在添加新颜色还是选择了已经存在的颜色，并使用不同的方式为BNRColorView- Controller对象传入BNRColorDescription对象。打开BNRPaletteViewController.m，实现prepareForSegue:sender:方法：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）prepareForSegue:（UIStoryboardSegue *）segue sender:（id）sender</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （[segue.identifier isEqualToString:@“NewColor”]） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果是添加新颜色，</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 就创建一个BNRColorDescription对象并将其添加到colors数组中</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRColorDescription *color = [[BNRColorDescription alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.colors addObject:color];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 通过UIStoryboardSegue对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 设置BNRColorViewController对象的颜色（colorDescription属性）</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UINavigationController *nc =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　（UINavigationController *）segue.destinationViewController;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRColorViewController *mvc =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　（BNRColorViewController *）[nc topViewController];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　mvc.colorDescription = color;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　else if （[segue.identifier isEqualToString:@“ExistingColor”]） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 对于push样式的UIStoryboardSegue对象，sender是UITableViewCell对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSIndexPath *ip = [self.tableView indexPathForCell:sender];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRColorDescription *color = self.colors[ip.row];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 设置BNRColorViewController对象的颜色，</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 同时设置其existingColor属性为YES（该颜色已经存在）</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRColorViewController *cvc =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　（BNRColorViewController *）segue.destinationViewController;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　cvc.colorDescription = color;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　cvc.existingColor = YES;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　在prepareForSegue:sender:方法中，首先检查segue参数的identifier，确定触发的是哪个UIStoryboardSegue对象。如果用户点击了“＋”按钮，那么触发的segue是“NewColor”，需要创建一个新的BNRColorDescription对象并将其传给BNRColorView- Controller；如果用户选择了已经存在的颜色，那么触发的segue是“ExistingColor”，需要将用户选择的颜色传给BNRColorViewController（如果UIStoryboardSegue对象的动作控件是UITableViewCell对象，可以通过UITableViewCell对象知道用户选择的是哪个NSIndexPath对象）。</p>

  <p class="calibre1">　　（请注意，“NewColor”的destinationViewController是UINavigationController对象，而“ExistingColor”的destinationViewController是BNRColorViewController对象。打开storyboard文件，可以看到，modal样式的UIStoryboardSegue对象指向一个UINavigationController对象，而push样式的则指向一个BNRColorViewController对象。push样式的UIStoryboardSegue对象直接将BNRColorViewController对象压入已经存在的UINavigationController栈中。）</p>

  <p class="calibre1">　　下面还需要在BNRColorViewController中编写以下代码：如果用户选择的是已经存在的颜色，就不能显示Done按钮；需要根据colorDescription属性设置view的背景颜色、颜色名称和UISlider对象的滑块值；当BNRColorViewController的view从屏幕上消失时，需要保存用户选择的新颜色。</p>

  <p class="calibre1">　　在BNRColorViewController.m中覆盖viewWillAppear:方法，如果颜色已经存在，就移除Done按钮：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillAppear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillAppear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果颜色已经存在，就移除Done按钮</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （self.existingColor） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.navigationItem.rightBarButtonItem = nil;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　接下来覆盖viewDidLoad方法，初始化view的背景颜色、颜色名称和UISlider对象的滑块值。</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewDidLoad</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewDidLoad];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIColor *color = self.colorDescription.color;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 从UIColor对象中取出RGB颜色分量</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　float red, green, blue;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[color getRed:&amp;red</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　green:&amp;green</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　blue:&amp;blue</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　alpha:nil];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 初始化UISlider对象的滑块值</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.redSlider.value = red;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.greenSlider.value = green;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.blueSlider.value = blue;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 初始化view的背景颜色和颜色名称</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.view.backgroundColor = color;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.textField.text = self.colorDescription.name;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　最后，当view消失时保存颜色和颜色名称。</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillDisappear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillDisappear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.colorDescription.name = self.textField.text;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.colorDescription.color = self.view.backgroundColor;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　构建并运行应用，Colorboard应该可以正确地显示并保存颜色。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
