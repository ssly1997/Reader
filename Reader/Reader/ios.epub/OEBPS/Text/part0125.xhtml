<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">13.6 UIPanGestureRecognizer以及同时识别多个手势</h2>

  <p class="calibre1">　　当用户按住某根线条不放时，TouchTracker应该允许用户通过移动手指来拖曳选中的线条。这类手势称为拖动（pan），可以用UIPanGestureRecognizer对象来识别。</p>

  <p class="calibre1">　　通常情况下，UIGestureRecognizer对象不会将其处理过的触摸事件再交给其他对象来处理。一旦某个UIGestureRecognizer子类对象识别出了相应的手势，就会“吃掉”所有相关的触摸事件，导致其他UIGestureRecognizer对象没有机会再处理这些触摸事件。对TouchTracker，这种特性会导致BNRDrawView对象无法处理拖动手势，这是因为整个拖动手势都是在长按手势中发生的。要解决这个问题，需要让UILongPressGestureRecognizer对象和UIPanGestureRecognizer对象能够同时识别手势。</p>

  <p class="calibre1">　　在BNRDrawView.m的类扩展中将BNRDrawView声明为遵守UIGestureRecognizer- Delegate协议。然后声明一个类型为UIPanGestureRecognizer的属性，代码如下：</p>

  <p class="calibre1">　　@interface BNRDrawView （） <span class="calibre10">&lt;UIGestureRecognizerDelegate&gt;</span></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, strong） UIPanGestureRecognizer *moveRecognizer;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@property （nonatomic, strong） NSMutableDictionary *linesInProgress;</p>

  <p class="calibre1">　　@property （nonatomic, strong） NSMutableArray *finishedLines;</p>

  <p class="calibre1">　　@property （nonatomic, weak） BNRLine *selectedLine;</p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　更新BNRDrawView.m中的<span class="calibre10">initWithFrame:</span>，创建一个<span class="calibre10">UIPanGestureRecognizer</span>对象，设置属性，然后将该对象附着在<span class="calibre10">BNRDrawView</span>对象上，代码如下：</p>

  <p class="calibre1">　　[self addGestureRecognizer:pressRecognizer];</p>

  <p class="calibre1"><span class="calibre10">　　self.moveRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　action:@selector（moveLine:）];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.moveRecognizer.delegate = self;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.moveRecognizer.cancelsTouchesInView = NO;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self addGestureRecognizer:self.moveRecognizer];</span><br class="calibre2"/></p>

  <p class="calibre1">　　UIGestureRecognizerDelegate协议声明了很多方法，目前BNRDrawView只需要用到其中的一个：gestureRecognizer:shouldRecognizeSimultaneouslyWith- GestureRecognizer:。当某个UIGestureRecognizer子类对象识别出特定的手势后，如果发现其他的UIGestureRecognizer子类对象也识别出了特定的手势，就会向其委托对象发送gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:消息。如果相应的方法返回YES，那么当前的<span class="calibre10">UIGestureRecognizer</span>子类对象就会和其他<span class="calibre10">UIGestureRecognizer</span>子类对象共享UITouch对象。</p>

  <p class="calibre1">　　在BNRDrawView.m中，如果消息的发送方是_moveRecognizer，就返回YES；否则返回NO，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （BOOL）gestureRecognizer:（UIGestureRecognizer *）gestureRecognizer</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　shouldRecognizeSimultaneouslyWithGestureRecognizer:（UIGestureRecognizer *）other</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （gestureRecognizer == self.moveRecognizer） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return YES;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return NO;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　完成上述修改后，当用户长按某根线条不放时，<span class="calibre10">UIPanGestureRecognizer</span>对象也能收到相关的<span class="calibre10">UITouch</span>对象，从而可以跟踪用户的手指移动。当用户的手指开始移动时，<span class="calibre10">UIPanGestureRecognizer</span>对象的状态也会切换至“开始”。如果<span class="calibre10">UILongPress- GestureRecognizer</span>对象和<span class="calibre10">UIPanGestureRecognizer</span>对象不能同时识别手势，那么当用户的手指开始在屏幕上移动时，<span class="calibre10">UILongPressGestureRecognizer</span>对象的状态还是会切换至“开始”，但是<span class="calibre10">UIPanGestureRecognizer</span>对象的状态不会发生变化，也不会向其目标对象发送动作消息。</p>

  <p class="calibre1">　　除了之前介绍的三种状态，<span class="calibre10">UIPanGestureRecognizer</span>对象还有一种变化后（changed）状态。当手指开始移动时，<span class="calibre10">UIPanGestureRecognizer</span>对象会进入“开始”状态，并向其目标对象发送指定的动作消息。当手指在屏幕上移动时，<span class="calibre10">UIPanGestureRecognizer</span>对象的状态会切换至“变化后”状态，并持续地向其目标对象发送指定的动作消息。最后，当手指离开屏幕时，<span class="calibre10">UIPanGestureRecognizer</span>对象的状态会切换至“结束”状态，并向其目标对象最后一次发送指定的动作消息。</p>

  <p class="calibre1">　　下面要实现<span class="calibre10">UIPanGestureRecognizer</span>对象的动作方法<span class="calibre10">moveLine:</span>。在<span class="calibre10">moveLine:</span>中，要调用<span class="calibre10">UIPanGestureRecognizer</span>对象的<span class="calibre10">translationInView:</span>方法。该方法会根据传入的<span class="calibre10">UIView</span>对象的坐标系，以CGPoint结构的形式返回手指的拖动距离。当拖动手势开始时，拖动距离是0点（x和y都是0）。拖动的过程中，拖动距离会不断发生变化（将手指移动至窗口的最右端，x的值就会很高。将手指移回手势的起始位置，拖动距离就会变回0点）。</p>

  <p class="calibre1">　　在BNRDrawView.m中实现<span class="calibre10">moveLine:</span>。因为调用该方法的将是<span class="calibre10">UIPanGestureRecognizer</span>对象，所以可以将<span class="calibre10">moveLine:</span>的传入实参类型声明为<span class="calibre10">UIPanGestureRecognizer</span>对象，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）moveLine:（UIPanGestureRecognizer *）gr</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果没有选中的线条就直接返回</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （！self.selectedLine） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果UIPanGestureRecognizer对象处于“变化后”状态</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （gr.state == UIGestureRecognizerStateChanged） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 获取手指的拖移距离</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　CGPoint translation = [gr translationInView:self];</span><br class="calibre2"/></p>

  <p class="calibre1">　　// 将拖移距离加至选中的线条的起点和终点</p>

  <p class="calibre1"><span class="calibre10">　　CGPoint begin = self.selectedLine.begin;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　CGPoint end = self.selectedLine.end;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　begin.x += translation.x;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　begin.y += translation.y;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　end.x += translation.x;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　end.y += translation.y;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 为选中的线条设置新的起点和终点</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.selectedLine.begin = begin;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.selectedLine.end = end;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 重画视图</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self setNeedsDisplay];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　构建并运行应用。画一根线条，按住这根线条不放并开始拖移。读者会发现当前选中的线条位置并不能和手指的位置保持一致。这是因为<span class="calibre10">moveLine:</span>会持续累加当前选中的线条的起点和终点。如果<span class="calibre10">UIPanGestureRecognizer</span>对象可以增量地报告拖移距离（以上次调用<span class="calibre10">moveLine:</span>时的位置为起点），就能解决上述问题。<span class="calibre10">UIPanGestureRecognizer</span>有一个名为<span class="calibre10">setTranslation:</span>的方法，调用该方法并传入CGPointZero，就能将手指的当前位置设置为拖移手势的起始位置。因此，只需要在<span class="calibre10">UIPanGestureRecognizer</span>对象报告位置变化时，向其发送<span class="calibre10">setTranslation:</span>消息并传入CGPointZero，就能使该对象增量地报告拖移距离。</p>

  <p class="calibre1">　　在BNRDrawView.m的<span class="calibre10">moveLine:</span>底部，加入下面这行代码。</p>

  <p class="calibre1">　　[self setNeedsDisplay];</p>

  <p class="calibre1"><span class="calibre10">　　[gr setTranslation:CGPointZero inView:self];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，画一根线条，按住这根线条不放并开始拖移。当前选中的线条位置应该会和手指的位置保持一致。</p>

  <p class="calibre1">　　在BNRDrawView.m的<span class="calibre10">initWithFrame:</span>中，TouchTracker还设置了<span class="calibre10">UIPanGesture- Recognizer</span>对象的cancelsTouchesInView属性。该属性的默认值是YES，当某个<span class="calibre10">UIGestureRecognizer</span>对象的cancelsTouchesInView属性为YES时，这个对象会在识别出特定的手势时，“吃掉”所有和该手势有关的<span class="calibre10">UITouch</span>对象。这样，该对象所依附的<span class="calibre10">UIView</span>对象将不会收到之前介绍过的那些<span class="calibre10">UIResponder</span>消息，例如<span class="calibre10">touchesBegan:withEvent:</span>。</p>

  <p class="calibre1">　　通常情况下，上述特性是符合开发预期的，但是也有例外。以TouchTracker为例，如果<span class="calibre10">UIPanGestureRecognizer</span>对象在识别出拖移手势时吃掉了所有相关的<span class="calibre10">UITouch</span>对象，那么<span class="calibre10">BNRDrawView</span>对象将没有机会处理这些<span class="calibre10">UITouch</span>对象，也就无法创建相应的<span class="calibre10">BNRLine</span>对象。</p>

  <p class="calibre1">　　当某个<span class="calibre10">UIGestureRecognizer</span>对象的cancelsTouchesInView属性为NO时，这个对象所依附的<span class="calibre10">UIView</span>对象仍然会收到相应的<span class="calibre10">UIResponder</span>消息，从而有机会处理相关的<span class="calibre10">UITouch</span>对象。读者可以尝试注释掉那行设置cancelsTouchesInView属性的代码，检验效果。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
