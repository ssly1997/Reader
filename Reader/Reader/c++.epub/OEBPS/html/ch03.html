<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3. Modularity</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch03"><a id="page_23"/><span class="pd_blue">3.</span> Modularity</h2>
<p class="blockquote"><em>Don&#8217;t interrupt me while I&#8217;m interrupting.</em></p>
<p class="attribution"><em>&#8211; Winston S. Churchill</em></p>
<p class="indenthangingB">&#8226; <a href="ch03.html#ch03lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch03.html#ch03lev1sec2">Separate Compilation</a></p>
<p class="indenthangingB">&#8226; <a href="ch03.html#ch03lev1sec3">Namespaces</a></p>
<p class="indenthangingB">&#8226; <a href="ch03.html#ch03lev1sec4">Error Handling</a></p>
<p class="indenthangingBP"><a href="ch03.html#ch03lev2sec1">Exceptions</a>; <a href="ch03.html#ch03lev2sec2">Invariants</a>; <a href="ch03.html#ch03lev2sec3">Static Assertions</a></p>
<p class="indenthangingB">&#8226; <a href="ch03.html#ch03lev1sec5">Advice</a></p>
<div class="heading">
<h3 id="ch03lev1sec1">3.1. Introduction</h3>
<p class="noindent">A C++ program consists of many separately developed parts, such as functions (&#167;<a href="ch01.html#ch01lev1sec3">1.3</a>), user-defined types (<a href="ch02.html#ch02">Chapter 2</a>), class hierarchies (&#167;<a href="ch04.html#ch04lev1sec5">4.5</a>), and templates (<a href="ch05.html#ch05">Chapter 5</a>). The key to managing this is to clearly define the interactions among those parts. The first and most important step is to distinguish between the interface to a part and its implementation. At the language level, C++ represents interfaces by declarations. A <em>declaration</em> specifies all that&#8217;s needed to use a function or a type. For example:</p>
</div>
<p class="codelink"><a id="p023pro01" href="ch03_images.html#p023pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double sqrt(double);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the square root function takes a double and returns a double</span><br/><br/><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(int s);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size();</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem; //</span> <span class="EmpItalic">elem points to an array of sz doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent"><a id="page_24"/>The key point here is that the function bodies, the function <em>definitions</em>, are &#8220;elsewhere.&#8221; For this example, we might like for the representation of <span class="EmpStrong">Vector</span> to be &#8220;elsewhere&#8221; also, but we will deal with that later (abstract types; &#167;<a href="ch04.html#ch04lev1sec3">4.3</a>). The definition of <span class="EmpStrong">sqrt()</span> will look like this:</p>
<p class="codelink"><a id="p024pro01" href="ch03_images.html#p024pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double sqrt(double d)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">definition of sqrt()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... algorithm as found in math textbook ...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">For <span class="EmpStrong">Vector</span>, we need to define all three member functions:</p>
<p class="codelink"><a id="p024pro02" href="ch03_images.html#p024pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector::Vector(int s)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">definition of the constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">:elem{new double[s]}, sz{s}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize members</span><br/><span class="EmpStrong">{</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">double&#38; Vector::operator[](int i)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">definition of subscripting</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return elem[i];</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">int Vector::size()</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">definition of size()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return sz;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">We must define <span class="EmpStrong">Vector</span>&#8217;s functions, but not <span class="EmpStrong">sqrt()</span> because it is part of the standard library. However, that makes no real difference: a library is simply some &#8220;other code we happen to use&#8221; written with the same language facilities as we use.</p>
<div class="heading">
<h3 id="ch03lev1sec2">3.2. Separate Compilation</h3>
<p class="noindent">C++ supports a notion of separate compilation where user code sees only declarations of the types and functions used. The definitions of those types and functions are in separate source files and compiled separately. This can be used to organize a program into a set of semi-independent code fragments. Such separation can be used to minimize compilation times and to strictly enforce separation of logically distinct parts of a program (thus minimizing the chance of errors). A library is often a collection of separately compiled code fragments (e.g., functions).</p>
</div>
<p class="indent">Typically, we place the declarations that specify the interface to a module in a file with a name indicating its intended use. For example:</p>
<p class="codelink"><a id="p024pro03" href="ch03_images.html#p024pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">//</span> <span class="EmpItalic">Vector.h:</span><br/><br/><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(int s);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size();</span><br/><span class="EmpStrong"><a id="page_25"/>private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">elem points to an array of sz doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">This declaration would be placed in a file <span class="EmpStrong">Vector.h</span>, and users will <em>include</em> that file, called a <em>header file</em>, to access that interface. For example:</p>
<p class="codelink"><a id="p025pro01" href="ch03_images.html#p025pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">//</span> <span class="EmpItalic">user.cpp:</span><br/><br/><span class="EmpStrong">#include "Vector.h"</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get Vector's interface</span><br/><span class="EmpStrong">#include &lt;cmath&gt;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get the the standard-library math function interface including sqrt()</span><br/><br/><span class="EmpStrong">using namespace std;</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">make std members visible (&#167;3.3)</span><br/><br/><span class="EmpStrong">double sqrt_sum(Vector&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">double sum = 0;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=v.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sum+=sqrt(v[i]);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">sum of square roots</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return sum;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">To help the compiler ensure consistency, the <span class="EmpStrong">.cpp</span> file providing the implementation of <span class="EmpStrong">Vector</span> will also include the <span class="EmpStrong">.h</span> file providing its interface:</p>
<p class="codelink"><a id="p025pro02" href="ch03_images.html#p025pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">//</span> <span class="EmpItalic">Vector.cpp:</span><br/><br/><span class="EmpStrong">#include "Vector.h" //</span> <span class="EmpItalic">get the interface</span><br/><br/><span class="EmpStrong">Vector::Vector(int s)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">:elem{new double[s]}, sz{s}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize members</span><br/><span class="EmpStrong">{</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">double&#38; Vector::operator[](int i)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return elem[i];</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">int Vector::size()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return sz;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The code in <span class="EmpStrong">user.cpp</span> and <span class="EmpStrong">Vector.cpp</span> shares the <span class="EmpStrong">Vector</span> interface information presented in <span class="EmpStrong">Vector.h</span>, but the two files are otherwise independent and can be separately compiled. Graphically, the program fragments can be represented like this:</p>
<div class="image"><a id="page_26"/><img src="graphics/026fig01.jpg" alt="Image"/></div>
<p class="noindent">Strictly speaking, using separate compilation isn&#8217;t a language issue; it is an issue of how best to take advantage of a particular language implementation. However, it is of great practical importance. The best approach is to maximize modularity, represent that modularity logically through language features, and then exploit the modularity physically through files for effective separate compilation.</p>
<div class="heading">
<h3 id="ch03lev1sec3">3.3. Namespaces</h3>
<p class="noindent">In addition to functions (&#167;<a href="ch01.html#ch01lev1sec4">1.4</a>), classes (&#167;<a href="ch02.html#ch02lev1sec3">2.3</a>), and enumerations (&#167;<a href="ch02.html#ch02lev1sec5">2.5</a>), C++ offers <em>namespaces</em> as a mechanism for expressing that some declarations belong together and that their names shouldn&#8217;t clash with other names. For example, I might want to experiment with my own complex number type (&#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>, &#167;<a href="ch12.html#ch12lev1sec4">12.4</a>):</p>
</div>
<p class="codelink"><a id="p026pro01" href="ch03_images.html#p026pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">namespace My_code {</span><br/>&#160;&#160;&#160;<span class="EmpStrong">class complex {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;<span class="EmpStrong">};</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">complex sqrt(complex);</span><br/>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">int main();</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">int My_code::main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex z {1,2};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto z2 = sqrt(z);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">std::cout &lt;&lt; '{' &lt;&lt; z2.real() &lt;&lt; ',' &lt;&lt; z2.imag() &lt;&lt; "}\n";</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return My_code::main();</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_27"/>By putting my code into the namespace <span class="EmpStrong">My_code</span>, I make sure that my names do not conflict with the standard-library names in namespace <span class="EmpStrong">std</span> (&#167;<a href="ch03.html#ch03lev1sec3">3.3</a>). The precaution is wise, because the standard library does provide support for <span class="EmpStrong">complex</span> arithmetic (&#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>, &#167;<a href="ch12.html#ch12lev1sec4">12.4</a>).</p>
<p class="indent">The simplest way to access a name in another namespace is to qualify it with the namespace name (e.g., <span class="EmpStrong">std::cout</span> and <span class="EmpStrong">My_code::main</span>). The &#8220;real <span class="EmpStrong">main()</span> &#8221; is defined in the global namespace, that is, not local to a defined namespace, class, or function. To gain access to names in the standard-library namespace, we can use a <span class="EmpStrong">using</span>-directive:</p>
<p class="pre"><span class="EmpStrong">using namespace std;</span></p>
<p class="noindent">A <span class="EmpStrong">using</span>-directive makes names from the named namespace accessible as if they were local to the scope in which we placed the directive. So after the <span class="EmpStrong">using</span>-directive for <span class="EmpStrong">std</span>, we can simply write <span class="EmpStrong">cout</span> rather than <span class="EmpStrong">std::std</span>.</p>
<p class="indent">Namespaces are primarily used to organize larger program components, such as libraries. They simplify the composition of a program out of separately developed parts.</p>
<div class="heading">
<h3 id="ch03lev1sec4">3.4. Error Handling</h3>
<p class="noindent">Error handling is a large and complex topic with concerns and ramifications that go far beyond language facilities into programming techniques and tools. However, C++ provides a few features to help. The major tool is the type system itself. Instead of painstakingly building up our applications from the built-in types (e.g., <span class="EmpStrong">char</span>, <span class="EmpStrong">int,</span> and <span class="EmpStrong">double</span>) and statements (e.g., <span class="EmpStrong">if</span>, <span class="EmpStrong">while,</span> and <span class="EmpStrong">for</span>), we build more types that are appropriate for our applications (e.g., <span class="EmpStrong">string</span>, <span class="EmpStrong">map</span>, and <span class="EmpStrong">regex</span>) and algorithms (e.g., <span class="EmpStrong">sort()</span>, <span class="EmpStrong">find_if()</span>, and <span class="EmpStrong">draw_all()</span>). Such higher-level constructs simplify our programming, limit our opportunities for mistakes (e.g., you are unlikely to try to apply a tree traversal to a dialog box), and increase the compiler&#8217;s chances of catching such errors. The majority of C++ constructs are dedicated to the design and implementation of elegant and efficient abstractions (e.g., user-defined types and algorithms using them). One effect of this modularity and abstraction (in particular, the use of libraries) is that the point where a run-time error can be detected is separated from the point where it can be handled. As programs grow, and especially when libraries are used extensively, standards for handling errors become important. It is a good idea to design and articulate a strategy for error handling early on in the development of a program.</p>
</div>
<div class="heading">
<h4 id="ch03lev2sec1">3.4.1. Exceptions</h4>
<p class="noindent">Consider again the <span class="EmpStrong">Vector</span> example. What <em>ought</em> to be done when we try to access an element that is out of range for the vector from &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>?</p>
</div>
<p class="indenthangingB">&#8226; The writer of <span class="EmpStrong">Vector</span> doesn&#8217;t know what the user would like to have done in this case (the writer of <span class="EmpStrong">Vector</span> typically doesn&#8217;t even know in which program the vector will be running).</p>
<p class="indenthangingB">&#8226; The user of <span class="EmpStrong">Vector</span> cannot consistently detect the problem (if the user could, the out-of-range access wouldn&#8217;t happen in the first place).</p>
<p class="noindent">The solution is for the <span class="EmpStrong">Vector</span> implementer to detect the attempted out-of-range access and then tell the user about it. The user can then take appropriate action. For example, <span class="EmpStrong">Vector::operator[]()</span> can detect an attempted out-of-range access and throw an <span class="EmpStrong">out_of_range</span> exception:</p>
<p class="codelink"><a id="page_28"/><a id="p028pro01" href="ch03_images.html#p028pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double&#38; Vector::operator[](int i)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (i&lt;0 || size()&lt;=i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw out_of_range{"Vector::operator[]"};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return elem[i];</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">throw</span> transfers control to a handler for exceptions of type <span class="EmpStrong">out_of_range</span> in some function that directly or indirectly called <span class="EmpStrong">Vector::operator[]()</span>. To do that, the implementation will <em>unwind</em> the function call stack as needed to get back to the context of that caller. That is, the exception handling mechanism will exit scopes and function as needed to get back to a caller that has expressed interest in handling that kind of exception, invoking destructors (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>) along the way as needed. For example:</p>
<p class="codelink"><a id="p028pro02" href="ch03_images.html#p028pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(Vector&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try { //</span> <span class="EmpItalic">exceptions here are handled by the handler defined below</span><br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v[v.size()] = 7;</span>&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">try to access beyond the end of v</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (out_of_range) {</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">oops: out_of_range error</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... handle range error ...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">We put code for which we are interested in handling exceptions into a <span class="EmpStrong">try</span>-block. That attempted assignment to <span class="EmpStrong">v[v.size()]</span> will fail. Therefore, the <span class="EmpStrong">catch</span>-clause providing a handler for <span class="EmpStrong">out_of_range</span> will be entered. The <span class="EmpStrong">out_of_range</span> type is defined in the standard library (in <span class="EmpStrong">&lt;stdexcept&gt;</span>) and is in fact used by some standard-library container access functions.</p>
<p class="indent">Use of the exception-handling mechanisms can make error handling simpler, more systematic, and more readable. To achieve that don&#8217;t overuse <span class="EmpStrong">try</span>-statements. The main technique for making error handling simple and systematic (called <em>Resource Aquisition Is Initialization</em>) is explained in &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>.</p>
<p class="indent">A function that should never throw an exception can be declared <span class="EmpStrong">noexcept</span>. For example:</p>
<p class="codelink"><a id="p028pro03" href="ch03_images.html#p028pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void user(int sz) noexcept</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v(sz);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">iota(&#38;v[0],&#38;v[sz],1); //</span> <span class="EmpItalic">fill v with 1,2,3,4...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">If all good intent and planning fails, so that <span class="EmpStrong">user()</span> still throws, the standard-library function <span class="EmpStrong">terminate()</span> is called to immediately terminate the program.</p>
<div class="heading">
<h4 id="ch03lev2sec2"><a id="page_29"/>3.4.2. Invariants</h4>
<p class="noindent">The use of exceptions to signal out-of-range access is an example of a function checking its argument and refusing to act because a basic assumption, a <em>precondition</em>, didn&#8217;t hold. Had we formally specified <span class="EmpStrong">Vector</span>&#8217;s subscript operator, we would have said something like &#8220;the index must be in the [<span class="EmpStrong">0</span>:<span class="EmpStrong">size()</span>) range,&#8221; and that was in fact what we tested in our <span class="EmpStrong">operator[]()</span>. The [<span class="EmpStrong">a</span>:<span class="EmpStrong">b</span>) notation specifies a half-open range, meaning that <span class="EmpStrong">a</span> is part of the range, but <span class="EmpStrong">b</span> is not. Whenever we define a function, we should consider what its preconditions are and if feasible test them.</p>
</div>
<p class="indent">However, <span class="EmpStrong">operator[]()</span> operates on objects of type <span class="EmpStrong">Vector</span> and nothing it does makes any sense unless the members of <span class="EmpStrong">Vector</span> have &#8220;reasonable&#8221; values. In particular, we did say &#8220;<span class="EmpStrong">elem</span> points to an array of <span class="EmpStrong">sz</span> doubles&#8221; but we only said that in a comment. Such a statement of what is assumed to be true for a class is called a <em>class invariant</em>, or simply an <em>invariant</em>. It is the job of a constructor to establish the invariant for its class (so that the member functions can rely on it) and for the member functions to make sure that the invariant holds when they exit. Unfortunately, our <span class="EmpStrong">Vector</span> constructor only partially did its job. It properly initialized the <span class="EmpStrong">Vector</span> members, but it failed to check that the arguments passed to it made sense. Consider:</p>
<p class="pre"><span class="EmpStrong">Vector v(-27);</span></p>
<p class="noindent">This is likely to cause chaos.</p>
<p class="indent">Here is a more appropriate definition:</p>
<p class="codelink"><a id="p029pro01" href="ch03_images.html#p029pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector::Vector(int s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (s&lt;0)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw length_error{};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">elem = new double[s];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">sz = s;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">I use the standard-library exception <span class="EmpStrong">length_error</span> to report a non-positive number of elements because some standard-library operations use that exception to report problems of this kind. If operator <span class="EmpStrong">new</span> can&#8217;t find memory to allocate, it throws a <span class="EmpStrong">std::bad_alloc</span>. We can now write:</p>
<p class="codelink"><a id="p029pro02" href="ch03_images.html#p029pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v(-27);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (std::length_error) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">handle negative size</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (std::bad_alloc) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">handle memory exhaustion</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">You can define your own classes to be used as exceptions and have them carry arbitrary information from a point where an error is detected to a point where it can be handled (&#167;<a href="ch03.html#ch03lev2sec1">3.4.1</a>).</p>
<p class="indent"><a id="page_30"/>Often, a function has no way of completing its assigned task after an exception is thrown. Then, &#8220;handling&#8221; an exception simply means doing some minimal local cleanup and rethrowing the exception. To throw (<em>rethrow</em>) the exception caught in an exception handler, we simply write <span class="EmpStrong">throw;</span>. For example:</p>
<p class="codelink"><a id="p030pro01" href="ch03_images.html#p030pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v(-27);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (std::length_error) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "test failed: length error\n";</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">rethrow</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (std::bad_alloc) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Ouch! test() is not designed to handle memory exhaustion</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">std::terminate();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">terminate the program</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The notion of invariants is central to the design of classes, and preconditions serve a similar role in the design of functions. Invariants</p>
<p class="indenthangingB">&#8226; helps us to understand precisely what we want</p>
<p class="indenthangingB">&#8226; forces us to be specific; that gives us a better chance of getting our code correct (after debugging and testing).</p>
<p class="noindent">The notion of invariants underlies C++&#8217;s notions of resource management supported by constructors (<a href="ch04.html#ch04">Chapter 4</a>) and destructors (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>, &#167;<a href="ch11.html#ch11lev1sec2">11.2</a>).</p>
<div class="heading">
<h4 id="ch03lev2sec3">3.4.3. Static Assertions</h4>
<p class="noindent">Exceptions report errors found at run time. If an error can be found at compile time, it is usually preferable to do so. That&#8217;s what much of the type system and the facilities for specifying the interfaces to user-defined types are for. However, we can also perform simple checks on other properties that are known at compile time and report failures as compiler error messages. For example:</p>
</div>
<p class="codelink"><a id="p030pro02" href="ch03_images.html#p030pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">static_assert(4&lt;=sizeof(int), "integers are too small"); //</span> <span class="EmpItalic">check integer size</span></p>
<p class="noindent">This will write <span class="EmpStrong">integers are too small</span> if <span class="EmpStrong">4&lt;=sizeof(int)</span> does not hold, that is, if an <span class="EmpStrong">int</span> on this system does not have at least 4 bytes. We call such statements of expectations <em>assertions</em>.</p>
<p class="indent">The <span class="EmpStrong">static_assert</span> mechanism can be used for anything that can be expressed in terms of constant expressions (&#167;<a href="ch01.html#ch01lev1sec7">1.7</a>). For example:</p>
<p class="codelink"><a id="p030pro03" href="ch03_images.html#p030pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">constexpr double C = 299792.458;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">km/s</span><br/><br/><span class="EmpStrong">void f(double speed)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const double local_max = 160.0/(60*60);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">160 km/h == 160.0/(60*60) km/s</span><br/><a id="page_31"/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">static_asser t(speed&lt;C,"can't go that fast");</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: speed must be a constant</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">static_assert(local_max&lt;C,"can't go that fast"); //</span> <span class="EmpItalic">OK</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">In general, <span class="EmpStrong">static_assert(A,S)</span> prints <span class="EmpStrong">S</span> as a compiler error message if <span class="EmpStrong">A</span> is not <span class="EmpStrong">true</span>.</p>
<p class="indent">The most important uses of <span class="EmpStrong">static_assert</span> come when we make assertions about types used as parameters in generic programming (&#167;<a href="ch05.html#ch05lev1sec4">5.4</a>, &#167;<a href="ch11.html#ch11lev1sec6">11.6</a>).</p>
<p class="indent">For runtime-checked assertions, use exceptions.</p>
<div class="heading">
<h3 id="ch03lev1sec5">3.5. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in <a href="ch13.html#ch13">Chapters 13</a>-15 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Distinguish between declarations (used as interfaces) and definitions (used as implementations); &#167;<a href="ch03.html#ch03lev1sec1">3.1</a>.</p>
<p class="ref">[3] Use header files to represent interfaces and to emphasize logical structure; &#167;<a href="ch03.html#ch03lev1sec2">3.2</a>.</p>
<p class="ref">[4] <span class="EmpStrong">#include</span> a header in the source file that implements its functions; &#167;<a href="ch03.html#ch03lev1sec2">3.2</a>.</p>
<p class="ref">[5] Avoid non-inline function definitions in headers; &#167;<a href="ch03.html#ch03lev1sec2">3.2</a>.</p>
<p class="ref">[6] Use namespaces to express logical structure; &#167;<a href="ch03.html#ch03lev1sec3">3.3</a>.</p>
<p class="ref">[7] Use <span class="EmpStrong">using</span>-directives for transition, for foundational libraries (such as <span class="EmpStrong">std</span>), or within a local scope; &#167;<a href="ch03.html#ch03lev1sec3">3.3</a>.</p>
<p class="ref">[8] Don&#8217;t put a <span class="EmpStrong">using</span>-directive in a header file; &#167;<a href="ch03.html#ch03lev1sec3">3.3</a>.</p>
<p class="ref">[9] Throw an exception to indicate that you cannot perform an assigned task; &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="ref1">[10] Use exceptions for error handling; &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="ref1">[11] Develop an error-handling strategy early in a design; &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="ref1">[12] Use purpose-designed user-defined types as exceptions (not built-in types); &#167;<a href="ch03.html#ch03lev2sec1">3.4.1</a>.</p>
<p class="ref1">[13] Don&#8217;t try to catch every exception in every function; &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="ref1">[14] If your function may not throw, declare it <span class="EmpStrong">noexcept</span>; &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="ref1">[15] Let a constructor establish an invariant, and throw if it cannot; &#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>.</p>
<p class="ref1">[16] Design your error-handling strategy around invariants; &#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>.</p>
<p class="ref1">[17] What can be checked at compile time is usually best checked at compile time (using <span class="EmpStrong">static_assert</span>); &#167;<a href="ch03.html#ch03lev2sec3">3.4.3</a>.</p>
</body>
</html>
