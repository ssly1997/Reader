<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>10. Algorithms</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch10"><a id="page_107"/><span class="pd_blue">10.</span> Algorithms</h2>
<p class="blockquote"><em>Do not multiply entities beyond necessity.</em></p>
<p class="attribution"><em>&#8211; William Occam</em></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec2">Use of Iterators</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec3">Iterator Types</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec4">Stream Iterators</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec5">Predicates</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec6">Algorithm Overview</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec7">Container Algorithms</a></p>
<p class="indenthangingB">&#8226; <a href="ch10.html#ch10lev1sec8">Advice</a></p>
<div class="heading">
<h3 id="ch10lev1sec1">10.1. Introduction</h3>
<p class="noindent">A data structure, such as a list or a vector, is not very useful on its own. To use one, we need operations for basic access such as adding and removing elements (as is provided for <span class="EmpStrong">list</span> and <span class="EmpStrong">vector</span>). Furthermore, we rarely just store objects in a container. We sort them, print them, extract subsets, remove elements, search for objects, etc. Consequently, the standard library provides the most common algorithms for containers in addition to providing the most common container types. For example, the we can simply and efficiently sort a <span class="EmpStrong">vector</span> of <span class="EmpStrong">Entry</span>s and place a copy of each unique <span class="EmpStrong">vector</span> element on a <span class="EmpStrong">list</span>:</p>
</div>
<p class="codelink"><a id="p107pro01" href="ch10_images.html#p107pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(vector&lt;Entry&gt;&#38; vec, list&lt;Entry&gt;&#38; lst)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(vec.begin(),vec.end());</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use &lt; for order</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_copy(vec.begin(),vec.end(),lst.begin());</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">don't copy adjacent equal elements</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">For this to work, less than (<span class="EmpStrong">&lt;</span>) must be defined for <span class="EmpStrong">Entry</span>s. For example:</p>
<p class="codelink"><a id="page_108"/><a id="p108pro01" href="ch10_images.html#p108pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool operator&lt;(const Entry&#38; x, const Entry&#38; y)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">less than</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return x.name&lt;y.name;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">order Entrys by their names</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A standard algorithm is expressed in terms of (half-open) sequences of elements. A <em>sequence</em> is represented by a pair of iterators specifying the first element and the one-beyond-the-last element:</p>
<div class="image"><img src="graphics/108fig01.jpg" alt="Image"/></div>
<p class="noindent">In the example, <span class="EmpStrong">sort()</span> sorts the sequence defined by the pair of iterators <span class="EmpStrong">vec.begin()</span> and <span class="EmpStrong">vec.end()</span> &#8211; which just happens to be all the elements of a <span class="EmpStrong">vector</span>. For writing (output), you need only to specify the first element to be written. If more than one element is written, the elements following that initial element will be overwritten. Thus, to avoid errors, <span class="EmpStrong">lst</span> must have at least as many elements as there are unique values in <span class="EmpStrong">vec</span>.</p>
<p class="indent">If we wanted to place the unique elements in a new container, we could have written:</p>
<p class="codelink"><a id="p108pro02" href="ch10_images.html#p108pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">list&lt;Entry&gt; f(vector&lt;Entry&gt;&#38; vec)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">list&lt;Entry&gt; res;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(vec.begin(),vec.end());</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_copy(vec.begin(),vec.end(),back_inserter(res));</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">append to res</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return res;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The call <span class="EmpStrong">back_inserter(res)</span> constructs an iterator for <span class="EmpStrong">res</span> that adds elements at the end of a container, extending the container to make room for them. This saves us from first having to allocate a fixed amount of space and then filling it. Thus, the standard containers plus <span class="EmpStrong">back_inserter()</span>s eliminate the need to use error-prone, explicit C-style memory management using <span class="EmpStrong">realloc()</span>. The standard-library <span class="EmpStrong">list</span> has a move constructor (&#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>) that makes returning <span class="EmpStrong">res</span> by value efficient (even for <span class="EmpStrong">list</span>s of thousands of elements).</p>
<p class="indent">If you find the pair-of-iterators style of code, such as <span class="EmpStrong">sort(vec.begin(),vec.end())</span>, tedious, you can define container versions of the algorithms and write <span class="EmpStrong">sort(vec)</span> (&#167;<a href="ch10.html#ch10lev1sec7">10.7</a>).</p>
<div class="heading">
<h3 id="ch10lev1sec2">10.2. Use of Iterators</h3>
<p class="noindent">When you first encounter a container, a few iterators referring to useful elements can be obtained; <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span> are the best examples of this. In addition, many algorithms return iterators. For example, the standard algorithm <span class="EmpStrong">find</span> looks for a value in a sequence and returns an iterator to the element found:</p>
</div>
<p class="codelink"><a id="page_109"/><a id="p109pro01" href="ch10_images.html#p109pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool has_c(const string&#38; s, char c)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">does s contain the character c?</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto p = find(s.begin(),s.end(),c);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (p!=s.end())</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return true;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">else</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return false;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Like many standard-library search algorithms, <span class="EmpStrong">find</span> returns <span class="EmpStrong">end()</span> to indicate &#8220;not found.&#8221; An equivalent, shorter, definition of <span class="EmpStrong">has_c()</span> is:</p>
<p class="codelink"><a id="p109pro02" href="ch10_images.html#p109pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool has_c(const string&#38; s, char c)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">does s contain the character c?</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return find(s.begin(),s.end(),c)!=s.end();</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A more interesting exercise would be to find the location of all occurrences of a character in a string. We can return the set of occurrences as a <span class="EmpStrong">vector</span> of <span class="EmpStrong">string</span> iterators. Returning a <span class="EmpStrong">vector</span> is efficient because <span class="EmpStrong">vector</span> provides move semantics (&#167;<a href="ch04.html#ch04lev2sec8">4.6.1</a>). Assuming that we would like to modify the locations found, we pass a non-<span class="EmpStrong">const</span> string:</p>
<p class="codelink"><a id="p109pro03" href="ch10_images.html#p109pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">vector&lt;string::iterator&gt; find_all(string&#38; s, char c)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">find all occurrences of c in s</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;string::iterator&gt; res;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p = s.begin(); p!=s.end(); ++p)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p==c)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">res.push_back(p);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return res;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">We iterate through the string using a conventional loop, moving the iterator <span class="EmpStrong">p</span> forward one element at a time using <span class="EmpStrong">++</span> and looking at the elements using the dereference operator<code>*</code>. We could test <span class="EmpStrong">find_all()</span> like this:</p>
<p class="codelink"><a id="p109pro04" href="ch10_images.html#p109pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string m {"Mary had a little lamb"};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : find_all(m,'a'))</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p!='a')</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "a bug!\n";</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">That call of <span class="EmpStrong">find_all()</span> could be graphically represented like this:</p>
<div class="image"><img src="graphics/109fig01.jpg" alt="Image"/></div>
<p class="noindent"><a id="page_110"/>Iterators and standard algorithms work equivalently on every standard container for which their use makes sense. Consequently, we could generalize <span class="EmpStrong">find_all()</span>:</p>
<p class="codelink"><a id="p110pro01" href="ch10_images.html#p110pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C, typename V&gt;</span><br/><span class="EmpStrong">vector&lt;typename C::iterator&gt; find_all(C&#38; c, V v)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">find all occurrences of v in c</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;typename C::iterator&gt; res;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p = c.begin(); p!=c.end(); ++p)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p==v)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">res.push_back(p);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return res;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">typename</span> is needed to inform the compiler that <span class="EmpStrong">C</span>&#8217;s <span class="EmpStrong">iterator</span> is supposed to be a type and not a value of some type, say, the integer <span class="EmpStrong">7</span>. We can hide this implementation detail by introducing a type alias (&#167;<a href="ch05.html#ch05lev1sec7">5.7</a>) for <span class="EmpStrong">Iterator</span>:</p>
<p class="codelink"><a id="p110pro02" href="ch10_images.html#p110pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">using Iterator = typename T::iterator;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">T's iterator</span><br/><br/><span class="EmpStrong">template&lt;typename C, typename V&gt;</span><br/><span class="EmpStrong">vector&lt;Iterator&lt;C&gt;&gt; find_all(C&#38; c, V v)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">find all occurrences of v in c</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;Iterator&lt;C&gt;&gt; res;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p = c.begin(); p!=c.end(); ++p)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p==v)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">res.push_back(p);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return res;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">We can now write:</p>
<p class="codelink"><a id="p110pro03" href="ch10_images.html#p110pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string m {"Mary had a little lamb"};</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : find_all(m,'a'))</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">p is a string::iterator</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p!='a')</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "string bug!\n";</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">list&lt;double&gt; ld {1.1, 2.2, 3.3, 1.1};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : find_all(ld,1.1))</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p!=1.1)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "list bug!\n";</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;string&gt; vs { "red", "blue", "green", "green", "orange", "green" };</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : find_all(vs,"red"))</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (*p!="red")</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "vector bug!\n";</span><br/><a id="page_111"/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : find_all(vs,"green"))</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">*p = "vert";</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Iterators are used to separate algorithms and containers. An algorithm operates on its data through iterators and knows nothing about the container in which the elements are stored. Conversely, a container knows nothing about the algorithms operating on its elements; all it does is to supply iterators upon request (e.g., <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span>). This model of separation between data storage and algorithm delivers very general and flexible software.</p>
<div class="heading">
<h3 id="ch10lev1sec3">10.3. Iterator Types</h3>
<p class="noindent">What are iterators really? Any particular iterator is an object of some type. There are, however, many different iterator types, because an iterator needs to hold the information necessary for doing its job for a particular container type. These iterator types can be as different as the containers and the specialized needs they serve. For example, a <span class="EmpStrong">vector</span>&#8217;s iterator could be an ordinary pointer, because a pointer is quite a reasonable way of referring to an element of a <span class="EmpStrong">vector</span>:</p>
</div>
<div class="image"><img src="graphics/111fig01.jpg" alt="Image"/></div>
<p class="noindent">Alternatively, a <span class="EmpStrong">vector</span> iterator could be implemented as a pointer to the <span class="EmpStrong">vector</span> plus an index:</p>
<div class="image"><img src="graphics/111fig02.jpg" alt="Image"/></div>
<p class="noindent">Using such an iterator would allow range checking.</p>
<p class="indent">A <span class="EmpStrong">list</span> iterator must be something more complicated than a simple pointer to an element because an element of a <span class="EmpStrong">list</span> in general does not know where the next element of that <span class="EmpStrong">list</span> is. Thus, a <span class="EmpStrong">list</span> iterator might be a pointer to a link:</p>
<div class="image"><img src="graphics/111fig03.jpg" alt="Image"/></div>
<p class="noindent">What is common for all iterators is their semantics and the naming of their operations. For example, applying <span class="EmpStrong">++</span> to any iterator yields an iterator that refers to the next element. Similarly, <code>*</code> yields <a id="page_112"/>the element to which the iterator refers. In fact, any object that obeys a few simple rules like these is an iterator &#8211; <em>Iterator</em> is a concept (&#167;<a href="ch05.html#ch05lev1sec4">5.4</a>). Furthermore, users rarely need to know the type of a specific iterator; each container &#8220;knows&#8221; its iterator types and makes them available under the conventional names <span class="EmpStrong">iterator</span> and <span class="EmpStrong">const_iterator</span>. For example, <span class="EmpStrong">list&lt;Entry&gt;::iterator</span> is the general iterator type for <span class="EmpStrong">list&lt;Entry&gt;</span>. We rarely have to worry about the details of how that type is defined.</p>
<div class="heading">
<h3 id="ch10lev1sec4">10.4. Stream Iterators</h3>
<p class="noindent">Iterators are a general and useful concept for dealing with sequences of elements in containers. However, containers are not the only place where we find sequences of elements. For example, an input stream produces a sequence of values, and we write a sequence of values to an output stream. Consequently, the notion of iterators can be usefully applied to input and output.</p>
</div>
<p class="indent">To make an <span class="EmpStrong">ostream_iterator</span>, we need to specify which stream will be used and the type of objects written to it. For example:</p>
<p class="codelink"><a id="p112pro01" href="ch10_images.html#p112pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">ostream_iterator&lt;string&gt; oo {cout};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">write strings to cout</span></p>
<p class="noindent">The effect of assigning to <code>*</code><span class="EmpStrong">oo</span> is to write the assigned value to <span class="EmpStrong">cout.</span> For example:</p>
<p class="codelink"><a id="p112pro02" href="ch10_images.html#p112pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">*oo = "Hello, ";</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">meaning cout&lt;&lt;"Hello,"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">++oo;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">*oo = "world!\n";</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">meaning cout&lt;&lt;"world!\n"</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This is yet another way of writing the canonical message to standard output. The <span class="EmpStrong">++oo</span> is done to mimic writing into an array through a pointer.</p>
<p class="indent">Similarly, an <span class="EmpStrong">istream_iterator</span> is something that allows us to treat an input stream as a read-only container. Again, we must specify the stream to be used and the type of values expected:</p>
<p class="codelink"><a id="p112pro03" href="ch10_images.html#p112pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">istream_iterator&lt;string&gt; ii {cin};</span></p>
<p class="noindent">Input iterators are used in pairs representing a sequence, so we must provide an <span class="EmpStrong">istream_iterator</span> to indicate the end of input. This is the default <span class="EmpStrong">istream_iterator</span>:</p>
<p class="codelink"><a id="p112pro04" href="ch10_images.html#p112pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">istream_iterator&lt;string&gt; eos {};</span></p>
<p class="noindent">Typically, <span class="EmpStrong">istream_iterator</span>s and <span class="EmpStrong">ostream_iterator</span>s are not used directly. Instead, they are provided as arguments to algorithms. For example, we can write a simple program to read a file, sort the words read, eliminate duplicates, and write the result to another file:</p>
<p class="codelink"><a id="p112pro05" href="ch10_images.html#p112pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string from, to;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cin &gt;&gt; from &gt;&gt; to;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get source and target file names</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ifstream is {from};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">input stream for file "from"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">istream_iterator&lt;string&gt; ii {is};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">input iterator for stream</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">istream_iterator&lt;string&gt; eos {};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">input sentinel</span><br/><br/><a id="page_113"/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ofstream os {to};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">output stream for file "to"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ostream_iterator&lt;string&gt; oo {os,"\n"};</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">output iterator for stream</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;string&gt; b {ii,eos};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">b is a vector initialized from input</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(b.begin(),b.end());</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">sort the buffer</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_copy(b.begin(),b.end(),oo);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy buffer to output, discard replicated values</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return !is.eof() || !os;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">return error state (&#167;1.3, &#167;8.4)</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">An <span class="EmpStrong">ifstream</span> is an <span class="EmpStrong">istream</span> that can be attached to a file, and an <span class="EmpStrong">ofstream</span> is an <span class="EmpStrong">ostream</span> that can be attached to a file (&#167;<a href="ch08.html#ch08lev1sec7">8.7</a>). The <span class="EmpStrong">ostream_iterator</span>&#8217;s second argument is used to delimit output values.</p>
<p class="indent">Actually, this program is longer than it needs to be. We read the strings into a <span class="EmpStrong">vector</span>, then we <span class="EmpStrong">sort()</span> them, and then we write them out, eliminating duplicates. A more elegant solution is not to store duplicates at all. This can be done by keeping the <span class="EmpStrong">string</span>s in a <span class="EmpStrong">set</span>, which does not keep duplicates and keeps its elements in order (&#167;<a href="ch09.html#ch09lev1sec4">9.4</a>). That way, we could replace the two lines using a <span class="EmpStrong">vector</span> with one using a <span class="EmpStrong">set</span> and replace <span class="EmpStrong">unique_copy()</span> with the simpler <span class="EmpStrong">copy()</span>:</p>
<p class="codelink"><a id="p113pro01" href="ch10_images.html#p113pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">set&lt;string&gt; b {ii,eos};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">collect strings from input</span><br/><span class="EmpStrong">copy(b.begin(),b.end(),oo);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy buffer to output</span></p>
<p class="noindent">We used the names <span class="EmpStrong">ii</span>, <span class="EmpStrong">eos</span>, and <span class="EmpStrong">oo</span> only once, so we could further reduce the size of the program:</p>
<p class="codelink"><a id="p113pro02" href="ch10_images.html#p113pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string from, to;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cin &gt;&gt; from &gt;&gt; to;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get source and target file names</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ifstream is {from};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">input stream for file "from"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ofstream os {to};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">output stream for file "to"</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">set&lt;string&gt; b {istream_iterator&lt;string&gt;{is},istream_iterator&lt;string&gt;{}}; //</span> <span class="EmpItalic">read input</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">copy(b.begin(),b.end(),ostream_iterator&lt;string&gt;{os,"\n"});</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy to output</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return !is.eof() || !os;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">return error state (&#167;1.3, &#167;8.4)</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">It is a matter of taste and experience whether or not this last simplification improves readability.</p>
<div class="heading">
<h3 id="ch10lev1sec5">10.5. Predicates</h3>
<p class="noindent">In the examples above, the algorithms have simply &#8220;built in&#8221; the action to be done for each element of a sequence. However, we often want to make that action a parameter to the algorithm. For example, the <span class="EmpStrong">find</span> algorithm (&#167;<a href="ch10.html#ch10lev1sec2">10.2</a>, &#167;<a href="ch10.html#ch10lev1sec6">10.6</a>) provides a convenient way of looking for a specific value. A more general variant looks for an element that fulfills a specified requirement, a <em>predicate</em>. For example, we might want to search a <span class="EmpStrong">map</span> for the first value larger than <span class="EmpStrong">42</span>. A <span class="EmpStrong">map</span> allows us to access its elements as a sequence of <em>(key,value)</em> pairs, so we can search a <span class="EmpStrong">map&lt;string,int&gt;</span>&#8217;s sequence for a <span class="EmpStrong">pair&lt;const string,int&gt;</span> where the <span class="EmpStrong">int</span> is greater than <span class="EmpStrong">42</span>:</p>
</div>
<p class="codelink"><a id="page_114"/><a id="p114pro01" href="ch10_images.html#p114pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(map&lt;string,int&gt;&#38; m)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto p = find_if(m.begin(),m.end(),Greater_than{42});</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, <span class="EmpStrong">Greater_than</span> is a function object (&#167;<a href="ch05.html#ch05lev1sec5">5.5</a>) holding the value (<span class="EmpStrong">42</span>) to be compared against:</p>
<p class="codelink"><a id="p114pro02" href="ch10_images.html#p114pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">struct Greater_than {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int val;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Greater_than(int v) : val{v} { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bool operator()(const pair&lt;string,int&gt;&#38; r) { return r.second&gt;val; }</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Alternatively, we could use a lambda expression (&#167;<a href="ch05.html#ch05lev1sec5">5.5</a>):</p>
<p class="codelink"><a id="p114pro03" href="ch10_images.html#p114pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">auto p = find_if(m.begin(), m.end(), [](const pair&lt;string,int&gt;&#38; r) { return r.second&gt;42; });</span></p>
<p class="noindent">A predicate should not modify the elements to which it is applied.</p>
<div class="heading">
<h3 id="ch10lev1sec6">10.6. Algorithm Overview</h3>
<p class="noindent">A general definition of an algorithm is &#8220;a finite set of rules which gives a sequence of operations for solving a specific set of problems [and] has five important features: Finiteness ... Definiteness ... Input ... Output ... Effectiveness&#8221; [Knuth,1968,&#167;1.1]. In the context of the C++ standard library, an algorithm is a function template operating on sequences of elements.</p>
</div>
<p class="indent">The standard library provides dozens of algorithms. The algorithms are defined in namespace <span class="EmpStrong">std</span> and presented in the <span class="EmpStrong">&lt;algorithm&gt;</span> header. These standard-library algorithms all take sequences as inputs. A half-open sequence from <span class="EmpStrong">b</span> to <span class="EmpStrong">e</span> is referred to as [<span class="EmpStrong">b</span>:<span class="EmpStrong">e</span>). Here are a few examples:</p>
<div class="image"><img src="graphics/114tab01.jpg" alt="Image"/></div>
<p class="noindent"><a id="page_115"/>These algorithms, and many more (e.g., &#167;<a href="ch12.html#ch12lev1sec3">12.3</a>), can be applied to elements of containers, <span class="EmpStrong">string</span>s, and built-in arrays.</p>
<p class="indent">Some algorithms, such as <span class="EmpStrong">replace()</span> and <span class="EmpStrong">sort(),</span> modify element values, but no algorithm adds or subtracts elements of a container. The reason is that a sequence does not identify the container that holds the elements of the sequence. If you want to add elements, you need something, such as a <span class="EmpStrong">back_inserter</span> that knows about the container (&#167;<a href="ch10.html#ch10lev1sec1">10.1</a>), or directly refer to the container itself, such as <span class="EmpStrong">push_back()</span> or <span class="EmpStrong">erase()</span> (&#167;<a href="ch09.html#ch09lev1sec2">9.2</a>).</p>
<p class="indent">The standard-library algorithms tend to be more carefully designed, specified, and implemented than the average hand-crafted loop, so know them and use them in preference to code written in the bare language.</p>
<div class="heading">
<h3 id="ch10lev1sec7">10.7. Container Algorithms</h3>
<p class="noindent">A sequence is defined by a pair of iterators [<span class="EmpStrong">begin</span>:<span class="EmpStrong">end</span>). This is general and flexible, but most often, we apply an algorithm to a sequence that is the contents of a container. For example:</p>
</div>
<p class="pre"><span class="EmpStrong">sort(v.begin(),v.end());</span></p>
<p class="noindent">Why don&#8217;t we just say <span class="EmpStrong">sort(v)</span>? We can easily provide that shorthand:</p>
<p class="codelink"><a id="p115pro01" href="ch10_images.html#p115pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">namespace Estd {</span><br/>&#160;&#160;&#160;<span class="EmpStrong">using namespace std;</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">template&lt;typename C&gt;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">void sort(C&#38; c)</span><br/>&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(c.begin(),c.end());</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">template&lt;typename C, typename Pred&gt;</span><br/>&#160;&#160;&#160;<span class="EmpStrong">void sort(C&#38; c, Pred p)</span><br/>&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(c.begin(),c.end(),p);</span><br/>&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">I put the container versions of <span class="EmpStrong">sort()</span> (and other algorithms) into their own namespace <span class="EmpStrong">Estd</span> (&#8220;extended <span class="EmpStrong">std</span>&#8221;) to avoid interfering with other programmers&#8217; uses of namespace <span class="EmpStrong">std</span>.</p>
<div class="heading">
<h3 id="ch10lev1sec8">10.8. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapter 32 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] An STL algorithm operates on one or more sequences; &#167;<a href="ch10.html#ch10lev1sec1">10.1</a>.</p>
<p class="ref"><a id="page_116"/>[3] An input sequence is half-open and defined by a pair of iterators; &#167;<a href="ch10.html#ch10lev1sec1">10.1</a>.</p>
<p class="ref">[4] When searching, an algorithm usually returns the end of the input sequence to indicate &#8220;not found&#8221;; &#167;<a href="ch10.html#ch10lev1sec2">10.2</a>.</p>
<p class="ref">[5] Algorithms do not directly add or subtract elements from their argument sequences; &#167;<a href="ch10.html#ch10lev1sec2">10.2</a>, &#167;<a href="ch10.html#ch10lev1sec6">10.6</a>.</p>
<p class="ref">[6] When writing a loop, consider whether it could be expressed as a general algorithm; &#167;<a href="ch10.html#ch10lev1sec2">10.2</a>.</p>
<p class="ref">[7] Use predicates and other function objects to give standard algorithms a wider range of meanings; &#167;<a href="ch10.html#ch10lev1sec5">10.5</a>, &#167;<a href="ch10.html#ch10lev1sec6">10.6</a>.</p>
<p class="ref">[8] A predicate must not modify its argument; &#167;<a href="ch10.html#ch10lev1sec5">10.5</a>.</p>
<p class="ref">[9] Know your standard-library algorithms and prefer them to hand-crafted loops; &#167;<a href="ch10.html#ch10lev1sec6">10.6</a>.</p>
<p class="ref1">[10] When the pair-of-iterators style becomes tedious, introduce a container/range algorithm; &#167;<a href="ch10.html#ch10lev1sec7">10.7</a>.</p>
</body>
</html>