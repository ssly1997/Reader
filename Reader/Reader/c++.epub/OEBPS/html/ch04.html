<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4. Classes</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch04"><a id="page_33"/><span class="pd_blue">4.</span> Classes</h2>
<p class="blockquote"><em>Those types are not &#8220;abstract&#8221;;<br/>they are as real as</em> <span class="EmpStrong">int</span> <em>and</em> <span class="EmpStrong">float</span><em>.</em></p>
<p class="attribution"><em>&#8211; Doug McIlroy</em></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec2">Concrete Types</a></p>
<p class="indenthangingBP"><a href="ch04.html#ch04lev2sec1">An Arithmetic Type</a>; <a href="ch04.html#ch04lev2sec2">A Container</a>; <a href="ch04.html#ch04lev2sec3">Initializing Containers</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec3">Abstract Types</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec4">Virtual Functions</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec5">Class Hierarchies</a></p>
<p class="indenthangingBP"><a href="ch04.html#ch04lev2sec4">Explicit Overriding</a>; <a href="ch04.html#ch04lev2sec5">Benefits from Hierarchies</a>; <a href="ch04.html#ch04lev2sec6">Hierarchy Navigation</a>; <a href="ch04.html#ch04lev2sec7">Avoiding Resource Leaks</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec6">Copy and Move</a></p>
<p class="indenthangingBP"><a href="ch04.html#ch04lev2sec8">Copying Containers</a>; <a href="ch04.html#ch04lev2sec9">Moving Containers</a>; <a href="ch04.html#ch04lev2sec10">Essential Operations</a>; <a href="ch04.html#ch04lev2sec11">Resource Management</a>; <a href="ch04.html#ch04lev2sec12">Suppressing Operations</a></p>
<p class="indenthangingB">&#8226; <a href="ch04.html#ch04lev1sec7">Advice</a></p>
<div class="heading">
<h3 id="ch04lev1sec1">4.1. Introduction</h3>
<p class="noindent">This chapter and the next aim to give you an idea of C++&#8217;s support for abstraction and resource management without going into a lot of detail:</p>
</div>
<p class="indenthangingB">&#8226; This chapter informally presents ways of defining and using new types (<em>user-defined types</em>). In particular, it presents the basic properties, implementation techniques, and language facilities used for <em>concrete classes</em>, <em>abstract classes</em>, and <em>class hierarchies</em>.</p>
<p class="indenthangingB">&#8226; The next chapter introduces templates as a mechanism for parameterizing types and algorithms with (other) types and algorithms. Computations on user-defined and built-in types are represented as functions, sometimes generalized to <em>template functions</em> and <em>function objects</em>.</p>
<p class="noindent"><a id="page_34"/>These are the language facilities supporting the programming styles known as <em>object-oriented programming</em> and <em>generic programming</em>. <a href="ch06.html#ch06">Chapters 6</a>-<a href="ch13.html#ch13">13</a> follow up by presenting examples of standard-library facilities and their use.</p>
<p class="indent">The central language feature of C++ is the <em>class</em>. A class is a user-defined type provided to represent a concept in the code of a program. Whenever our design for a program has a useful concept, idea, entity, etc., we try to represent it as a class in the program so that the idea is there in the code, rather than just in our head, in a design document, or in some comments. A program built out of a well chosen set of classes is far easier to understand and get right than one that builds everything directly in terms of the built-in types. In particular, classes are often what libraries offer.</p>
<p class="indent">Essentially all language facilities beyond the fundamental types, operators, and statements exist to help define better classes or to use them more conveniently. By &#8220;better,&#8221; I mean more correct, easier to maintain, more efficient, more elegant, easier to use, easier to read, and easier to reason about. Most programming techniques rely on the design and implementation of specific kinds of classes. The needs and tastes of programmers vary immensely. Consequently, the support for classes is extensive. Here, we will just consider the basic support for three important kinds of classes:</p>
<p class="indenthangingB">&#8226; Concrete classes (&#167;<a href="ch04.html#ch04lev1sec2">4.2</a>)</p>
<p class="indenthangingB">&#8226; Abstract classes (&#167;<a href="ch04.html#ch04lev1sec3">4.3</a>)</p>
<p class="indenthangingB">&#8226; Classes in class hierarchies (&#167;<a href="ch04.html#ch04lev1sec5">4.5</a>)</p>
<p class="noindent">An astounding number of useful classes turn out to be of these three kinds. Even more classes can be seen as simple variants of these kinds or are implemented using combinations of the techniques used for these.</p>
<div class="heading">
<h3 id="ch04lev1sec2">4.2. Concrete Types</h3>
<p class="noindent">The basic idea of <em>concrete classes</em> is that they behave &#8220;just like built-in types.&#8221; For example, a complex number type and an infinite-precision integer are much like built-in <span class="EmpStrong">int</span>, except of course that they have their own semantics and sets of operations. Similarly, a <span class="EmpStrong">vector</span> and a <span class="EmpStrong">string</span> are much like built-in arrays, except that they are better behaved (&#167;<a href="ch07.html#ch07lev1sec2">7.2</a>, &#167;<a href="ch08.html#ch08lev1sec3">8.3</a>, &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>).</p>
</div>
<p class="indent">The defining characteristic of a concrete type is that its representation is part of its definition. In many important cases, such as a <span class="EmpStrong">vector</span>, that representation is only one or more pointers to data stored elsewhere, but it is present in each object of a concrete class. That allows implementations to be optimally efficient in time and space. In particular, it allows us to</p>
<p class="indenthangingB">&#8226; place objects of concrete types on the stack, in statically allocated memory, and in other objects (&#167;<a href="ch01.html#ch01lev1sec6">1.6</a>);</p>
<p class="indenthangingB">&#8226; refer to objects directly (and not just through pointers or references);</p>
<p class="indenthangingB">&#8226; initialize objects immediately and completely (e.g., using constructors; &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>); and</p>
<p class="indenthangingB">&#8226; copy objects (&#167;<a href="ch04.html#ch04lev1sec6">4.6</a>).</p>
<p class="noindent">The representation can be private (as it is for <span class="EmpStrong">Vector</span>; &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>) and accessible only through the member functions, but it is present. Therefore, if the representation changes in any significant way, a user must recompile. This is the price to pay for having concrete types behave exactly like built-in types. For types that don&#8217;t change often, and where local variables provide much-needed clarity and efficiency, this is acceptable and often ideal. To increase flexibility, a concrete type can keep <a id="page_35"/>major parts of its representation on the free store (dynamic memory, heap) and access them through the part stored in the class object itself. That&#8217;s the way <span class="EmpStrong">vector</span> and <span class="EmpStrong">string</span> are implemented; they can be considered resource handles with carefully crafted interfaces.</p>
<div class="heading">
<h4 id="ch04lev2sec1">4.2.1. An Arithmetic Type</h4>
<p class="noindent">The &#8220;classical user-defined arithmetic type&#8221; is <span class="EmpStrong">complex</span>:</p>
</div>
<p class="codelink"><a id="p035pro01" href="ch04_images.html#p035pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class complex {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double re, im; //</span> <span class="EmpItalic">representation: two doubles</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex(double r, double i) :re{r}, im{i} {}</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">construct complex from two scalars</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex(double r) :re{r}, im{0} {}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">construct complex from one scalar</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex() :re{0}, im{0} {}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">default complex: {0,0}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double real() const { return re; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void real(double d) { re=d; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double imag() const { return im; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void imag(double d) { im=d; }</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex&#38; operator+=(complex z) { re+=z.re, im+=z.im; return *this; }</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">add to re and im</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">and return the result</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex&#38; operator-=(complex z) { re-=z.re, im-=z.im; return *this; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex&#38; operator*=(complex);&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">defined out-of-class somewhere</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex&#38; operator/=(complex);&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">defined out-of-class somewhere</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">This is a slightly simplified version of the standard-library <span class="EmpStrong">complex</span> (&#167;<a href="ch12.html#ch12lev1sec4">12.4</a>). The class definition itself contains only the operations requiring access to the representation. The representation is simple and conventional. For practical reasons, it has to be compatible with what Fortran provided 50 years ago, and we need a conventional set of operators. In addition to the logical demands, <span class="EmpStrong">complex</span> must be efficient or it will remain unused. This implies that simple operations must be inlined. That is, simple operations (such as constructors, <span class="EmpStrong">+=</span>, and <span class="EmpStrong">imag()</span>) must be implemented without function calls in the generated machine code. Functions defined in a class are inlined by default. It is possible to explicitly require inlining by preceeding a function declaration with the keyword <span class="EmpStrong">inline</span>. An industrial-strength <span class="EmpStrong">complex</span> (like the standard-library one) is carefully implemented to do appropriate inlining.</p>
<p class="indent">A constructor that can be invoked without an argument is called a <em>default constructor</em>. Thus, <span class="EmpStrong">complex()</span> is <span class="EmpStrong">complex</span>&#8217;s default constructor. By defining a default constructor you eliminate the possibility of uninitialized variables of that type.</p>
<p class="indent">The <span class="EmpStrong">const</span> specifiers on the functions returning the real and imaginary parts indicate that these functions do not modify the object for which they are called.</p>
<p class="indent">Many useful operations do not require direct access to the representation of <span class="EmpStrong">complex</span>, so they can be defined separately from the class definition:</p>
<p class="codelink"><a id="page_36"/><a id="p036pro01" href="ch04_images.html#p036pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">complex operator+(complex a, complex b) { return a+=b; }</span><br/><span class="EmpStrong">complex operator-(complex a, complex b) { return a-=b; }</span><br/><span class="EmpStrong">complex operator-(complex a){return {-a.real(), -a.imag()}; }</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">unary minus</span><br/><span class="EmpStrong">complex operator*(complex a, complex b) { return a*=b; }</span><br/><span class="EmpStrong">complex operator/(complex a, complex b) { return a/=b; }</span></p>
<p class="noindent">Here, I use the fact that an argument passed by value is copied, so that I can modify an argument without affecting the caller&#8217;s copy, and use the result as the return value.</p>
<p class="indent">The definitions of <span class="EmpStrong">==</span> and <span class="EmpStrong">!=</span> are straightforward:</p>
<p class="codelink"><a id="p036pro02" href="ch04_images.html#p036pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool operator==(complex a, complex b)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">equal</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return a.real()==b.real() &#38;&#38; a.imag()==b.imag();</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">bool operator!=(complex a, complex b)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">not equal</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return !(a==b);</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">complex sqrt(complex);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the definition is elsewhere</span><br/><br/><span class="EmpStrong">//</span> <span class="EmpItalic">...</span></p>
<p class="noindent">Class <span class="EmpStrong">complex</span> can be used like this:</p>
<p class="codelink"><a id="p036pro03" href="ch04_images.html#p036pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(complex z)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex a {2.3};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">construct {2.3,0.0} from 2.3</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex b {1/a};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex c {a+z*complex {1,2.3}};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (c != b)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">c = -(b/a)+2*b;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The compiler converts operators involving <span class="EmpStrong">complex</span> numbers into appropriate function calls. For example, <span class="EmpStrong">c!=b</span> means <span class="EmpStrong">operator!=(c,b)</span> and <span class="EmpStrong">1/a</span> means <span class="EmpStrong">operator/(complex{1},a)</span>.</p>
<p class="indent">User-defined operators (&#8220;overloaded operators&#8221;) should be used cautiously and conventionally. The syntax is fixed by the language, so you can&#8217;t define a unary <span class="EmpStrong">/</span>. Also, it is not possible to change the meaning of an operator for built-in types, so you can&#8217;t redefine <span class="EmpStrong">+</span> to subtract <span class="EmpStrong">int</span>s.</p>
<div class="heading">
<h4 id="ch04lev2sec2">4.2.2. A Container</h4>
<p class="noindent">A <em>container</em> is an object holding a collection of elements, so we call <span class="EmpStrong">Vector</span> a container because it is the type of objects that are containers. As defined in &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>, <span class="EmpStrong">Vector</span> isn&#8217;t an unreasonable container of <span class="EmpStrong">double</span>s: it is simple to understand, establishes a useful invariant (&#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>), provides range-checked access (&#167;<a href="ch03.html#ch03lev2sec1">3.4.1</a>), and provides <span class="EmpStrong">size()</span> to allow us to iterate over its elements. However, it does have a fatal flaw: it allocates elements using <span class="EmpStrong">new</span> but never deallocates them. That&#8217;s not a good idea because although C++ defines an interface for a garbage collector (&#167;<a href="ch04.html#ch04lev2sec11">4.6.4</a>), it is not guaranteed that <a id="page_37"/>one is available to make unused memory available for new objects. In some environments you can&#8217;t use a collector, and sometimes you prefer more precise control of destruction for logical or performance reasons. We need a mechanism to ensure that the memory allocated by the constructor is deallocated; that mechanism is a <em>destructor</em>:</p>
</div>
<p class="codelink"><a id="p037pro01" href="ch04_images.html#p037pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">elem points to an array of sz doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(int s) :elem{new double[s]}, sz{s}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">constructor: acquire resources</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=s; ++i)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize elements</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">elem[i]=0;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Vector() { delete[] elem; }</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor: release resources</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() const;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The name of a destructor is the complement operator, <span class="EmpStrong"><sup>~</sup></span>, followed by the name of the class; it is the complement of a constructor. <span class="EmpStrong">Vector</span>&#8217;s constructor allocates some memory on the free store (also called the <em>heap</em> or <em>dynamic store</em>) using the <span class="EmpStrong">new</span> operator. The destructor cleans up by freeing that memory using the <span class="EmpStrong">delete</span> operator. This is all done without intervention by users of <span class="EmpStrong">Vector.</span> The users simply create and use <span class="EmpStrong">Vector</span>s much as they would variables of built-in types. For example:</p>
<p class="codelink"><a id="p037pro02" href="ch04_images.html#p037pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void fct(int n)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v(n);</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... use v ...</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v2(2*n);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... use v and v2 ...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">} //</span> <span class="EmpItalic">v2 is destroyed here</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... use v ..</span><br/><br/><span class="EmpStrong">} //</span> <span class="EmpItalic">v is destroyed here</span></p>
<p class="noindent"><span class="EmpStrong">Vector</span> obeys the same rules for naming, scope, allocation, lifetime, etc. (&#167;<a href="ch01.html#ch01lev1sec6">1.6</a>), as does a built-in type, such as <span class="EmpStrong">int</span> and <span class="EmpStrong">char</span>. This <span class="EmpStrong">Vector</span> has been simplified by leaving out error handling; see &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>.</p>
<p class="indent">The constructor/destructor combination is the basis of many elegant techniques. In particular, it is the basis for most C++ general resource management techniques (&#167;<a href="ch11.html#ch11lev1sec2">11.2</a>). Consider a graphical illustration of a <span class="EmpStrong">Vector</span>:</p>
<div class="image"><a id="page_38"/><img src="graphics/038fig01.jpg" alt="Image"/></div>
<p class="noindent">The constructor allocates the elements and initializes the <span class="EmpStrong">Vector</span> members appropriately. The destructor deallocates the elements. This <em>handle-to-data model</em> is very commonly used to manage data that can vary in size during the lifetime of an object. The technique of acquiring resources in a constructor and releasing them in a destructor, known as <em>Resource Acquisition Is Initialization</em> or <em>RAII</em>, allows us to eliminate &#8220;naked <span class="EmpStrong">new</span> operations,&#8221; that is, to avoid allocations in general code and keep them buried inside the implementation of well-behaved abstractions. Similarly, &#8220;naked <span class="EmpStrong">delete</span> operations&#8221; should be avoided. Avoiding naked <span class="EmpStrong">new</span> and naked <span class="EmpStrong">delete</span> makes code far less error-prone and far easier to keep free of resource leaks (&#167;<a href="ch11.html#ch11lev1sec2">11.2</a>).</p>
<div class="heading">
<h4 id="ch04lev2sec3">4.2.3. Initializing Containers</h4>
<p class="noindent">A container exists to hold elements, so obviously we need convenient ways of getting elements into a container. We can handle that by creating a <span class="EmpStrong">Vector</span> with an appropriate number of elements and then assigning to them, but typically other ways are more elegant. Here, I just mention two favorites:</p>
</div>
<p class="indenthangingB">&#8226; <em>Initializer-list constructor</em>: Initialize with a list of elements.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">push_back()</span>: Add a new element at the end (at the back of) the sequence.</p>
<p class="noindent">These can be declared like this:</p>
<p class="codelink"><a id="p038pro01" href="ch04_images.html#p038pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(std::initializer_list&lt;double&gt;);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize with a list of doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void push_back(double);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">add element at end, increasing the size by one</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The <span class="EmpStrong">push_back()</span> is useful for input of arbitrary numbers of elements. For example:</p>
<p class="codelink"><a id="p038pro02" href="ch04_images.html#p038pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector read(istream&#38; is)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (double d; is&gt;&gt;d;)</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read floating-point values into d</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.push_back(d);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">add d to v</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return v;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The input loop is terminated by an end-of-file or a formatting error. Until that happens, each number read is added to the <span class="EmpStrong">Vector</span> so that at the end, <span class="EmpStrong">v</span>&#8217;s size is the number of elements read. I used a <span class="EmpStrong">for</span>-statement rather than the more conventional <span class="EmpStrong">while</span>-statement to keep the scope of <span class="EmpStrong">d</span> limited to the loop. The way to provide <span class="EmpStrong">Vector</span> with a move constructor, so that returning a potentially huge amount of data from <span class="EmpStrong">read()</span> is cheap, is explained in &#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>.</p>
<p class="indent"><a id="page_39"/>The <span class="EmpStrong">std::initializer_list</span> used to define the initializer-list constructor is a standard-library type known to the compiler: when we use a <span class="EmpStrong">{}</span>-list, such as <span class="EmpStrong">{1,2,3,4}</span>, the compiler will create an object of type <span class="EmpStrong">initializer_list</span> to give to the program. So, we can write:</p>
<p class="codelink"><a id="p039pro01" href="ch04_images.html#p039pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector v1 = {1,2,3,4,5};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">v1 has 5 elements</span><br/><span class="EmpStrong">Vector v2 = {1.23, 3.45, 6.7, 8};</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">v2 has 4 elements</span></p>
<p class="indent"><span class="EmpStrong">Vector</span>&#8217;s initializer-list constructor might be defined like this:</p>
<p class="codelink"><a id="p039pro02" href="ch04_images.html#p039pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector::Vector(std::initializer_list&lt;double&gt; lst)&#160;&#160;//</span> <span class="EmpItalic">initialize with a list</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">:elem{new double[lst.size()]}, sz{static_cast&lt;int&gt;(lst.size())}</span><br/><span class="EmpStrong">{</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;copy(lst.begin(),lst.end(),elem);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy from lst into elem (&#167;10.6)</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">I use the ugly <span class="EmpStrong">static_cast</span> (&#167;<a href="ch14.html#ch14lev2sec6">14.2.3</a>) to convert the size of the initializer list to an <span class="EmpStrong">int</span>. This is pedantic because the chance that the number of elements in a hand-written list is larger than the largest integer (32,767 for 16-bit integers and 2,147,483,647 for 32-bit integers) is rather low. However, it is worth remembering that the type system has no common sense. It knows about the possible values of variables, rater than actual values, so it might complain where there is no actual violation. However, sooner or later, such warnings will save the programmer from a bad error.</p>
<p class="indent">A <span class="EmpStrong">static_cast</span> is does not check the value it is converting; the programmer is trusted to use it correctly. This is not always a good assumption, so if in doubt, check the value. Explicit type conversions (often called <em>casts</em> to remind you that they are used to prop up something broken) are best avoided. Judicious use of the type system and well-designed libraries allow us to eliminate unchecked cast in higher-level software.</p>
<div class="heading">
<h3 id="ch04lev1sec3">4.3. Abstract Types</h3>
<p class="noindent">Types such as <span class="EmpStrong">complex</span> and <span class="EmpStrong">Vector</span> are called <em>concrete types</em> because their representation is part of their definition. In that, they resemble built-in types. In contrast, an <em>abstract type</em> is a type that completely insulates a user from implementation details. To do that, we decouple the interface from the representation and give up genuine local variables. Since we don&#8217;t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>) and access them through references or pointers (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>, &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>).</p>
</div>
<p class="indent">First, we define the interface of a class <span class="EmpStrong">Container</span> which we will design as a more abstract version of our <span class="EmpStrong">Vector</span>:</p>
<p class="codelink"><a id="p039pro03" href="ch04_images.html#p039pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Container {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual double&#38; operator[](int) = 0;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pure virtual function</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual int size() const = 0;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">const member function (&#167;4.2.1)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual<sup>~</sup>Container() {}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor (&#167;4.2.2)</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">This class is a pure interface to specific containers defined later. The word <span class="EmpStrong">virtual</span> means &#8220;may be redefined later in a class derived from this one.&#8221; Unsurprisingly, a function declared <span class="EmpStrong">virtual</span> is called a <em>virtual function</em>. A class derived from <span class="EmpStrong">Container</span> provides an implementation for the <a id="page_40"/><span class="EmpStrong">Container</span> interface. The curious <span class="EmpStrong">=0</span> syntax says the function is <em>pure virtual</em>; that is, some class derived from <span class="EmpStrong">Container</span> <em>must</em> define the function. Thus, it is not possible to define an object that is just a <span class="EmpStrong">Container</span>; a <span class="EmpStrong">Container</span> can only serve as the interface to a class that implements its <span class="EmpStrong">operator[]()</span> and <span class="EmpStrong">size()</span> functions. A class with a pure virtual function is called an <em>abstract class</em>.</p>
<p class="indent">This <span class="EmpStrong">Container</span> can be used like this:</p>
<p class="pre"><span class="EmpStrong">void use(Container&#38; c)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const int sz = c.size();</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=sz; ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; c[i] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Note how <span class="EmpStrong">use()</span> uses the <span class="EmpStrong">Container</span> interface in complete ignorance of implementation details. It uses <span class="EmpStrong">size()</span> and <span class="EmpStrong">[ ]</span> without any idea of exactly which type provides their implementation. A class that provides the interface to a variety of other classes is often called a <em>polymorphic type</em>.</p>
<p class="indent">As is common for abstract classes, <span class="EmpStrong">Container</span> does not have a constructor. After all, it does not have any data to initialize. On the other hand, <span class="EmpStrong">Container</span> does have a destructor and that destructor is <span class="EmpStrong">virtual</span>. Again, that is common for abstract classes because they tend to be manipulated through references or pointers, and someone destroying a <span class="EmpStrong">Container</span> through a pointer has no idea what resources are owned by its implementation; see also &#167;<a href="ch04.html#ch04lev1sec5">4.5</a>.</p>
<p class="indent">A container that implements the functions required by the interface defined by the abstract class <span class="EmpStrong">Container</span> could use the concrete class <span class="EmpStrong">Vector:</span></p>
<p class="codelink"><a id="p040pro01" href="ch04_images.html#p040pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector_container : public Container {</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Vector_container implements Container</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v;</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector_container(int s) : v(s) { }</span>&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Vector of s elements</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Vector_container() {}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i) { return v[i]; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() const { return v.size(); }</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The <span class="EmpStrong">:public</span> can be read as &#8220;is derived from&#8221; or &#8220;is a subtype of.&#8221; Class <span class="EmpStrong">Vector_container</span> is said to be <em>derived</em> from class <span class="EmpStrong">Container</span>, and class <span class="EmpStrong">Container</span> is said to be a <em>base</em> of class <span class="EmpStrong">Vector_container</span>. An alternative terminology calls <span class="EmpStrong">Vector_container</span> and <span class="EmpStrong">Container</span> <em>subclass</em> and <em>superclass</em>, respectively. The derived class is said to inherit members from its base class, so the use of base and derived classes is commonly referred to as <em>inheritance</em>.</p>
<p class="indent">The members <span class="EmpStrong">operator[]()</span> and <span class="EmpStrong">size()</span> are said to <em>override</em> the corresponding members in the base class <span class="EmpStrong">Container</span>. The destructor (<span class="EmpStrong"><sup>~</sup>Vector_container()</span>) overrides the base class destructor (<span class="EmpStrong"><sup>~</sup>Container()</span>). Note that the member destructor (<span class="EmpStrong"><sup>~</sup>Vector()</span>) is implicitly invoked by its class&#8217;s destructor (<span class="EmpStrong"><sup>~</sup>Vector_container()</span>).</p>
<p class="indent">For a function like <span class="EmpStrong">use(Container&#38;)</span> to use a <span class="EmpStrong">Container</span> in complete ignorance of implementation details, some other function will have to make an object on which it can operate. For example:</p>
<p class="codelink"><a id="page_41"/><a id="p041pro01" href="ch04_images.html#p041pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void g()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector_container vc {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">use(vc);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Since <span class="EmpStrong">use()</span> doesn&#8217;t know about <span class="EmpStrong">Vector_container</span>s but only knows the <span class="EmpStrong">Container</span> interface, it will work just as well for a different implementation of a <span class="EmpStrong">Container</span>. For example:</p>
<p class="codelink"><a id="p041pro02" href="ch04_images.html#p041pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class List_container : public Container {</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">List_container implements Container</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">std::list&lt;double&gt; ld;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">(standard-library) list of doubles (&#167;9.3)</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">List_container() { }</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">empty List</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">List_container(initializer_list&lt;double&gt; il) : ld{il} { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>List_container() {}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() const { return ld.size(); }</span><br/><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">double&#38; List_container::operator[](int i)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto&#38; x : ld) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (i==0) return x;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">--i;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">throw out_of_range("List container");</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, the representation is a standard-library <span class="EmpStrong">list&lt;double&gt;</span>. Usually, I would not implement a container with a subscript operation using a <span class="EmpStrong">list</span>, because performance of <span class="EmpStrong">list</span> subscripting is atrocious compared to <span class="EmpStrong">vector</span> subscripting. However, here I just wanted to show an implementation that is radically different from the usual one.</p>
<p class="indent">A function can create a <span class="EmpStrong">List_container</span> and have <span class="EmpStrong">use()</span> use it:</p>
<p class="codelink"><a id="p041pro03" href="ch04_images.html#p041pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void h()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">List_container lc = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">use(lc);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The point is that <span class="EmpStrong">use(Container&#38;)</span> has no idea if its argument is a <span class="EmpStrong">Vector_container</span>, a <span class="EmpStrong">List_container</span>, or some other kind of container; it doesn&#8217;t need to know. It can use any kind of <span class="EmpStrong">Container</span>. It knows only the interface defined by <span class="EmpStrong">Container</span>. Consequently, <span class="EmpStrong">use(Container&#38;)</span> needn&#8217;t be recompiled if the implementation of <span class="EmpStrong">List_container</span> changes or a brand-new class derived from <span class="EmpStrong">Container</span> is used.</p>
<p class="indent">The flip side of this flexibility is that objects must be manipulated through pointers or references (&#167;<a href="ch04.html#ch04lev1sec6">4.6</a>, &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>).</p>
<div class="heading">
<h3 id="ch04lev1sec4"><a id="page_42"/>4.4. Virtual Functions</h3>
<p class="noindent">Consider again the use of <span class="EmpStrong">Container</span>:</p>
</div>
<p class="pre"><span class="EmpStrong">void use(Container&#38; c)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const int sz = c.size();</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=sz; ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; c[i] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">How is the call <span class="EmpStrong">c[i]</span> in <span class="EmpStrong">use()</span> resolved to the right <span class="EmpStrong">operator[]()</span>? When <span class="EmpStrong">h()</span> calls <span class="EmpStrong">use()</span>, <span class="EmpStrong">List_container</span>&#8217;s <span class="EmpStrong">operator[]()</span> must be called. When <span class="EmpStrong">g()</span> calls <span class="EmpStrong">use()</span>, <span class="EmpStrong">Vector_container</span>&#8217;s <span class="EmpStrong">operator[]()</span> must be called. To achieve this resolution, a <span class="EmpStrong">Container</span> object must contain information to allow it to select the right function to call at run time. The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions. That table is usually called the <em>virtual function table</em> or simply the <span class="EmpStrong">vtbl</span>. Each class with virtual functions has its own <span class="EmpStrong">vtbl</span> identifying its virtual functions. This can be represented graphically like this:</p>
<div class="image"><img src="graphics/042fig01.jpg" alt="Image"/></div>
<p class="noindent">The functions in the <span class="EmpStrong">vtbl</span> allow the object to be used correctly even when the size of the object and the layout of its data are unknown to the caller. The implementation of the caller needs only to know the location of the pointer to the <span class="EmpStrong">vtbl</span> in a <span class="EmpStrong">Container</span> and the index used for each virtual function. This virtual call mechanism can be made almost as efficient as the &#8220;normal function call&#8221; mechanism (within 25%). Its space overhead is one pointer in each object of a class with virtual functions plus one <span class="EmpStrong">vtbl</span> for each such class.</p>
<div class="heading">
<h3 id="ch04lev1sec5">4.5. Class Hierarchies</h3>
<p class="noindent">The <span class="EmpStrong">Container</span> example is a very simple example of a class hierarchy. A <em>class hierarchy</em> is a set of classes ordered in a lattice created by derivation (e.g., <span class="EmpStrong">: public</span>). We use class hierarchies to represent concepts that have hierarchical relationships, such as &#8220;A fire engine is a kind of a truck which <a id="page_43"/>is a kind of a vehicle&#8221; and &#8220;A smiley face is a kind of a circle which is a kind of a shape.&#8221; Huge hierarchies, with hundreds of classes, that are both deep and wide are common. As a semi-realistic classic example, let&#8217;s consider shapes on a screen:</p>
</div>
<div class="image"><img src="graphics/043fig01.jpg" alt="Image"/></div>
<p class="noindent">The arrows represent inheritance relationships. For example, class <span class="EmpStrong">Circle</span> is derived from class <span class="EmpStrong">Shape</span>. To represent that simple diagram in code, we must first specify a class that defines the general properties of all shapes:</p>
<p class="codelink"><a id="p043pro01" href="ch04_images.html#p043pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Shape {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual Point center() const =0;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pure virtual</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual void move(Point to) =0;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual void draw() const = 0;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">draw on current "Canvas"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual void rotate(int angle) = 0;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual <sup>~</sup>Shape() {}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Naturally, this interface is an abstract class: as far as representation is concerned, <em>nothing</em> (except the location of the pointer to the <span class="EmpStrong">vtbl</span>) is common for every <span class="EmpStrong">Shape</span>. Given this definition, we can write general functions manipulating vectors of pointers to shapes:</p>
<p class="codelink"><a id="p043pro02" href="ch04_images.html#p043pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void rotate_all(vector&lt;Shape*&gt;&#38; v, int angle) //</span> <span class="EmpItalic">rotate v's elements by angle degrees</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : v)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p-&gt;rotate(angle);</span><br/><span class="EmpStrong">}</span></p>
<p class="indent">To define a particular shape, we must say that it is a <span class="EmpStrong">Shape</span> and specify its particular properties (including its virtual functions):</p>
<p class="codelink"><a id="p043pro03" href="ch04_images.html#p043pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Circle : public Shape {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Circle(Point p, int rr);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">constructor</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Point center() const { return x; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void move(Point to) { x=to; }</span><br/><a id="page_44"/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void draw() const;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void rotate(int) {}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">nice simple algorithm</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Point x;</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">center</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int r;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">radius</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">So far, the <span class="EmpStrong">Shape</span> and <span class="EmpStrong">Circle</span> example provides nothing new compared to the <span class="EmpStrong">Container</span> and <span class="EmpStrong">Vector_container</span> example, but we can build further:</p>
<p class="codelink"><a id="p044pro01" href="ch04_images.html#p044pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Smiley : public Circle {</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use the circle as the base for a face</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Smiley(Point p, int r) : Circle{p,r}, mouth{nullptr} { }</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Smiley()</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete mouth;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : eyes)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete p;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void move(Point to);</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void draw() const;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void rotate(int);</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void add_eye(Shape* s) { eyes.push_back(s); }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void set_mouth(Shape* s);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual void wink(int i);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wink eye number i</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;Shape*&gt; eyes;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">usually two eyes</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape* mouth;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The <span class="EmpStrong">push_back()</span> member function adds its argument to the <span class="EmpStrong">vector</span> (here, <span class="EmpStrong">eyes</span>), increasing that vector&#8217;s size by one.</p>
<p class="indent">We can now define <span class="EmpStrong">Smiley::draw()</span> using calls to <span class="EmpStrong">Smiley</span>&#8217;s base and member <span class="EmpStrong">draw()</span>s:</p>
<p class="pre"><span class="EmpStrong">void Smiley::draw()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Circle::draw();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : eyes)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p-&gt;draw();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">mouth-&gt;draw();</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Note the way that <span class="EmpStrong">Smiley</span> keeps its eyes in a standard-library <span class="EmpStrong">vector</span> and deletes them in its destructor. <span class="EmpStrong">Shape</span>&#8217;s destructor is <span class="EmpStrong">virtual</span> and <span class="EmpStrong">Smiley</span>&#8217;s destructor overrides it. A virtual destructor is <a id="page_45"/>essential for an abstract class because an object of a derived class is usually manipulated through the interface provided by its abstract base class. In particular, it may be deleted through a pointer to a base class. Then, the virtual function call mechanism ensures that the proper destructor is called. That destructor then implicitly invokes the destructors of its bases and members.</p>
<p class="indent">In this simplified example, it is the programmer&#8217;s task to place the eyes and mouth appropriately within the circle representing the face.</p>
<p class="indent">We can add data members, operations, or both as we define a new class by derivation. This gives great flexibility with corresponding opportunities for confusion and poor design.</p>
<div class="heading">
<h4 id="ch04lev2sec4">4.5.1. Explicit Overriding</h4>
<p class="noindent">A function in a derived class overrides a virtual function in a base class if that function has exactly the same name and type. In large hierachies, it is not always obvious if overriding was intended. A function with a slightly different name or a slightly different type may be intended to override or it may be intended to be a separate function. To avoid confusion in such cases, a programmer can explicitly state that a function is meant to override. For example, I could (equivalently) have defined <span class="EmpStrong">Smiley</span> like this:</p>
</div>
<p class="codelink"><a id="p045pro01" href="ch04_images.html#p045pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Smiley : public Circle { //</span> <span class="EmpItalic">use the circle as the base for a face</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Smiley(Point p, int r) : Circle{p,r}, mouth{nullptr} { }</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Smiley()</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete mouth;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : eyes)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete p;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void move(Point to) override;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void draw() const override;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void rotate(int) override;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void add_eye(Shape* s) { eyes.push_back(s); }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void set_mouth(Shape* s);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">virtual void wink(int i);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wink eye number i</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;Shape*&gt; eyes;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">usually two eyes</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape* mouth;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Now, had I mistyped <span class="EmpStrong">move</span> as <span class="EmpStrong">mve</span>, I would have gotten an error because no base of <span class="EmpStrong">Smiley</span> has a virtual function called <span class="EmpStrong">mve</span>. Similarly, had I added <span class="EmpStrong">override</span> to the declaration of <span class="EmpStrong">wink()</span>, I would have gotten an error message.</p>
<div class="heading">
<h4 id="ch04lev2sec5"><a id="page_46"/>4.5.2. Benefits from Hierarchies</h4>
<p class="noindent">A class hierarchy offers two kinds of benefits:</p>
</div>
<p class="indenthangingB">&#8226; <em>Interface inheritance</em>: An object of a derived class can be used wherever an object of a base class is required. That is, the base class acts as an interface for the derived class. The <span class="EmpStrong">Container</span> and <span class="EmpStrong">Shape</span> classes are examples. Such classes are often abstract classes.</p>
<p class="indenthangingB">&#8226; <em>Implementation inheritance</em>: A base class provides functions or data that simplifies the implementation of derived classes. <span class="EmpStrong">Smiley</span>&#8217;s uses of <span class="EmpStrong">Circle</span>&#8217;s constructor and of <span class="EmpStrong">Circle::draw()</span> are examples. Such base classes often have data members and constructors.</p>
<p class="noindent">Concrete classes &#8211; especially classes with small representations &#8211; are much like built-in types: we define them as local variables, access them using their names, copy them around, etc. Classes in class hierarchies are different: we tend to allocate them on the free store using <span class="EmpStrong">new</span>, and we access them through pointers or references. For example, consider a function that reads data describing shapes from an input stream and constructs the appropriate <span class="EmpStrong">Shape</span> objects:</p>
<p class="codelink"><a id="p046pro01" href="ch04_images.html#p046pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">enum class Kind { circle, triangle, smiley };</span><br/><br/><span class="EmpStrong">Shape* read_shape(istream&#38; is)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read shape descriptions from input stream is</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... read shape header from is and find its Kind k ...</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">switch (k) {</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">case Kind::circle:</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read circle data {Point,int} into p and r</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return new Circle{p,r};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">case Kind::triangle:</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read triangle data {Point,Point,Point} into p1, p2, and p3</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return new Triangle{p1,p2,p3};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">case Kind::smiley:</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1, e2, and m</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Smiley* ps = new Smiley{p,r};</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ps-&gt;add_eye(e1);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ps-&gt;add_eye(e2);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ps-&gt;set_mouth(m);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return ps;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A program may use that shape reader like this:</p>
<p class="codelink"><a id="p046pro02" href="ch04_images.html#p046pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void user()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">std::vector&lt;Shape*&gt; v;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">while (cin)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.push_back(read_shape(cin));</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">draw_all(v);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call draw() for each element</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">rotate_all(v,45);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call rotate(45) for each element</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p : v)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">remember to delete elements</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete p;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_47"/>Obviously, the example is simplified &#8211; especially with respect to error handling &#8211; but it vividly illustrates that <span class="EmpStrong">user()</span> has absolutely no idea of which kinds of shapes it manipulates. The <span class="EmpStrong">user()</span> code can be compiled once and later used for new <span class="EmpStrong">Shape</span>s added to the program. Note that there are no pointers to the shapes outside <span class="EmpStrong">user()</span>, so <span class="EmpStrong">user()</span> is responsible for deallocating them. This is done with the <span class="EmpStrong">delete</span> operator and relies critically on <span class="EmpStrong">Shape</span>&#8217;s virtual destructor. Because that destructor is virtual, <span class="EmpStrong">delete</span> invokes the destructor for the most derived class. This is crucial because a derived class may have acquired all kinds of resources (such as file handles, locks, and output streams) that need to be released. In this case, a <span class="EmpStrong">Smiley</span> deletes its <span class="EmpStrong">eyes</span> and <span class="EmpStrong">mouth</span> objects.</p>
<div class="heading">
<h4 id="ch04lev2sec6">4.5.3. Hierarchy Navigation</h4>
<p class="noindent">The <span class="EmpStrong">read_shape()</span> function returns <span class="EmpStrong">Shape</span> <code>*</code> so that we can treat all <span class="EmpStrong">Shapes</span> alike. However, what can we do if we want to use a member function that is only provided by a particular derived class, such as <span class="EmpStrong">Smiley</span>&#8217;s <span class="EmpStrong">wink()</span>? We can ask &#8220;is this <span class="EmpStrong">Shape</span> a kind of <span class="EmpStrong">Smiley</span>?&#8221; using the <span class="EmpStrong">dynamic_cast</span> operator:</p>
</div>
<p class="codelink"><a id="p047pro01" href="ch04_images.html#p047pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Shape* ps {read_shape(cin)};</span><br/><br/><span class="EmpStrong">if (Smiley* p = dynamic_cast&lt;Smiley*&gt;(ps)) {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... is the Smiley pointer to by p ...</span><br/><span class="EmpStrong">}</span><br/><span class="EmpStrong">else {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... not a Smiley, try something else ...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">If the object pointed to by the argument of <span class="EmpStrong">dynamic_cast</span> (here, <span class="EmpStrong">ps</span>) is not of the expected type (here, <span class="EmpStrong">Smiley</span>) or a class derived from the expected type, <span class="EmpStrong">dynamic_cast</span> returns <span class="EmpStrong">nullptr</span>.</p>
<p class="indent">We use <span class="EmpStrong">dynamic_cast</span> to a pointer type when a pointer to an object of a different derived class is a valid argument. We then test whether the result is <span class="EmpStrong">nullptr</span>. This test can often conveniently be placed in the initialization of a variable in a condition.</p>
<p class="indent">When a different type is unacceptable, we can simply <span class="EmpStrong">dynamic_cast</span> to a reference type. If the object is not of the expected type, <span class="EmpStrong">bad_cast</span> is thrown:</p>
<p class="codelink"><a id="p047pro02" href="ch04_images.html#p047pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Shape* ps {read_shape(cin)};</span><br/><span class="EmpStrong">Smiley&#38; r {dynamic_cast&lt;Smiley&#38;&gt;(*ps)};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">somewhere, catch std::bad_cast</span></p>
<p class="noindent">Code is cleaner when <span class="EmpStrong">dynamic_cast</span> is used with restraint. If we can avoid using type information, we can write simpler and more efficient code, but occasionally type information is lost and must be recovered. This typically happens when we pass an object to some system that accepts an interface specified by a base class. When that system later passes the object back to use, we might have to recover the original type. Operations similar to <span class="EmpStrong">dynamic_cast</span> are known as &#8220;is kind of&#8221; and &#8220;is instance of&#8221; operations.</p>
<div class="heading">
<h4 id="ch04lev2sec7">4.5.4. Avoiding Resource Leaks</h4>
<p class="noindent">Experienced programmers will notice that I left open two obvious opportunities for mistakes:</p>
</div>
<p class="indenthangingB">&#8226; A user might fail to <span class="EmpStrong">delete</span> the pointer returned by <span class="EmpStrong">read_shape()</span>.</p>
<p class="indenthangingB">&#8226; The owner of a container of <span class="EmpStrong">Shape</span> pointers might not <span class="EmpStrong">delete</span> the objects pointed to.</p>
<p class="indent">In that sense, functions returning a pointer to an object allocated on the free store are dangerous.</p>
<p class="noindent"><a id="page_48"/>One solution to both problems is to return a standard-library <span class="EmpStrong">unique_ptr</span> (&#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>) rather than a &#8220;naked pointer&#8221; and store <span class="EmpStrong">unique_ptr</span>s in the container:</p>
<p class="codelink"><a id="p048pro01" href="ch04_images.html#p048pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">unique_ptr&lt;Shape&gt; read_shape(istream&#38; is) //</span> <span class="EmpItalic">read shape descriptions from input stream is</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read shape header from is and find its Kind k</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">switch (k) {</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">case Kind::circle:</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read circle data {Point,int} into p and r</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return unique_ptr&lt;Shape&gt;{new Circle{p,r}};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">&#167;11.2.1</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">void user()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">while (cin)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.push_back(read_shape(cin));</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">draw_all(v);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call draw() for each element</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">rotate_all(v,45);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call rotate(45) for each element</span><br/><span class="EmpStrong">} //</span> <span class="EmpItalic">all Shapes implicitly destroyed</span></p>
<p class="noindent">Now the object is owned by the <span class="EmpStrong">unique_ptr</span> which will <span class="EmpStrong">delete</span> the object when it is no longer needed, that is, when its <span class="EmpStrong">unique_ptr</span> goes out of scope.</p>
<p class="indent">For the <span class="EmpStrong">unique_ptr</span> version of <span class="EmpStrong">user()</span> to work, we need versions of <span class="EmpStrong">draw_all()</span> and <span class="EmpStrong">rotate_all()</span> that accept <span class="EmpStrong">vector&lt;unique_ptr&lt;Shape&gt;&gt;</span>s. Writing many such <span class="EmpStrong">_all()</span> functions could become tedious, so &#167;<a href="ch05.html#ch05lev1sec5">5.5</a> shows an alternative.</p>
<div class="heading">
<h3 id="ch04lev1sec6">4.6. Copy and Move</h3>
<p class="noindent">By default, objects can be copied. This is true for objects of user-defined types as well as for builtin types. The default meaning of copy is memberwise copy: copy each member. For example, using <span class="EmpStrong">complex</span> from &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>:</p>
</div>
<p class="codelink"><a id="p048pro02" href="ch04_images.html#p048pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test(complex z1)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex z2 {z1};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy initialization</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">complex z3;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">z3 = z2;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy assignment</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Now <span class="EmpStrong">z1</span>, <span class="EmpStrong">z2</span>, and <span class="EmpStrong">z3</span> have the same value because both the assignment and the initialization copied both members.</p>
<p class="indent">When we design a class, we must always consider if and how an object might be copied. For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some sophisticated concrete types, such as <span class="EmpStrong">Vector</span>, memberwise copy is not the right semantics for copy, and for abstract types it almost never is.</p>
<div class="heading">
<h4 id="ch04lev2sec8"><a id="page_49"/>4.6.1. Copying Containers</h4>
<p class="noindent">When a class is a <em>resource handle</em> &#8211; that is, when the class is responsible for an object accessed through a pointer &#8211; the default memberwise copy is typically a disaster. Memberwise copy would violate the resource handle&#8217;s inv ariant (&#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>). For example, the default copy would leave a copy of a <span class="EmpStrong">Vector</span> referring to the same elements as the original:</p>
</div>
<p class="codelink"><a id="p049pro01" href="ch04_images.html#p049pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void bad_copy(Vector v1)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v2 = v1;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy v1's representation into v2</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v1[0] = 2;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">v2[0] is now also 2!</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v2[1] = 3;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">v1[1] is now also 3!</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Assuming that <span class="EmpStrong">v1</span> has four elements, the result can be represented graphically like this:</p>
<div class="image"><img src="graphics/049fig01.jpg" alt="Image"/></div>
<p class="noindent">Fortunately, the fact that <span class="EmpStrong">Vector</span> has a destructor is a strong hint that the default (memberwise) copy semantics is wrong and the compiler should at least warn against this example. We need to define better copy semantics.</p>
<p class="indent">Copying of an object of a class is defined by two members: a <em>copy constructor</em> and a <em>copy assignment</em>:</p>
<p class="codelink"><a id="p049pro02" href="ch04_images.html#p049pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem; //</span> <span class="EmpItalic">elem points to an array of sz doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(int s);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">constructor: establish invariant, acquire resources</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Vector() { delete[] elem; }</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor: release resources</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(const Vector&#38; a);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector&#38; operator=(const Vector&#38; a);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy assignment</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const double&#38; operator[](int i) const;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() const;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">A suitable definition of a copy constructor for <span class="EmpStrong">Vector</span> allocates the space for the required number of elements and then copies the elements into it, so that after a copy each <span class="EmpStrong">Vector</span> has its own copy of the elements:</p>
<p class="codelink"><a id="page_50"/><a id="p050pro01" href="ch04_images.html#p050pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector::Vector(const Vector&#38; a)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy constructor</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">:elem{new double[a.sz]},</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">allocate space for elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">sz{a.sz}</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=sz; ++i)</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy elements</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">elem[i] = a.elem[i];</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The result of the <span class="EmpStrong">v2=v1</span> example can now be presented as:</p>
<div class="image"><img src="graphics/050fig01.jpg" alt="Image"/></div>
<p class="noindent">Of course, we need a copy assignment in addition to the copy constructor:</p>
<p class="codelink"><a id="p050pro02" href="ch04_images.html#p050pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector&#38; Vector::operator=(const Vector&#38; a)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy assignment</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">double* p = new double[a.sz];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=a.sz; ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p[i] = a.elem[i];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">delete[] elem;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">delete old elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">elem = p;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">sz = a.sz;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return *this;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The name <span class="EmpStrong">this</span> is predefined in a member function and points to the object for which the member function is called.</p>
<div class="heading">
<h4 id="ch04lev2sec9">4.6.2. Moving Containers</h4>
<p class="noindent">We can control copying by defining a copy constructor and a copy assignment, but copying can be costly for large containers. We avoid the cost of copying when we pass objects to a function by using references, but we can&#8217;t return a reference to a local object as the result (the local object would be destroyed by the time the caller got a chance to look at it). Consider:</p>
</div>
<p class="codelink"><a id="p050pro03" href="ch04_images.html#p050pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector operator+(const Vector&#38; a, const Vector&#38; b)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (a.size()!=b.size())</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw Vector_size_mismatch{};</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector res(a.size());</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=a.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">res[i]=a[i]+b[i];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return res;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_51"/>Returning from a <span class="EmpStrong">+</span> involves copying the result out of the local variable <span class="EmpStrong">res</span> and into some place where the caller can access it. We might use this <span class="EmpStrong">+</span> like this:</p>
<p class="codelink"><a id="p051pro01" href="ch04_images.html#p051pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(const Vector&#38; x, const Vector&#38; y, const Vector&#38; z)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector r;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">r = x+y+z;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">That would be copying a <span class="EmpStrong">Vector</span> at least twice (one for each use of the <span class="EmpStrong">+</span> operator). If a <span class="EmpStrong">Vector</span> is large, say, 10,000 <span class="EmpStrong">double</span>s, that could be embarrassing. The most embarrassing part is that <span class="EmpStrong">res</span> in <span class="EmpStrong">operator+()</span> is never used again after the copy. We didn&#8217;t really want a copy; we just wanted to get the result out of a function: we wanted to <em>move</em> a <span class="EmpStrong">Vector</span> rather than to <em>copy</em> it. Fortunately, we can state that intent:</p>
<p class="codelink"><a id="p051pro02" href="ch04_images.html#p051pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(const Vector&#38; a);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector&#38; operator=(const Vector&#38; a);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy assignment</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(Vector&#38;&#38; a);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector&#38; operator=(Vector&#38;&#38; a);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move assignment</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Given that definition, the compiler will choose the <em>move constructor</em> to implement the transfer of the return value out of the function. This means that <span class="EmpStrong">r = x+y+z</span> will involve no copying of <span class="EmpStrong">Vector</span>s. Instead, <span class="EmpStrong">Vector</span>s are just moved.</p>
<p class="indent">As is typical, <span class="EmpStrong">Vector</span>&#8217;s move constructor is trivial to define:</p>
<p class="codelink"><a id="p051pro03" href="ch04_images.html#p051pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector::Vector(Vector&#38;&#38; a)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">:elem{a.elem},</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">"grab the elements" from a</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">sz{a.sz}</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">a.elem = nullptr;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">now a has no elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">a.sz = 0;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">&#38;&#38;</span> means &#8220;rvalue reference&#8221; and is a reference to which we can bind an rvalue. The word &#8220;rvalue&#8221; is intended to complement &#8220;lvalue,&#8221; which roughly means &#8220;something that can appear on the left-hand side of an assignment.&#8221; So an rvalue is &#8211; to a first approximation &#8211; a value that you can&#8217;t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference to something that <em>nobody else</em> can assign to, so that we can safely &#8220;steal&#8221; its value. The <span class="EmpStrong">res</span> local variable in <span class="EmpStrong">operator+()</span> for <span class="EmpStrong">Vector</span>s is an example.</p>
<p class="indent">A move constructor does <em>not</em> take a <span class="EmpStrong">const</span> argument: after all, a move constructor is supposed to remove the value from its argument. A <em>move assignment</em> is defined similarly.</p>
<p class="indent">A move operation is applied when an rvalue reference is used as an initializer or as the right-hand side of an assignment.</p>
<p class="indent"><a id="page_52"/>After a move, a moved-from object should be in a state that allows a destructor to be run. Typically, we should also allow assignment to a moved-from object.</p>
<p class="indent">Where the programmer knows that a value will not be used again, but the compiler can&#8217;t be expected to be smart enough to figure that out, the programmer can be specific:</p>
<p class="codelink"><a id="p052pro01" href="ch04_images.html#p052pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector f()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector x(1000);</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector y(1000);</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector z(1000);</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">z = x;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">we get a copy</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">y = std::move(x);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">we get a move</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return z;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">we get a move</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The standard-library function <span class="EmpStrong">move()</span> returns doesn&#8217;t actually move anything. Instead, it returns a reference to its argument from which we may move &#8211; an <em>rvalue reference</em>.</p>
<p class="indent">Just before the <span class="EmpStrong">return</span> we have:</p>
<div class="image"><img src="graphics/052fig01.jpg" alt="Image"/></div>
<p class="noindent">When <span class="EmpStrong">z</span> is destroyed, it too has been moved from (by the <span class="EmpStrong">return</span>) so that, like <span class="EmpStrong">x</span>, it is empty (it holds no elements).</p>
<div class="heading">
<h4 id="ch04lev2sec10">4.6.3. Essential Operations</h4>
<p class="noindent">Construction of objects plays a key role in many designs. This wide variety of uses is reflected in the range and flexibility of the language features supporting initialization.</p>
</div>
<p class="indent">Constructors, destructors, and copy and move operations for a type are not logically separate. We must define them as a matched set or suffer logical or performance problems. If a class <span class="EmpStrong">X</span> has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:</p>
<p class="codelink"><a id="p052pro02" href="ch04_images.html#p052pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class X {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X(Sometype);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">"ordinary constructor": create an object</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">default constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X(const X&#38;);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X(X&#38;&#38;);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X&#38; operator=(const X&#38;); //</span> <span class="EmpItalic">copy assignment: clean up target and copy</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X&#38; operator=(X&#38;&#38;);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move assignment: clean up target and move</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>X();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor: clean up</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent"><a id="page_53"/>There are five situations in which an object is copied or moved:</p>
<p class="indenthangingB">&#8226; As the source of an assignment</p>
<p class="indenthangingB">&#8226; As an object initializer</p>
<p class="indenthangingB">&#8226; As a function argument</p>
<p class="indenthangingB">&#8226; As a function return value</p>
<p class="indenthangingB">&#8226; As an exception</p>
<p class="noindent">In all cases, the copy or move constructor will be applied (unless it can be optimized away).</p>
<p class="indent">In addition to the initialization of named objects and objects on the free store, constructors are used to initialize temporary objects and to implement explicit type conversion.</p>
<p class="indent">Except for the &#8220;ordinary constructor,&#8221; these special member functions will be generated by the compiler as needed. If you want to be explicit about generating default implementations, you can:</p>
<p class="codelink"><a id="p053pro01" href="ch04_images.html#p053pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Y {</span><br/><span class="EmpStrong">Public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Y(Sometype);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Y(const Y&#38;) = default;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">I really do want the default copy constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Y(Y&#38;&#38;) = default;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">and the default copy constructor</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">If you are explicit about some defaults, other default definitions will not be generated.</p>
<p class="indent">When a class has a pointer or a reference member, it is usually a good idea to be explicit about copy of move operations. The reason is that a pointer or reference will point to something that the class needs to delete, in which case the default copy would be wrong, or it points to something that the class must not delete, in which case a reader of the code would like to know that.</p>
<p class="indent">A constructor taking a single argument defines a conversion from its argument type. For example, <span class="EmpStrong">complex</span> (&#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>) provides a constructor from a <span class="EmpStrong">double</span>:</p>
<p class="codelink"><a id="p053pro02" href="ch04_images.html#p053pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">complex z1 = 3.14; //</span> <span class="EmpItalic">z1 becomes {3.14,0.0}</span><br/><span class="EmpStrong">complex z2 = z1*2; //</span> <span class="EmpItalic">z2 becomes {6.28,0.0}</span></p>
<p class="noindent">Obviously, this is sometimes ideal, but not always. For example, <span class="EmpStrong">Vector</span> (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>) provides a constructor from an <span class="EmpStrong">int</span>:</p>
<p class="codelink"><a id="p053pro03" href="ch04_images.html#p053pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector v1 = 7; //</span> <span class="EmpItalic">OK: v1 has 7 elements</span></p>
<p class="noindent">This is typically considered unfortunate, and the standard-library <span class="EmpStrong">vector</span> does not allow this <span class="EmpStrong">int</span>-to-<span class="EmpStrong">vector</span> &#8220;conversion.&#8221;</p>
<p class="indent">The way to avoid this problem is to say that only explicit &#8220;conversion&#8221; is allowed; that is, we can define the constructor like this:</p>
<p class="codelink"><a id="p053pro04" href="ch04_images.html#p053pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">explicit Vector(int s);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no implicit conversion from int to Vector</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">That gives us:</p>
<p class="codelink"><a id="p053pro05" href="ch04_images.html#p053pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector v1(7);&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">OK: v1 has 7 elements</span><br/><span class="EmpStrong">Vector v2 = 7;&#160;&#160;&#160;//</span> <span class="EmpItalic">error: no implicit conversion from int to Vector</span></p>
<p class="noindent"><a id="page_54"/>When it comes to conversions, more types are like <span class="EmpStrong">Vector</span> than are like <span class="EmpStrong">complex</span>, so use <span class="EmpStrong">explicit</span> for constructors that take a single argument unless there is a good reason not to.</p>
<div class="heading">
<h4 id="ch04lev2sec11">4.6.4. Resource Management</h4>
<p class="noindent">By defining constructors, copy operations, move operations, and a destructor, a programmer can provide complete control of the lifetime of a contained resource (such as the elements of a container). Furthermore, a move constructor allows an object to move simply and cheaply from one scope to another. That way, objects that we cannot or would not want to copy out of a scope can be simply and cheaply moved out instead. Consider a standard-library <span class="EmpStrong">thread</span> representing a concurrent activity (&#167;<a href="ch13.html#ch13lev1sec2">13.2</a>) and a <span class="EmpStrong">Vector</span> of a million <span class="EmpStrong">double</span>s. We can&#8217;t copy the former and don&#8217;t want to copy the latter.</p>
</div>
<p class="codelink"><a id="p054pro01" href="ch04_images.html#p054pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">std::vector&lt;thread&gt; my_threads;</span><br/><br/><span class="EmpStrong">Vector init(int n)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t {heartbeat};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">run heartbeat concurrently (on its own thread)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">my_threads.push_back(move(t));</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move t into my_threads</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... more initialization ...</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector vec(n);</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i&lt;vec.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vec[i] = 777;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return vec;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move res out of init()</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">auto v = init(10000);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">start heartbeat and initialize v</span></p>
<p class="noindent">This makes resource handles, such as <span class="EmpStrong">Vector</span> and <span class="EmpStrong">thread</span>, an alternative to using pointers in many cases. In fact, the standard-library &#8220;smart pointers,&#8221; such as <span class="EmpStrong">unique_ptr</span>, are themselves resource handles (&#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>).</p>
<p class="indent">I used the standard-library <span class="EmpStrong">vector</span> to hold the <span class="EmpStrong">thread</span>s because we don&#8217;t get to parameterize <span class="EmpStrong">Vector</span> with an element type until &#167;<a href="ch05.html#ch05lev1sec2">5.2</a>.</p>
<p class="indent">In very much the same way as <span class="EmpStrong">new</span> and <span class="EmpStrong">delete</span> disappear from application code, we can make pointers disappear into resource handles. In both cases, the result is simpler and more maintainable code, without added overhead. In particular, we can achieve <em>strong resource safety</em>; that is, we can eliminate resource leaks for a general notion of a resource. Examples are <span class="EmpStrong">vector</span>s holding memory, <span class="EmpStrong">thread</span>s holding system threads, and <span class="EmpStrong">fstream</span>s holding file handles.</p>
<p class="indent">In many languages, resource management is primarily delegated to a garbage collector. C++ also offers a garbage collection interface so that you can plug in a garbage collector. However, I consider garbage collection the last alternative after cleaner, more general, and better localized alternatives to resource management have been exhausted.</p>
<p class="indent">Garbage collection is fundamentally a global memory management scheme. Clever implementations can compensate, but as systems are getting more distributed (think multicores, caches, and clusters), locality is more important than ever.</p>
<p class="indent"><a id="page_55"/>Also, memory is not the only resource. A resource is anything that has to be acquired and (explicitly or implicitly) released after use. Examples are memory, locks, sockets, file handles, and thread handles. A good resource management system handles all kinds of resources. Leaks must be avoided in any long-running systems, but excessive resource retention can be almost as bad as a leak. For example, if a system holds on to memory, locks, files, etc., for twice as long, the system needs to be provisioned with potentially twice as many resources.</p>
<p class="indent">Before resorting to garbage collection, systematically use resource handles: Let each resource have an owner in some scope and by default be released at the end of its owners scope. In C++, this is known as RAII (<em>Resource Acquisition Is Initialization</em>) and is integrated with error handling in the form of exceptions. Resources can be moved from scope to scope using move semantics or &#8220;smart pointers,&#8221; and shared ownership can be represented by &#8220;shared pointers&#8221; (&#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>).</p>
<p class="indent">In the C++ standard library, RAII is pervasive: for example, memory (<span class="EmpStrong">string</span>, <span class="EmpStrong">vector</span>, <span class="EmpStrong">map</span>, <span class="EmpStrong">unordered_map</span>, etc.), files (<span class="EmpStrong">ifstream</span>, <span class="EmpStrong">ofstream</span>, etc.), threads (<span class="EmpStrong">thread</span>), locks (<span class="EmpStrong">lock_guard</span>, <span class="EmpStrong">unique_lock</span>, etc.), and general objects (through <span class="EmpStrong">unique_ptr</span> and <span class="EmpStrong">shared_ptr</span>). The result is implicit resource management that is invisible in common use and leads to low resource retention durations.</p>
<div class="heading">
<h4 id="ch04lev2sec12">4.6.5. Suppressing Operations</h4>
<p class="noindent">Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer to a base, we simply don&#8217;t know what members the derived class has (&#167;<a href="ch04.html#ch04lev1sec3">4.3</a>), so we can&#8217;t know how to copy them. So, the best thing to do is usually to <em>delete</em> the default copy and move operations, that is, to eliminate the default definitions of those two operations:</p>
</div>
<p class="codelink"><a id="p055pro01" href="ch04_images.html#p055pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Shape {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape(const Shape&#38;) =delete;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no copy operations</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape&#38; operator=(const Shape&#38;) =delete;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape(Shape&#38;&#38;) =delete;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no move operations</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape&#38; operator=(Shape&#38;&#38;) =delete;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Shape();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Now an attempt to copy a <span class="EmpStrong">Shape</span> will be caught by the compiler. If you need to copy an object in a class hierarchy, write a <span class="EmpStrong">virtual</span> clone function.</p>
<p class="indent">In this particular case, if you forgot to <span class="EmpStrong">delete</span> a copy or move operation, no harm is done. A move operation is <em>not</em> implicitly generated for a class where the user has explicitly declared a destructor, so you get a compiler error if you try to move a <span class="EmpStrong">Shape</span>. Furthermore, the generation of copy operations is deprecated in this case (&#167;<a href="ch14.html#ch14lev2sec6">14.2.3</a>), so you should expect the compiler to issue a warning if you try to copy a <span class="EmpStrong">Shape</span>.</p>
<p class="indent">A base class in a class hierarchy is just one example of an object we wouldn&#8217;t want to copy. A resource handle generally cannot be copied just by copying its members (&#167;<a href="ch04.html#ch04lev2sec8">4.6.1</a>).</p>
<p class="indent">The <span class="EmpStrong">=delete</span> mechanism is general, that is, it can be used to suppress any operation.</p>
<div class="heading">
<h3 id="ch04lev1sec7"><a id="page_56"/>4.7. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapters 16-22 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Express ideas directly in code; &#167;<a href="ch04.html#ch04lev1sec1">4.1</a>.</p>
<p class="ref">[3] A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over more complicated classes and over plain data structures; &#167;<a href="ch04.html#ch04lev1sec2">4.2</a>.</p>
<p class="ref">[4] Use concrete classes to represent simple concepts and performance-critical components; &#167;<a href="ch04.html#ch04lev1sec2">4.2</a>.</p>
<p class="ref">[5] Define a constructor to handle initialization of objects; &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>, &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref">[6] Make a function a member only if it needs direct access to the representation of a class; &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>.</p>
<p class="ref">[7] Define operators primarily to mimic conventional usage; &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>.</p>
<p class="ref">[8] Use nonmember functions for symmetric operators; &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>.</p>
<p class="ref">[9] Declare a member function that does not modify the state of its object <span class="EmpStrong">const</span>; &#167;<a href="ch04.html#ch04lev2sec1">4.2.1</a>.</p>
<p class="ref1">[10] If a constructor acquires a resource, its class needs a destructor to release the resource; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>.</p>
<p class="ref1">[11] Avoid &#8220;naked&#8221; <span class="EmpStrong">new</span> and <span class="EmpStrong">delete</span> operations; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>.</p>
<p class="ref1">[12] Use resource handles and RAII to manage resources; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>.</p>
<p class="ref1">[13] If a class is a container, give it an initializer-list constructor; &#167;<a href="ch04.html#ch04lev2sec3">4.2.3</a>.</p>
<p class="ref1">[14] Use abstract classes as interfaces when complete separation of interface and implementation is needed; &#167;<a href="ch04.html#ch04lev1sec3">4.3</a>.</p>
<p class="ref1">[15] Access polymorphic objects through pointers and references; &#167;<a href="ch04.html#ch04lev1sec3">4.3</a>.</p>
<p class="ref1">[16] An abstract class typically doesn&#8217;t need a constructor; &#167;<a href="ch04.html#ch04lev1sec3">4.3</a>.</p>
<p class="ref1">[17] Use class hierarchies to represent concepts with inherent hierarchical structure; &#167;<a href="ch04.html#ch04lev1sec5">4.5</a>.</p>
<p class="ref1">[18] A class with a virtual function should have a virtual destructor; &#167;<a href="ch04.html#ch04lev1sec5">4.5</a>.</p>
<p class="ref1">[19] Use <span class="EmpStrong">override</span> to make overriding explicit in large class hierarchies; &#167;<a href="ch04.html#ch04lev2sec4">4.5.1</a>.</p>
<p class="ref1">[20] When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance; &#167;<a href="ch04.html#ch04lev2sec5">4.5.2</a>.</p>
<p class="ref1">[21] Use <span class="EmpStrong">dynamic_cast</span> where class hierarchy navigation is unavoidable; &#167;<a href="ch04.html#ch04lev2sec6">4.5.3</a>.</p>
<p class="ref1">[22] Use <span class="EmpStrong">dynamic_cast</span> to a reference type when failure to find the required class is considered a failure; &#167;<a href="ch04.html#ch04lev2sec6">4.5.3</a>.</p>
<p class="ref1">[23] Use <span class="EmpStrong">dynamic_cast</span> to a pointer type when failure to find the required class is considered a valid alternative; &#167;<a href="ch04.html#ch04lev2sec6">4.5.3</a>.</p>
<p class="ref1">[24] Use <span class="EmpStrong">unique_ptr</span> or <span class="EmpStrong">shared_ptr</span> to avoid forgetting to <span class="EmpStrong">delete</span> objects created using <span class="EmpStrong">new</span>; &#167;<a href="ch04.html#ch04lev2sec7">4.5.4</a>.</p>
<p class="ref1">[25] Redefine or prohibit copying if the default is not appropriate for a type; &#167;<a href="ch04.html#ch04lev2sec8">4.6.1</a>, &#167;<a href="ch04.html#ch04lev2sec12">4.6.5</a>.</p>
<p class="ref1">[26] Return containers by value (relying on move for efficiency); &#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>.</p>
<p class="ref1">[27] For large operands, use <span class="EmpStrong">const</span> reference argument types; &#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>.</p>
<p class="ref1">[28] If a class has a destructor, it probably needs user-defined or deleted copy and move operations; &#167;<a href="ch04.html#ch04lev2sec12">4.6.5</a>.</p>
<p class="ref1">[29] Control construction, copy, move, and destruction of objects; &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref1">[30] Design constructors, assignments, and the destructor as a matched set of operations; &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref1">[31] If a default constructor, assignment, or destructor is appropriate, let the compiler generate it (don&#8217;t rewrite it yourself); &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref1"><a id="page_57"/>[32] By default, declare single-argument constructors <span class="EmpStrong">explicit</span>; &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref1">[33] If a class has a pointer or reference member, it probably needs a destructor and non-default copy operations; &#167;<a href="ch04.html#ch04lev2sec10">4.6.3</a>.</p>
<p class="ref1">[34] Provide strong resource safety; that is, never leak anything that you think of as a resource; &#167;<a href="ch04.html#ch04lev2sec11">4.6.4</a>.</p>
<p class="ref1">[35] If a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations; &#167;<a href="ch04.html#ch04lev2sec11">4.6.4</a>.</p>
</body>
</html>
