<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>7. Strings and Regular Expressions</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch07"><a id="page_75"/><span class="pd_blue">7.</span> Strings and Regular Expressions</h2>
<p class="blockquote"><em>Prefer the standard to the offbeat.</em></p>
<p class="attribution"><em>&#8211; Strunk &#38; White</em></p>
<p class="indenthangingB">&#8226; <a href="ch07.html#ch07lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch07.html#ch07lev1sec2">Strings</a></p>
<p class="indenthangingBP"><a href="ch07.html#ch07lev2sec1"><span class="EmpStrong">string</span> Implementation</a></p>
<p class="indenthangingB">&#8226; <a href="ch07.html#ch07lev1sec3">Regular Expressions</a></p>
<p class="indenthangingBP"><a href="ch07.html#ch07lev2sec2">Searching</a>; <a href="ch07.html#ch07lev2sec3">Regular Expression Notation</a>; <a href="ch07.html#ch07lev2sec4">Iterators</a></p>
<p class="indenthangingB">&#8226; <a href="ch07.html#ch07lev1sec4">Advice</a></p>
<div class="heading">
<h3 id="ch07lev1sec1">7.1. Introduction</h3>
<p class="noindent">Text manipulation is a major part of most programs. The C++ standard library offers a <span class="EmpStrong">sting</span> type to save most users from C-style manipulation of arrays of characters through pointers. In addition, regular expression matching is offered to help find patterns in text. The regular expressions are provided in a form similar to what is common in most modern languages. Both <span class="EmpStrong">string</span>s and <span class="EmpStrong">regex</span> objects can use a variety of character types (e.g., Unicode).</p>
</div>
<div class="heading">
<h3 id="ch07lev1sec2">7.2. Strings</h3>
<p class="noindent">The standard library provides a <span class="EmpStrong">string</span> type to complement the string literals (&#167;<a href="ch01.html#ch01lev1sec3">1.3</a>). The <span class="EmpStrong">string</span> type provides a variety of useful string operations, such as concatenation. For example:</p>
</div>
<p class="codelink"><a id="p075pro01" href="ch07_images.html#p075pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">string compose(const string&#38; name, const string&#38; domain)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return name + '@' + domain;</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">auto addr = compose("dmr","bell-labs.com");</span></p>
<p class="noindent"><a id="page_76"/>Here, <span class="EmpStrong">addr</span> is initialized to the character sequence <span class="EmpStrong"><a href="mailto:dmr@bell-labs.com">dmr@bell-labs.com</a></span>. &#8220;Addition&#8221; of strings means concatenation. You can concatenate a <span class="EmpStrong">string</span>, a string literal, a C-style string, or a character to a <span class="EmpStrong">string</span>. The standard <span class="EmpStrong">string</span> has a move constructor so returning even long <span class="EmpStrong">string</span>s by value is efficient (&#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>).</p>
<p class="indent">In many applications, the most common form of concatenation is adding something to the end of a <span class="EmpStrong">string</span>. This is directly supported by the <span class="EmpStrong">+=</span> operation. For example:</p>
<p class="codelink"><a id="p076pro01" href="ch07_images.html#p076pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void m2(string&#38; s1, string&#38; s2)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">s1 = s1 + '\n';</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">append newline</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">s2 += '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">append newline</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The two ways of adding to the end of a <span class="EmpStrong">string</span> are semantically equivalent, but I prefer the latter because it is more explicit about what it does, more concise, and possibly more efficient.</p>
<p class="indent">A <span class="EmpStrong">string</span> is mutable. In addition to <span class="EmpStrong">=</span> and <span class="EmpStrong">+=</span>, subscripting (using <span class="EmpStrong">[ ]</span>), and substring operations are supported. Among other useful features, it provides the ability to manipulate substrings. For example:</p>
<p class="codelink"><a id="p076pro02" href="ch07_images.html#p076pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">string name = "Niels Stroustrup";</span><br/><br/><span class="EmpStrong">void m3()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string s = name.substr(6,10);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">s = "Stroustrup"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">name.replace(0,5,"nicholas");</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">name becomes "nicholas Stroustrup"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">name[0] = toupper(name[0]);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">name becomes "Nicholas Stroustrup"</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">substr()</span> operation returns a <span class="EmpStrong">string</span> that is a copy of the substring indicated by its arguments. The first argument is an index into the <span class="EmpStrong">string</span> (a position), and the second is the length of the desired substring. Since indexing starts from <span class="EmpStrong">0</span>, <span class="EmpStrong">s</span> gets the value <span class="EmpStrong">Stroustrup</span>.</p>
<p class="indent">The <span class="EmpStrong">replace()</span> operation replaces a substring with a value. In this case, the substring starting at <span class="EmpStrong">0</span> with length <span class="EmpStrong">5</span> is <span class="EmpStrong">Niels</span>; it is replaced by <span class="EmpStrong">nicholas</span>. Finally, I replace the initial character with its uppercase equivalent. Thus, the final value of <span class="EmpStrong">name</span> is <span class="EmpStrong">Nicholas Stroustrup</span>. Note that the replacement string need not be the same size as the substring that it is replacing.</p>
<p class="indent">Naturally, <span class="EmpStrong">string</span>s can be compared against each other and against string literals. For example:</p>
<p class="codelink"><a id="p076pro03" href="ch07_images.html#p076pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">string incantation;</span><br/><br/><span class="EmpStrong">void respond(const string&#38; answer)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (answer == incantation) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">perform magic</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">else if (answer == "yes") {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_77"/>Among the many useful <span class="EmpStrong">string</span> operations are assignment (using <span class="EmpStrong">=</span>), subscripting (using <span class="EmpStrong">[ ]</span> or <span class="EmpStrong">at()</span> as for <span class="EmpStrong">vector</span>; &#167;<a href="ch09.html#ch09lev2sec2">9.2.2</a>), iteration (using iterators as for <span class="EmpStrong">vector</span>; &#167;<a href="ch10.html#ch10lev1sec2">10.2</a>), input (&#167;<a href="ch08.html#ch08lev1sec3">8.3</a>), streaming (&#167;<a href="ch08.html#ch08lev1sec8">8.8</a>).</p>
<p class="indent">If you need a C-style string (a zero-terminated array of <span class="EmpStrong">char</span>), <span class="EmpStrong">string</span> offers read-only access to its contained characters. For example:</p>
<p class="codelink"><a id="p077pro01" href="ch07_images.html#p077pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void print(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">printf("For people who like printf: %s\n",s.c_str());</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "For people who like streams: " &lt;&lt; s &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<div class="heading">
<h4 id="ch07lev2sec1">7.2.1. <span class="EmpStrong">string</span> Implementation</h4>
<p class="noindent">Implementing a string class is a popular and useful exercise. However, for general-purpose use, our carefully crafted first attempts rarely match the standard <span class="EmpStrong">string</span> in convenience or performance. These days, <span class="EmpStrong">string</span> is usually implemented using the <em>short-string optimization</em>. That is, short string values are kept in the <span class="EmpStrong">string</span> object itself and only longer strings are placed on free store. Consider:</p>
</div>
<p class="codelink"><a id="p077pro02" href="ch07_images.html#p077pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">string s1 {"Annemarie"};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">short string</span><br/><span class="EmpStrong">string s2 {"Annemarie Stroustrup"};</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">long string</span></p>
<p class="noindent">The memory layout will be something like:</p>
<div class="image"><img src="graphics/077fig01.jpg" alt="Image"/></div>
<p class="noindent">When a <span class="EmpStrong">string</span>&#8217;s value changes from a short to a long string (and vice verse) its representation adjusts appropriately.</p>
<p class="indent">The actual performance of <span class="EmpStrong">string</span>s can depend critically on the run-time environment. In particular, in multi-threaded implementations, memory allocation can be relatively costly. Also, when lots of strings of differing lengths are used, memory fragmentation can result. These are the main reasons that the short-string optimization has become ubiquitous.</p>
<p class="indent">To handle multipe character sets, <span class="EmpStrong">string</span> is really an alias for a general template <span class="EmpStrong">basic_string</span> with the character type <span class="EmpStrong">char</span>:</p>
<p class="codelink"><a id="p077pro03" href="ch07_images.html#p077pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Char&gt;</span><br/><span class="EmpStrong">class basic_string {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... string of Char ...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">using string = basic_string&lt;char&gt;</span></p>
<p class="noindent">A user can define strings of arbitrary character types. For example, assuming we have a Japanese character type <span class="EmpStrong">Jchar</span>, we can write:</p>
<p class="codelink"><a id="p077pro04" href="ch07_images.html#p077pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">using Jstring = basic_string&lt;Jchar&gt;;</span></p>
<p class="noindent"><a id="page_78"/>Now we can do all the usual string operations on <span class="EmpStrong">Jstring</span>, a string of Japanese characters. Similarly, we can handle Unicode strings.</p>
<div class="heading">
<h3 id="ch07lev1sec3">7.3. Regular Expressions</h3>
<p class="noindent">Regular expressions are a powerful tool for text processing. They provide a way to simply and tersely describe patterns in text (e.g., a U.S. postal code such as <span class="EmpStrong">TX 77845</span>, or an ISO-style date, such as <span class="EmpStrong">2009-06-07</span>) and to efficiently find such patterns in text. In <span class="EmpStrong">&lt;regex&gt;</span>, the standard library provides support for regular expressions in the form of the <span class="EmpStrong">std::regex</span> class and its supporting functions. To give a taste of the style of the <span class="EmpStrong">regex</span> library, let us define and print a pattern:</p>
</div>
<p class="codelink"><a id="p078pro01" href="ch07_images.html#p078pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">regex pat {R"(\w{2}\s</span> *<span class="EmpStrong">\d{5}(-\d{4})?)"}; //</span> <span class="EmpItalic">US postal code pattern: XXddddd-dddd and variants</span></p>
<p class="noindent">People who have used regular expressions in just about any language will find <span class="EmpStrong">\w{2}\s</span> <code>*</code><span class="EmpStrong">\d{5}(-\d{4})?</span> familiar. It specifies a pattern starting with two letters <span class="EmpStrong">\w{2}</span> optionally followed by some space <span class="EmpStrong">\s</span> <code>*</code> followed by five digits <span class="EmpStrong">\d{5}</span> and optionally followed by a dash and four digits <span class="EmpStrong">-\d{4}</span>. If you are not familiar with regular expressions, this may be a good time to learn about them ([Stroustrup,2009], [Maddock,2009], [Friedl,1997]).</p>
<p class="indent">To express the pattern, I use a <em>raw string literal</em> starting with <span class="EmpStrong">R"(</span> and terminated by <span class="EmpStrong">)"</span>. This allows backslashes and quotes to be used directly in the string. Raw strings are particularly suitable for regular expressions because they tend to contain a lot of backslashes. Had I used a conventional string, the pattern definition would have been:</p>
<p class="codelink"><a id="p078pro02" href="ch07_images.html#p078pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">regex pat {"\\w{2}\\s*\\d{5}(-\\d{4})?"};</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">U.S. postal code pattern</span></p>
<p class="noindent">In <span class="EmpStrong">&lt;regex&gt;</span>, the standard library provides support for regular expressions:</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">regex_match()</span>: Match a regular expression against a string (of known size) (&#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>).</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">regex_search()</span>: Search for a string that matches a regular expression in an (arbitrarily long) stream of data (&#167;<a href="ch07.html#ch07lev2sec2">7.3.1</a>).</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">regex_replace()</span>: Search for strings that match a regular expression in an (arbitrarily long) stream of data and replace them.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">regex_iterator</span>: Iterate over matches and submatches (&#167;<a href="ch07.html#ch07lev2sec4">7.3.3</a>).</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">regex_token_iterator</span>: Iterate over non-matches.</p>
<div class="heading">
<h4 id="ch07lev2sec2">7.3.1. Searching</h4>
<p class="noindent">The simplest way of using a pattern is to search for it in a stream:</p>
</div>
<p class="codelink"><a id="p078pro03" href="ch07_images.html#p078pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int lineno = 0;</span><br/><span class="EmpStrong">for (string line; getline(cin,line);) {</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read into line buffer</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">++lineno;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">smatch matches;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">matched strings go here</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (regex_search(line,matches,pat))</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">search for pat in line</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; lineno &lt;&lt; ": " &lt;&lt; matches[0] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">regex_search(line,matches,pat)</span> searches the <span class="EmpStrong">line</span> for anything that matches the regular expression stored in <span class="EmpStrong">pat</span> and if it finds any matches, it stores them in <span class="EmpStrong">matches</span>. If no match was found, <a id="page_79"/><span class="EmpStrong">regex_search(line,matches,pat)</span> returns <span class="EmpStrong">false</span>. The <span class="EmpStrong">matches</span> variable is of type <span class="EmpStrong">smatch</span>. The &#8220;s&#8221; stands for &#8220;sub&#8221; or &#8220;string,&#8221; and an <span class="EmpStrong">smatch</span> is a <span class="EmpStrong">vector</span> of sub-matches of type <span class="EmpStrong">string</span>. The first element, here <span class="EmpStrong">matches[0]</span>, is the complete match. The result of a <span class="EmpStrong">regex_search()</span> is a collection of matches, typically represented as an <span class="EmpStrong">smatch</span>:</p>
<p class="codelink"><a id="p079pro01" href="ch07_images.html#p079pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void use()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">ifstream in("file.txt");</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">input file</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (!in)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">check that the file was opened</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "no file\n";</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">regex pat {R"(\w{2}\s*\d{5}(-\d{4})?)"};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">U.S. postal code pattern</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int lineno = 0;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (string line; getline(in,line);) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">++lineno;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">smatch matches;</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">matched strings go here</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (regex_search(line, matches, pat)) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; lineno &lt;&lt; ": " &lt;&lt; matches[0] &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the complete match</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (1&lt;matches.size() &#38;&#38; matches[1].matched)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "\t: " &lt;&lt; matches[1] &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">submatch</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This function reads a file looking for U.S. postal codes, such as <span class="EmpStrong">TX77845</span> and <span class="EmpStrong">DC 20500-0001</span>. An <span class="EmpStrong">smatch</span> type is a container of regex results. Here, <span class="EmpStrong">matches[0]</span> is the whole pattern and <span class="EmpStrong">matches[1]</span> is the optional four-digit subpattern.</p>
<p class="indent">The regular expression syntax and semantics are designed so that regular expressions can be compiled into state machines for efficient execution [Cox,2007]. The <span class="EmpStrong">regex</span> type performs this compilation at run time.</p>
<div class="heading">
<h4 id="ch07lev2sec3">7.3.2. Regular Expression Notation</h4>
<p class="noindent">The <span class="EmpStrong">regex</span> library can recognize several variants of the notation for regular expressions. Here, I use the default notation used, a variant of the ECMA standard used for ECMAScript (more commonly known as JavaScript).</p>
</div>
<p class="indent">The syntax of regular expressions is based on characters with special meaning:</p>
<div class="image"><img src="graphics/079tab01.jpg" alt="Image"/></div>
<p class="noindent"><a id="page_80"/>For example, we can specify a line starting with zero or more <span class="EmpStrong">A</span>s followed by one or more <span class="EmpStrong">B</span>s followed by an optional <span class="EmpStrong">C</span> like this:</p>
<p class="pre"><span class="EmpStrong">^A</span> *<span class="EmpStrong">B+C?$</span></p>
<p class="noindent">Examples that match:</p>
<p class="pre"><span class="EmpStrong">AAAAAAAAAAAABBBBBBBBBC</span><br/><span class="EmpStrong">BC</span><br/><span class="EmpStrong">B</span></p>
<p class="noindent">Examples that do not match:</p>
<p class="pre"><span class="EmpStrong">AAAAA</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no B</span><br/>&#160;&#160;<span class="EmpStrong">AAAABC</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initial space</span><br/><span class="EmpStrong">AABBCC</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">too many Cs</span></p>
<p class="noindent">A part of a pattern is considered a subpattern (which can be extracted separately from an <span class="EmpStrong">smatch</span>) if it is enclosed in parentheses. For example:</p>
<p class="pre"><span class="EmpStrong">\d+-\d+</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no subpatterns</span><br/><span class="EmpStrong">\d+(-\d+)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">one subpattern</span><br/><span class="EmpStrong">(\d+)(-\d+)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">two subpatterns</span></p>
<p class="noindent">A pattern can be optional or repeated (the default is exactly once) by adding a suffix:</p>
<div class="image"><img src="graphics/080tab01.jpg" alt="Image"/></div>
<p class="noindent">For example:</p>
<p class="pre"><span class="EmpStrong">A{3}B{2,4}C</span> *</p>
<p class="noindent">Examples that match:</p>
<p class="pre"><span class="EmpStrong">AAABBC</span><br/><span class="EmpStrong">AAABBB</span></p>
<p class="noindent">Example that do not match:</p>
<p class="pre"><span class="EmpStrong">AABBC</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">too few As</span><br/><span class="EmpStrong">AAABC</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">too few Bs</span><br/><span class="EmpStrong">AAABBBBBCCC</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">too many Bs</span></p>
<p class="noindent">A suffix <span class="EmpStrong">?</span> after any of the repetition notations (<span class="EmpStrong">?</span>, <code>*</code>, <span class="EmpStrong">?</span>, and <span class="EmpStrong">{ }</span>) makes the pattern matcher &#8220;lazy&#8221; or &#8220;non-greedy.&#8221; That is, when looking for a pattern, it will look for the shortest match rather than the longest. By default, the pattern matcher always looks for the longest match; this is known as the <em>Max Munch rule</em>. Consider:</p>
<p class="pre"><a id="page_81"/><span class="EmpStrong">ababab</span></p>
<p class="noindent">The pattern <span class="EmpStrong">(ab)</span> <code>*</code> matches all of <span class="EmpStrong">ababab</span>. However, <span class="EmpStrong">(ab)</span> <code>*</code><span class="EmpStrong">?</span> matches only the first <span class="EmpStrong">ab</span>.</p>
<p class="indent">The most common character classifications have names:</p>
<div class="image"><img src="graphics/081tab01.jpg" alt="Image"/></div>
<p class="noindent">In a regular expression, a character class name must be bracketed by <span class="EmpStrong">[: :]</span>. For example, <span class="EmpStrong">[:digit:]</span> matches a decimal digit. Furthermore, they must be used within a <span class="EmpStrong">[ ]</span> pair defining a character class.</p>
<p class="indent">Several character classes are supported by shorthand notation:</p>
<div class="image"><img src="graphics/081tab02.jpg" alt="Image"/></div>
<p class="noindent">In addition, languages supporting regular expressions often provide:</p>
<div class="image"><img src="graphics/081tab03.jpg" alt="Image"/></div>
<p class="noindent">For full portability, use the character class names rather than these abbreviations.</p>
<p class="indent">As an example, consider writing a pattern that describes C++ identifiers: an underscore or a letter followed by a possibly empty sequence of letters, digits, or underscores. To illustrate the <a id="page_82"/>subtleties involved, I include a few false attempts:</p>
<p class="codelink"><a id="p082pro01" href="ch07_images.html#p082pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">[:alpha:][:alnum:]</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wrong: characters from the set ":alph" followed by ...</span><br/><span class="EmpStrong">[[:alpha:]][[:alnum:]]</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wrong: doesn't accept underscore ('_' is not alpha)</span><br/><span class="EmpStrong">([[:alpha:]]|_)[[:alnum:]]</span>*&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wrong: underscore is not part of alnum either</span><br/><br/><span class="EmpStrong">([[:alpha:]]|_)([[:alnum:]]|_)</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">OK, but clumsy</span><br/><span class="EmpStrong">[[:alpha:]_][[:alnum:]_]</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">OK: include the underscore in the character classes</span><br/><span class="EmpStrong">[_[:alpha:]][_[:alnum:]]</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">also OK</span><br/><span class="EmpStrong">[_[:alpha:]]\w</span>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">\w is equivalent to [_[:alnum:]]</span></p>
<p class="noindent">Finally, here is a function that uses the simplest version of <span class="EmpStrong">regex_match()</span> (&#167;<a href="ch07.html#ch07lev2sec2">7.3.1</a>) to test whether a string is an identifier:</p>
<p class="codelink"><a id="p082pro02" href="ch07_images.html#p082pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool is_identifier(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">regex pat {"[_[:alpha:]]\\w*"}; //</span> <span class="EmpItalic">underscore or letter</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">followed by zero or more underscores, letters, or digits</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return regex_match(s,pat);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Note the doubling of the backslash to include a backslash in an ordinary string literal. Use raw string literals to alleviate problems with special characters. For example:</p>
<p class="codelink"><a id="p082pro03" href="ch07_images.html#p082pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool is_identifier(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">regex pat {R"([_[:alpha:]]\w*)"};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return regex_match(s,pat);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here are some examples of patterns:</p>
<p class="codelink"><a id="p082pro04" href="ch07_images.html#p082pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Ax*</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">A, Ax, Axxxx</span><br/><span class="EmpStrong">Ax+</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Ax, Axxx</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">Not A</span><br/><span class="EmpStrong">\d-?\d</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">1-2, 12</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">Not 1--2</span><br/><span class="EmpStrong">\w{2}-\d{4,5}</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Ab-1234, XX-54321, 22-5432</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">Digits are in\w</span><br/><span class="EmpStrong">(\d*:)?(\d+)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">12:3, 1:23, 123, :123</span>&#160;&#160;<span class="EmpItalic">Not 123:</span><br/><span class="EmpStrong">(bs|BS)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">bs, BS</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">Not bS</span><br/><span class="EmpStrong">[aeiouy]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">a, o, u</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">An English vowel, not x</span><br/><span class="EmpStrong">[&#94;aeiouy]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">x, k</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">Not an English vowel, not e</span><br/><span class="EmpStrong">[a&#94;eiouy]</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">a, &#94;, o, u</span>&#160;&#160;&#160;<span class="EmpItalic">An English vowel or&#94;</span></p>
<p class="noindent">A <span class="EmpStrong">group</span> (a subpattern) potentially to be represented by a <span class="EmpStrong">sub_match</span> is delimited by parentheses. If you need parentheses that should not define a subpattern, use <span class="EmpStrong">(?</span> rather than plain <span class="EmpStrong">(</span>. For example:</p>
<p class="codelink"><a id="p082pro05" href="ch07_images.html#p082pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">(\s|:|,)*(\d*)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">spaces, colons, and/or commas followed by a number</span></p>
<p class="noindent">Assuming that we were not interested in the characters before the number (presumably separators), we could write:</p>
<p class="codelink"><a id="p082pro06" href="ch07_images.html#p082pro06a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">(?\s|:|,)*(\d*)</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">spaces, colons, and/or commas followed by a number</span></p>
<p class="noindent">This would save the regular expression engine from having to store the first characters: the <span class="EmpStrong">(?</span> variant has only one subpattern.</p>
<div class="image"><a id="page_83"/><img src="graphics/083tab01.jpg" alt="Image"/></div>
<p class="noindent">That last pattern is useful for parsing XML. It finds tag/end-of-tag markers. Note that I used a non-greedy match (a <em>lazy match</em>), <span class="EmpStrong">.</span> <code>*</code><span class="EmpStrong">?</span>, for the subpattern between the tag and the end tag. Had I used plain <span class="EmpStrong">.</span> <code>*</code>, this input would have caused a problem:</p>
<p class="codelink"><a id="p083pro01" href="ch07_images.html#p083pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Always look for the &lt;b&gt;bright&lt;/b&gt; side of &lt;b&gt;life&lt;/b&gt;.</span></p>
<p class="noindent">A <em>greedy match</em> for the first subpattern would match the first <span class="EmpStrong">&lt;</span> with the last <span class="EmpStrong">&gt;</span>. A greedy match on the second subpattern would match the first <span class="EmpStrong">&lt;b&gt;</span> with the last <span class="EmpStrong">&lt;/b&gt;</span>. Both would be correct behavior, but unlikely what the programmer wanted.</p>
<p class="indent">For a more exhaustive presentation of regular expressions, see [Friedl,1997].</p>
<div class="heading">
<h4 id="ch07lev2sec4">7.3.3. Iterators</h4>
<p class="noindent">We can define a <span class="EmpStrong">regex_iterator</span> for iterating over a stream finding matches for a pattern. For example, we can output all whitespace-separated words in a <span class="EmpStrong">string</span>:</p>
</div>
<p class="codelink"><a id="p083pro02" href="ch07_images.html#p083pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string input = "aa as; asd ++e&#94;asdf asdfg";</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">regex pat {R"(\s+(\w+))"};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (sregex_iterator p(input.begin(),input.end(),pat); p!=sregex_iterator{}; ++p)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; (*p)[1] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This outputs:</p>
<p class="pre"><span class="EmpStrong">as</span><br/><span class="EmpStrong">asd</span><br/><span class="EmpStrong">asdfg</span></p>
<p class="noindent">Note that we are missing the first word, <span class="EmpStrong">aa</span>, because it has no preceding whitespace. If we simplify the pattern to <span class="EmpStrong">R"((\ew+))"</span>, we get</p>
<p class="pre"><span class="EmpStrong">aa</span><br/><span class="EmpStrong">as</span><br/><span class="EmpStrong">asd</span><br/><span class="EmpStrong">e</span><br/><span class="EmpStrong">asdf</span><br/><span class="EmpStrong">asdfg</span></p>
<p class="noindent">A <span class="EmpStrong">regex_iterator</span> is a bidirectional iterator, so we cannot directly iterate over an <span class="EmpStrong">istream</span>. Also, we cannot write through a <span class="EmpStrong">regex_iterator</span>, and the default <span class="EmpStrong">regex_iterator</span> (<span class="EmpStrong">regex_iterator{}</span>) is the only possible end-of-sequence.</p>
<div class="heading">
<h3 id="ch07lev1sec4"><a id="page_84"/>7.4. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapters 36-37 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Prefer <span class="EmpStrong">string</span> operations to C-style string functions; &#167;<a href="ch07.html#ch07lev1sec1">7.1</a>.</p>
<p class="ref">[3] Use <span class="EmpStrong">string</span> to declare variables and members rather than as a base class; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref">[4] Return <span class="EmpStrong">string</span>s by value (rely on move semantics); &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>, &#167;<a href="ch07.html#ch07lev2sec1">7.2.1</a>.</p>
<p class="ref">[5] Directly or indirectly, use <span class="EmpStrong">substr()</span> to read substrings and <span class="EmpStrong">replace()</span> to write substrings; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref">[6] A <span class="EmpStrong">string</span> can grow and shrink, as needed; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref">[7] Use <span class="EmpStrong">at()</span> rather than iterators or <span class="EmpStrong">[ ]</span> when you want range checking; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref">[8] Use iterators and <span class="EmpStrong">[ ]</span> rather than <span class="EmpStrong">at()</span> when you want to optimize speed; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref">[9] <span class="EmpStrong">string</span> input doesn&#8217;t overflow; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>, &#167;<a href="ch08.html#ch08lev1sec3">8.3</a>.</p>
<p class="ref1">[10] Use <span class="EmpStrong">c_str()</span> to produce a C-style string representation of a <span class="EmpStrong">string</span> (only) when you have to; &#167;<a href="ch07.html#ch07lev1sec2">7.2</a>.</p>
<p class="ref1">[11] Use a <span class="EmpStrong">string_stream</span> or a generic value extraction function (such as <span class="EmpStrong">to&lt;X&gt;</span>) for numeric conversion of strings; &#167;<a href="ch08.html#ch08lev1sec8">8.8</a>.</p>
<p class="ref1">[12] A <span class="EmpStrong">basic_string</span> can be used to make strings of characters on any type; &#167;<a href="ch07.html#ch07lev2sec1">7.2.1</a>.</p>
<p class="ref1">[13] Use <span class="EmpStrong">regex</span> for most conventional uses of regular expressions; &#167;<a href="ch07.html#ch07lev1sec3">7.3</a>.</p>
<p class="ref1">[14] Prefer raw string literals for expressing all but the simplest patterns; &#167;<a href="ch07.html#ch07lev1sec3">7.3</a>.</p>
<p class="ref1">[15] Use <span class="EmpStrong">regex_match()</span> to match a complete input; &#167;<a href="ch07.html#ch07lev1sec3">7.3</a>, &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[16] Use <span class="EmpStrong">regex_search()</span> to search for a pattern in an input stream; &#167;<a href="ch07.html#ch07lev2sec2">7.3.1</a>.</p>
<p class="ref1">[17] The regular expression notation can be adjusted to match various standards; &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[18] The default regular expression notation is that of ECMAScript; &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[19] Be restrained; regular expressions can easily become a write-only language; &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[20] Note that <span class="EmpStrong">\i</span> allows you to express a subpattern in terms of a previous subpattern; &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[21] Use <span class="EmpStrong">?</span> to make patterns &#8220;lazy&#8221;; &#167;<a href="ch07.html#ch07lev2sec3">7.3.2</a>.</p>
<p class="ref1">[22] Use <span class="EmpStrong">regex_iterator</span>s for iterating over a stream looking for a pattern; &#167;<a href="ch07.html#ch07lev2sec4">7.3.3</a></p>
</body>
</html>