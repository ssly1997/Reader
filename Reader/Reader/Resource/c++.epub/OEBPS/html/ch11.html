<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>11. Utilities</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch11"><a id="page_117"/><span class="pd_blue">11.</span> Utilities</h2>
<p class="blockquote"><em>The time you enjoy wasting is not wasted time.</em></p>
<p class="attribution"><em>&#8211; Bertrand Russell</em></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec2">Resource Management</a></p>
<p class="indenthangingBP"><a href="ch11.html#ch11lev2sec1"><span class="EmpStrong">unique_ptr</span> and <span class="EmpStrong">shared_ptr</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec3">Specialized Containers</a></p>
<p class="indenthangingBP"><a href="ch11.html#ch11lev2sec2"><span class="EmpStrong">array</span></a>; <a href="ch11.html#ch11lev2sec3"><span class="EmpStrong">bitset</span></a>; <a href="ch11.html#ch11lev2sec4"><span class="EmpStrong">pair</span> and <span class="EmpStrong">tuple</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec4">Time</a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec5">Function Adaptors</a></p>
<p class="indenthangingBP"><a href="ch11.html#ch11lev2sec5"><span class="EmpStrong">bind()</span></a>; <a href="ch11.html#ch11lev2sec6"><span class="EmpStrong">mem_fn()</span></a>; <a href="ch11.html#ch11lev2sec7"><span class="EmpStrong">function</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec6">Type Functions</a></p>
<p class="indenthangingBP"><a href="ch11.html#ch11lev2sec8"><span class="EmpStrong">iterator_traits</span></a>; <a href="ch11.html#ch11lev2sec9">Type Predicates</a></p>
<p class="indenthangingB">&#8226; <a href="ch11.html#ch11lev1sec7">Advice</a></p>
<div class="heading">
<h3 id="ch11lev1sec1">11.1. Introduction</h3>
<p class="noindent">Not all standard-library components come as part of obviously labeled facilities, such as &#8220;containers&#8221; or &#8220;I/O.&#8221; This section gives a few examples of small, widely useful components. The point here is that a function or a type need not be complicated or closely tied to a mass of other functions and types to be useful. Such library components mostly act as building blocks for more powerful library facilities, including other components of the standard library.</p>
</div>
<div class="heading">
<h3 id="ch11lev1sec2">11.2. Resource Management</h3>
<p class="noindent">One of the key tasks of any nontrivial program is to manage resources. A resource is something that must be acquired and later (explicitly or implicitly) released. Examples are memory, locks, <a id="page_118"/>sockets, thread handles, and file handles. For a long-running program, failing to release a resource in a timely manner (&#8220;a leak&#8221;) can cause serious performance degradation and possibly even a miserable crash. Even for short programs, a leak can become an embarrassment, say by a resource shortage increasing the run time by orders of magnitude.</p>
</div>
<p class="indent">The standard library components are designed not to leak resources. To do this, they rely on the basic language support for resource management using constructor/destructor pairs to ensure that a resource doesn&#8217;t outlive an object responsible for it. The use of a constructor/destructor pair in <span class="EmpStrong">Vector</span> to manage the lifetime of its elements is an example (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>) and all standard-library containers are implemented in similar ways. Importantly, this approach interacts correctly with error handling using exceptions. For example, the technique is used for the standard-library lock classes:</p>
<p class="codelink"><a id="p118pro01" href="ch11_images.html#p118pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">mutex m; //</span> <span class="EmpItalic">used to protect access to shared data</span><br/><span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">void f()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck {m}; //</span> <span class="EmpItalic">acquire the mutex m</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... manipulate shared data ...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A <span class="EmpStrong">thread</span> will not proceed until <span class="EmpStrong">lck</span>&#8217;s constructor has acquired its <span class="EmpStrong">mutex</span>, <span class="EmpStrong">m</span> (&#167;<a href="ch13.html#ch13lev1sec5">13.5</a>). The corresponding destructor releases the resource. So, in this example, <span class="EmpStrong">unique_lock</span>&#8217;s destructor releases the <span class="EmpStrong">mutex</span> when the thread of control leaves <span class="EmpStrong">f()</span> (through a <span class="EmpStrong">return</span>, by &#8220;falling off the end of the function,&#8221; or through an exception throw).</p>
<p class="indent">This is an application of the &#8220;Resource Acquisition Is Initialization&#8221; technique (RAII; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>). RAII is fundamental to the idiomatic handling of resources in C++. Containers (such as <span class="EmpStrong">vector</span> and <span class="EmpStrong">map</span>), <span class="EmpStrong">string</span>, and <span class="EmpStrong">iostream</span> manage their resources (such as file handles and buffers) similarly.</p>
<div class="heading">
<h4 id="ch11lev2sec1">11.2.1. <span class="EmpStrong">unique_ptr</span> and <span class="EmpStrong">shared_ptr</span></h4>
<p class="noindent">The examples so far take care of objects defined in a scope, releasing the resources they acquire at the exit from the scope, but what about objects allocated on the free store? In <span class="EmpStrong">&lt;memory&gt;</span>, the standard library provides two &#8220;smart pointers&#8221; to help manage objects on the free store:</p>
</div>
<p class="indenthangingN">[1] <span class="EmpStrong">unique_ptr</span> to represent unique ownership</p>
<p class="indenthangingN">[2] <span class="EmpStrong">shared_ptr</span> to represent shared ownership</p>
<p class="noindent">The most basic use of these &#8220;smart pointers&#8221; is to prevent memory leaks caused by careless programming. For example:</p>
<p class="codelink"><a id="p118pro02" href="ch11_images.html#p118pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(int i, int j)</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">X* vs. unique_ptr&lt;X&gt;</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X* p = new X;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">allocate a new X</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_ptr&lt;X&gt; sp {new X};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">allocate a new X and give its pointer to unique_ptr</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (i&lt;99) throw Z{};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">may throw an exception</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (j&lt;77) return;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">may return "early"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p-&gt;do_something();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">may throw an exception</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sp-&gt;do_something();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">may throw an exception</span><br/><a id="page_119"/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">delete p;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destroy *p</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, we &#8220;forgot&#8221; to delete <span class="EmpStrong">p</span> if <span class="EmpStrong">i&lt;99</span> or if <span class="EmpStrong">j&lt;77</span>. On the other hand, <span class="EmpStrong">unique_ptr</span> ensures that its object is properly destroyed whichever way we exit <span class="EmpStrong">f()</span> (by throwing an exception, by executing <span class="EmpStrong">return</span>, or by &#8220;falling off the end&#8221;). Ironically, we could have solved the problem simply by <em>not</em> using a pointer and <em>not</em> using <span class="EmpStrong">new</span>:</p>
<p class="codelink"><a id="p119pro01" href="ch11_images.html#p119pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(int i, int j)</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use a local variable</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X x;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Unfortunately, overuse of <span class="EmpStrong">new</span> (and of pointers and references) seems to be an increasing problem.</p>
<p class="indent">However, when you really need the semantics of pointers, <span class="EmpStrong">unique_ptr</span> is a very lightweight mechanism with no space or time overhead compared to correct use of a built-in pointer. Its further uses include passing free-store allocated objects in and out of functions:</p>
<p class="codelink"><a id="p119pro02" href="ch11_images.html#p119pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">unique_ptr&lt;X&gt; make_X(int i)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">make an X and immediately give it to a unique_ptr</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... check i, etc. ...</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return unique_ptr&lt;X&gt;{new X{i}};</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A <span class="EmpStrong">unique_ptr</span> is a handle to an individual object (or an array) in much the same way that a <span class="EmpStrong">vector</span> is a handle to a sequence of objects. Both control the lifetime of other objects (using RAII) and both rely on move semantics to make <span class="EmpStrong">return</span> simple and efficient.</p>
<p class="indent">The <span class="EmpStrong">shared_ptr</span> is similar to <span class="EmpStrong">unique_ptr</span> except that <span class="EmpStrong">shared_ptr</span>s are copied rather than moved. The <span class="EmpStrong">shared_ptr</span>s for an object share ownership of an object and that object is destroyed when the last of its <span class="EmpStrong">shared_ptr</span>s is destroyed. For example:</p>
<p class="codelink"><a id="p119pro03" href="ch11_images.html#p119pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(shared_ptr&lt;fstream&gt;);</span><br/><span class="EmpStrong">void g(shared_ptr&lt;fstream&gt;);</span><br/><br/><span class="EmpStrong">void user(const string&#38; name, ios_base::openmode mode)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">shared_ptr&lt;fstream&gt; fp {new fstream(name,mode)};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (!*fp)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">make sure the file was properly opened</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw No_file{};</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(fp);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">g(fp);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Now, the file opened by <span class="EmpStrong">fp</span>&#8217;s constructor will be closed by the last function to (explicitly or implicitly) destroy a copy of <span class="EmpStrong">fp</span>. Note that <span class="EmpStrong">f()</span> or <span class="EmpStrong">g()</span> may spawn a task holding a copy of <span class="EmpStrong">fp</span> or in some other way store a copy that outlives <span class="EmpStrong">user()</span>. Thus, <span class="EmpStrong">shared_ptr</span> provides a form of garbage collection <a id="page_120"/>that respects the destructor-based resource management of the memory-managed objects. This is neither cost free nor exorbitantly expensive, but it does make the lifetime of the shared object hard to predict. Use <span class="EmpStrong">shared_ptr</span> only if you actually need shared ownership.</p>
<p class="indent">Creating an object on the free store and then passing a pointer to it to a smart pointer is logically a bit odd and can be verbose. To compensate, the standard library (in <span class="EmpStrong">&lt;memory&gt;</span>) provides a function <span class="EmpStrong">make_shared()</span>. For example:</p>
<p class="codelink"><a id="p120pro01" href="ch11_images.html#p120pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">struct S {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string s;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double d;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">shared_ptr&lt;S&gt; p1 {new S {1,"Ankh Morpork",4.65}};</span><br/><br/><span class="EmpStrong">auto p2 = make_shared&lt;S&gt;(2,"Oz",7.62);</span></p>
<p class="noindent">Now, <span class="EmpStrong">p2</span> is a <span class="EmpStrong">shared_ptr&lt;S&gt;</span> pointing to an object of type <span class="EmpStrong">S</span> allocated on the free store, containing <span class="EmpStrong">{1,string{"Ankh Morpork"},4.65}</span>.</p>
<p class="indent">Currently, there is no standard-library <span class="EmpStrong">make_unique()</span> similar to <span class="EmpStrong">make_shared()</span> and <span class="EmpStrong">make_pair()</span> (&#167;<a href="ch11.html#ch11lev2sec4">11.3.3</a>). However, it is easily defined:</p>
<p class="codelink"><a id="p120pro02" href="ch11_images.html#p120pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T, typename... Args&gt;</span><br/><span class="EmpStrong">unique_ptr&lt;T&gt; make_unique(Args&#38;&#38;... args)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return std::unique_ptr&lt;T&gt;{new T{std::forward&lt;Args&gt;(args)...}};</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">No, I don&#8217;t claim that this definition is trivial to understand, but it is efficient and quite general. The elipses, <span class="EmpStrong">...</span>, indicate the use of a variadic template (&#167;<a href="ch05.html#ch05lev1sec6">5.6</a>). We can now write:</p>
<p class="codelink"><a id="p120pro03" href="ch11_images.html#p120pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">auto p2 = make_unique&lt;S&gt;(3,"Atlantis",11.3);</span></p>
<p class="indent">Given <span class="EmpStrong">unique_ptr</span> and <span class="EmpStrong">shared_ptr</span>, we can implement a complete &#8220;no naked <span class="EmpStrong">new</span> &#8221; policy (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>) for many programs. However, these &#8220;smart pointers&#8221; are still conceptually pointers and therefore only my second choice for resource management &#8211; after containers and other types that manage their resources at a higher conceptual level. In particular, <span class="EmpStrong">shared_ptr</span>s do not in themselves provide any rules for which of their owners can read and/or write the shared object. Data races (&#167;<a href="ch13.html#ch13lev1sec7">13.7</a>) and other forms of confusion are not addressed simply by eliminating the resource management issues.</p>
<p class="indent">Where do we use &#8220;smart pointers&#8221; (such as <span class="EmpStrong">unique_ptr</span>) rather than resource handles with operations designed specifically for the resource (such as <span class="EmpStrong">vector</span> or <span class="EmpStrong">thread</span>)? Unsurprisingly, the answer is &#8220;when we need pointer semantics.&#8221;</p>
<p class="indenthangingB">&#8226; When we share an object, we need pointers (or references) to refer to the shared object, so a <span class="EmpStrong">shared_ptr</span> becomes the obvious choice (unless there is an obvious single owner).</p>
<p class="indenthangingB">&#8226; When we refer to a polymorphic object, we need a pointer (or a reference) because we don&#8217;t know the exact type of the object referred to (or even its size), so a <span class="EmpStrong">unique_ptr</span> becomes the obvious choice.</p>
<p class="indenthangingB"><a id="page_121"/>&#8226; A shared polymorphic object typically requires <span class="EmpStrong">shared_ptr</span>s.</p>
<p class="noindent">We do <em>not</em> need to use a pointer to return a collection of objects from a function; a container that is a resource handle will do that simply and efficiently (&#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>).</p>
<div class="heading">
<h3 id="ch11lev1sec3">11.3. Specialized Containers</h3>
<p class="noindent">The standard library provides several containers that don&#8217;t fit perfectly into the STL framework (<a href="ch09.html#ch09">Chapter 9</a>, <a href="ch10.html#ch10">Chapter 10</a>). Examples are built-in arrays, <span class="EmpStrong">array</span>, and <span class="EmpStrong">string</span>. I sometimes refer to those as &#8220;almost containers,&#8221; but that is not quite fair: they hold elements, so they are containers, but each has restrictions or added facilities that make them awkward in the context of the STL. Describing them separately also simplifies the description of the STL.</p>
</div>
<div class="image"><img src="graphics/121tab01.jpg" alt="Image"/></div>
<p class="noindent">Why does the standard library provide so many containers? They serve common but different (often overlapping) needs. If the standard library didn&#8217;t provide them, many people would have to design and implement their own. For example:</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">pair</span> and <span class="EmpStrong">tuple</span> are heterogeneous; all other containers are homogeneous (all elements are of the same type).</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">array</span>, <span class="EmpStrong">vector</span>, and <span class="EmpStrong">tuple</span> elements are contiguously allocated; <span class="EmpStrong">forward_list</span> and <span class="EmpStrong">map</span> are linked structures.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">bitset</span> and <span class="EmpStrong">vector&lt;bool&gt;</span> hold bits and access them through proxy objects; all other standard-library containers can hold a variety of types and access elements directly.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">basic_string</span> requires its elements to be some form of character and to provide string manipulation, such as concatenation and locale-sensitive operations</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">valarray</span> requires its elements to be numbers and to provide numerical operations.</p>
<p class="noindent">All of these containers can be seen as providing specialized services needed by large communities of programmers. No single container could serve all of these needs because some needs are contradictory, for example, &#8220;ability to grow&#8221; vs. &#8220;guaranteed to be allocated in a fixed location,&#8221; and &#8220;elements do not move when elements are added&#8221; vs. &#8220;contiguously allocated.&#8221; Furthermore, a very general container would imply overhead deemed unacceptable for individual containers.</p>
<div class="heading">
<h4 id="ch11lev2sec2"><a id="page_122"/>11.3.1. <span class="EmpStrong">array</span></h4>
<p class="noindent">An <span class="EmpStrong">array</span>, defined in <span class="EmpStrong">&lt;array&gt;</span>, is a fixed-size sequence of elements of a given type where the number of elements is specified at compile time. Thus, an <span class="EmpStrong">array</span> can be allocated with its elements on the stack, in an object, or in static storage. The elements are allocated in the scope where the <span class="EmpStrong">array</span> is defined. An <span class="EmpStrong">array</span> is best understood as a built-in array with its size firmly attached, without implicit, potentially surprising conversions to pointer types, and with a few convenience functions provided. There is no overhead (time or space) involved in using an <span class="EmpStrong">array</span> compared to using a built-in array. An <span class="EmpStrong">array</span> does <em>not</em> follow the &#8220;handle to elements&#8221; model of STL containers. Instead, an <span class="EmpStrong">array</span> directly contains its elements.</p>
</div>
<p class="indent">An <span class="EmpStrong">array</span> can be initialized by an initializer list:</p>
<p class="pre"><span class="EmpStrong">array&lt;int,3&gt; a1 = {1,2,3};</span></p>
<p class="noindent">The number of elements in the initializer must be equal to or less than the number of elements specified for the <span class="EmpStrong">array</span>.</p>
<p class="indent">The element count is not optional:</p>
<p class="codelink"><a id="p122pro01" href="ch11_images.html#p122pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">array&lt;int&gt; ax = {1,2,3};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error size not specified</span></p>
<p class="noindent">The element count must be a constant expression:</p>
<p class="codelink"><a id="p122pro02" href="ch11_images.html#p122pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(int n)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">array&lt;string,n&gt; aa = {"John's", "Queens' "};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: size not a constant expression</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">If you need the element count to be a variable, use <span class="EmpStrong">vector</span>.</p>
<p class="indent">When necessary, an <span class="EmpStrong">array</span> can be explicitly passed to a C-style function that expects a pointer.</p>
<p class="noindent">For example:</p>
<p class="codelink"><a id="p122pro03" href="ch11_images.html#p122pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(int* p, int sz);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">C-style interface</span><br/><br/><span class="EmpStrong">void g()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">array&lt;int,10&gt; a;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(a,a.size());</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: no conversion</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(&#38;a[0],a.size());</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">C-style use</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(a.data(),a.size());</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">C-style use</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto p = find(a.begin(),a.end(),777);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">C++/STL-style use</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Why would we use an <span class="EmpStrong">array</span> when <span class="EmpStrong">vector</span> is so much more flexible? Because an <span class="EmpStrong">array</span> is less flexible, it is simpler. Occasionally, there is a significant performance advantage to be had by directly accessing elements allocated on the stack rather than allocating elements on the free store, accessing them indirectly through the <span class="EmpStrong">vector</span> (a handle), and then deallocating them. On the other hand, the stack is a limited resource (especially on some embedded systems), and stack overflow is nasty.</p>
<p class="indent"><a id="page_123"/>Why would we use an <span class="EmpStrong">array</span> when we could use a built-in array? An <span class="EmpStrong">array</span> knows its size, so it is easy to use with standard-library algorithms, and it can be copied (using <span class="EmpStrong">=</span> or initialization). However, my main reason to prefer <span class="EmpStrong">array</span> is that it saves me from surprising nasty conversions to pointers. Consider:</p>
<p class="codelink"><a id="p123pro01" href="ch11_images.html#p123pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void h()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Circle a1[10];</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">array&lt;Circle,10&gt; a2;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape* p1 = a1;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">OK: disaster waiting to happen</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Shape* p2 = a2;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: no conversion of array&lt;Circle,10&gt; to Shape*</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p1[3].draw();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">disaster</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The &#8220;disaster&#8221; comment assumes that <span class="EmpStrong">sizeof(Shape)&lt;sizeof(Circle)</span>, so that subscripting a <span class="EmpStrong">Circle[]</span> through a <span class="EmpStrong">Shape</span> <code>*</code> gives a wrong offset. All standard containers provide this advantage over built-in arrays.</p>
<div class="heading">
<h4 id="ch11lev2sec3">11.3.2. <span class="EmpStrong">bitset</span></h4>
<p class="noindent">Aspects of a system, such as the state of an input stream, are often represented as a set of flags indicating binary conditions such as good/bad, true/false, and on/off. C++ supports the notion of small sets of flags efficiently through bitwise operations on integers (&#167;<a href="ch01.html#ch01lev1sec5">1.5</a>). Class <span class="EmpStrong">bitset&lt;N&gt;</span> generalizes this notion and offers greater convenience by providing operations on a sequence of <span class="EmpStrong">N</span> bits [<span class="EmpStrong">0</span>:<span class="EmpStrong">N</span>), where <span class="EmpStrong">N</span> is known at compile time. For sets of bits that don&#8217;t fit into a <span class="EmpStrong">long long int</span>, using a <span class="EmpStrong">bitset</span> is much more convenient than using integers directly. For smaller sets, <span class="EmpStrong">bitset</span> is usually optimized. If you want to name the bits, rather than numbering them, you can use a <span class="EmpStrong">set</span> (&#167;<a href="ch09.html#ch09lev1sec4">9.4</a>) or an enumeration (&#167;<a href="ch02.html#ch02lev1sec5">2.5</a>).</p>
</div>
<p class="indent">A <span class="EmpStrong">bitset</span> can be initialized with an integer or a string:</p>
<p class="pre"><span class="EmpStrong">bitset&lt;9&gt; bs1 {"110001111"};</span><br/><span class="EmpStrong">bitset&lt;9&gt; bs2 {399};</span></p>
<p class="noindent">The usual bitwise operations (&#167;<a href="ch01.html#ch01lev1sec5">1.5</a>) can be applied, as can left- and right-shift operations (<span class="EmpStrong">&lt;&lt;</span> and <span class="EmpStrong">&gt;&gt;</span>):</p>
<p class="codelink"><a id="p123pro02" href="ch11_images.html#p123pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bitset&lt;9&gt; bs3 = ~bs1;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">complement: bs3=="001110000"</span><br/><span class="EmpStrong">bitset&lt;9&gt; bs4 = bs1&#38;bs3;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">all zeros</span><br/><span class="EmpStrong">bitset&lt;9&gt; bs5 = bs1&lt;&lt;2;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">shift left: bs5 = "111000000"</span></p>
<p class="noindent">The shift operators (here, <span class="EmpStrong">&lt;&lt;</span>) &#8220;shifts in&#8221; zeros.</p>
<p class="indent">The operations <span class="EmpStrong">to_ullong()</span> and <span class="EmpStrong">to_string()</span> provide the inverse operations to the constructors. For example, we could write out the binary representation of an <span class="EmpStrong">int</span>:</p>
<p class="codelink"><a id="p123pro03" href="ch11_images.html#p123pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void binary(int i)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bitset&lt;8*sizeof(int)&gt; b = i;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assume 8-bit byte (see also &#167;12.7)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; b.to_string() &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">write out the bits of i</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_124"/>This prints the bits represented as <span class="EmpStrong">1</span>s and <span class="EmpStrong">0</span>s from left to right, with the most significant bit leftmost, so that argument <span class="EmpStrong">123</span> would give the output</p>
<p class="codelink"><a id="p124pro01" href="ch11_images.html#p124pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">00000000000000000000000001111011</span></p>
<p class="noindent">For this example, it is simpler to directly use the <span class="EmpStrong">bitset</span> output operator:</p>
<p class="codelink"><a id="p124pro02" href="ch11_images.html#p124pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void binary2(int i)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bitset&lt;8*sizeof(int)&gt; b = i;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assume 8-bit byte (see also &#167;12.7)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; b &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">write out the bits of i</span><br/><span class="EmpStrong">}</span></p>
<div class="heading">
<h4 id="ch11lev2sec4">11.3.3. <span class="EmpStrong">pair</span> and <span class="EmpStrong">tuple</span></h4>
<p class="noindent">Often, we need some data that is just data; that is, a collection of values, rather than an object of a class with a well-defined semantics and an invariant for its value (&#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>). In such cases, we could define a simple <span class="EmpStrong">struct</span> with an appropriate set of appropriately named members. Alternatively, we could let the standard library write the definition for us. For example, the standard-library algorithm <span class="EmpStrong">equal_range</span> returns a <span class="EmpStrong">pair</span> of iterators specifying a subsequence meeting a predicate:</p>
</div>
<p class="codelink"><a id="p124pro03" href="ch11_images.html#p124pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Forward_iterator, typename T, typename Compare&gt;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">pair&lt;Forward_iterator,Forward_iterator&gt;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">equal_range(Forward_iterator first, Forward_iterator last, const T&#38; val, Compare cmp);</span></p>
<p class="noindent">Given a sorted sequence [<span class="EmpStrong">first</span>:<span class="EmpStrong">last</span>), <span class="EmpStrong">equal_range()</span> will return the <span class="EmpStrong">pair</span> representing the subsequence that matches the predicate <span class="EmpStrong">cmp</span>. We can use that to search in a sorted sequence of <span class="EmpStrong">Record</span>s:</p>
<p class="codelink"><a id="p124pro04" href="ch11_images.html#p124pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">auto rec_eq = [](const Record&#38; r1, const Record&#38; r2) { return r1.name&lt;r2.name;};</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">compare names</span><br/><br/><span class="EmpStrong">void f(const vector&lt;Record&gt;&#38; v)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assume that v is sorted on its "name" field</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto er = equal_range(v.begin(),v.end(),Record{"Reg"},rec_eq);</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p = er.first; p!=er.second; ++p)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">print all equal records</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; *p;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assume that &lt;&lt; is defined for Record</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The first member of a <span class="EmpStrong">pair</span> is called <span class="EmpStrong">first</span> and the second member is called <span class="EmpStrong">second</span>. This naming is not particularly creative and may look a bit odd at first, but such consistent naming is a boon when we want to write generic code.</p>
<p class="indent">The standard-library <span class="EmpStrong">pair</span> (from <span class="EmpStrong">&lt;utility&gt;</span>) is quite frequently used in the standard library and elsewhere. A <span class="EmpStrong">pair</span> provides operators, such as <span class="EmpStrong">=</span>, <span class="EmpStrong">==</span>, and <span class="EmpStrong">&lt;</span>, if its elements do. The <span class="EmpStrong">make_pair()</span> function makes it easy to create a <span class="EmpStrong">pair</span> without explicitly mentioning its type. For example:</p>
<p class="codelink"><a id="p124pro05" href="ch11_images.html#p124pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(vector&lt;string&gt;&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto pp = make_pair(v.begin(),2);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pp is a pair&lt;vector&lt;string&gt;::iterator,int&gt;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_125"/>If you need more than two elements (or less), you can use <span class="EmpStrong">tuple</span> (from <span class="EmpStrong">&lt;utility&gt;</span>). A <span class="EmpStrong">tuple</span> is a heterogeneous sequence of elements; for example:</p>
<p class="codelink"><a id="p125pro01" href="ch11_images.html#p125pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">tuple&lt;string,int,double&gt; t2{"Sild",123, 3.14};</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the type is explicitly specified</span><br/><br/><span class="EmpStrong">auto t = make_tuple(string{"Herring"},10, 1.23);</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the type is deduced to tuple&lt;string,int,double&gt;</span><br/><br/><span class="EmpStrong">string s = get&lt;0&gt;(t);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get first element of tuple: "Herring"</span><br/><span class="EmpStrong">int x = get&lt;1&gt;(t);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">10</span><br/><span class="EmpStrong">double d = get&lt;2&gt;(t);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">1.23</span></p>
<p class="noindent">The elements of a <span class="EmpStrong">tuple</span> are numbered (starting with zero), rather than named the way elements of <span class="EmpStrong">pair</span>s are (<span class="EmpStrong">first</span> and <span class="EmpStrong">second</span>). To get compile-time selection of elements, I must unfortunately use the ugly <span class="EmpStrong">get&lt;1&gt;(t)</span>, rather than <span class="EmpStrong">get(t,1)</span> or <span class="EmpStrong">t[1]</span>.</p>
<p class="indent">Like <span class="EmpStrong">pair</span>s, <span class="EmpStrong">tuple</span>s can be assigned and compared if their elements can be.</p>
<p class="indent">A <span class="EmpStrong">pair</span> is common in interfaces because often we want to return more than one value, such as a result and an indicator of the quality of that result. It is less common to need three or more parts to a result, so <span class="EmpStrong">tuple</span>s are more often found in the implementations of generic algorithms.</p>
<div class="heading">
<h3 id="ch11lev1sec4">11.4. Time</h3>
<p class="noindent">The standard library provides facilities for dealing with time. For example, here is the basic way of timing something:</p>
</div>
<p class="codelink"><a id="p125pro02" href="ch11_images.html#p125pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">using namespace std::chrono;</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">see &#167;3.3</span><br/><br/><span class="EmpStrong">auto t0 = high_resolution_clock::now();</span><br/><span class="EmpStrong">do_work();</span><br/><span class="EmpStrong">auto t1 = high_resolution_clock::now();</span><br/><span class="EmpStrong">cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1-t0).count() &lt;&lt; "msec\n";</span></p>
<p class="noindent">The clock returns a <span class="EmpStrong">time_point</span> (a point in time). Subtracting two <span class="EmpStrong">time_point</span>s gives a <span class="EmpStrong">duration</span> (a period of time). Various clocks give their results in various units of time (the clock I used measures <span class="EmpStrong">nanoseconds</span>), so it is usually a good idea to convert a <span class="EmpStrong">duration</span> into a known unit. That&#8217;s what <span class="EmpStrong">duration_cast</span> does.</p>
<p class="indent">The standard-library facilities for dealing with time are found in the subnamespace <span class="EmpStrong">std::chrono</span> in <span class="EmpStrong">&lt;chrono&gt;</span>.</p>
<p class="indent">Don&#8217;t make statements about &#8220;efficiency&#8221; of code without first doing time measurements. Guesses about performance are most unreliable.</p>
<div class="heading">
<h3 id="ch11lev1sec5">11.5. Function Adaptors</h3>
<p class="noindent">A function adaptor takes a function as argument and returns a function object that can be used to invoke the original function. The standard library provides <span class="EmpStrong">bind()</span> and <span class="EmpStrong">mem_fn()</span> adaptors to do argument binding, also called <em>Currying</em> or <em>partial evaluation</em>. Binders were heavily used in the past, but most uses seem to be more easily expressed using lambdas (&#167;<a href="ch05.html#ch05lev1sec5">5.5</a>).</p>
</div>
<div class="heading">
<h4 id="ch11lev2sec5"><a id="page_126"/>11.5.1. <span class="EmpStrong">bind()</span></h4>
<p class="noindent">Given a function and a set of arguments, <span class="EmpStrong">bind()</span> produces a function object that can be called with &#8220;the remaining&#8221; arguments, if any, of the function. For example:</p>
</div>
<p class="pre"><span class="EmpStrong">double cube(double);</span><br/><br/><span class="EmpStrong">auto cube2 = bind(cube,2);</span></p>
<p class="noindent">A call <span class="EmpStrong">cube2()</span> will invoke <span class="EmpStrong">cube</span> with the argument <span class="EmpStrong">2</span>, that is, <span class="EmpStrong">cube(2)</span>. We don&#8217;t have to bind every argument of a function. For example:</p>
<p class="codelink"><a id="p126pro01" href="ch11_images.html#p126pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">using namespace placeholders;</span><br/><br/><span class="EmpStrong">void f(int,const string&#38;);</span><br/><span class="EmpStrong">auto g = bind(f,2,_1);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">bind f()'s first argument to 2</span><br/><span class="EmpStrong">f(2,"hello");</span><br/><span class="EmpStrong">g("hello");</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">also calls f(2,"hello");</span></p>
<p class="noindent">The curious <span class="EmpStrong">_1</span> argument to the binder is a placeholder telling <span class="EmpStrong">bind()</span> where arguments to the resulting function object should go. In this case, <span class="EmpStrong">g()</span>&#8217;s (first) argument is used as <span class="EmpStrong">f()</span>&#8217;s second argument.</p>
<p class="indent">The placeholders are found in the (sub)namespace <span class="EmpStrong">std::placeholders</span> that is part of <span class="EmpStrong">&lt;functional&gt;</span>.</p>
<p class="indent">To bind arguments for an overloaded function, we have to explicitly state which version of the function we want to bind:</p>
<p class="codelink"><a id="p126pro02" href="ch11_images.html#p126pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int pow(int,int);</span><br/><span class="EmpStrong">double pow(double,double);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pow() is overloaded</span><br/><br/><span class="EmpStrong">auto pow2 = bind(pow,_1,2);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: which pow()?</span><br/><span class="EmpStrong">auto pow2 = bind((double(*)(double,double))pow,_1,2);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">OK (but ugly)</span></p>
<p class="noindent">I assigned the result of <span class="EmpStrong">bind()</span> to a variable declared using <span class="EmpStrong">auto</span>. This saves me the bother of specifying the return type of a call of <span class="EmpStrong">bind()</span>. That can be useful because the return type of <span class="EmpStrong">bind()</span> varies with the type of function to be called and the argument values stored. In particular, the returned function object is larger when it has to hold values of bound parameters. When we want to be specific about the types of the arguments required and the type of result returned, we can use a <span class="EmpStrong">function</span> (&#167;<a href="ch11.html#ch11lev2sec7">11.5.3</a>).</p>
<div class="heading">
<h4 id="ch11lev2sec6">11.5.2. <span class="EmpStrong">mem_fn()</span></h4>
<p class="noindent">The function adaptor <span class="EmpStrong">mem_fn(mf)</span> produces a function object that can be called as a nonmember function. For example:</p>
</div>
<p class="codelink"><a id="p126pro03" href="ch11_images.html#p126pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void user(Shape* p)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">p-&gt;draw();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto draw = mem_fn(&#38;Shape::draw);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">draw(p);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The major use of <span class="EmpStrong">mem_fn()</span> is when an algorithm requires an operation to be called as a nonmember function. For example:</p>
<p class="codelink"><a id="page_127"/><a id="p127pro01" href="ch11_images.html#p127pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void draw_all(vector&lt;Shape*&gt;&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for_each(v.begin(),v.end(),mem_fn(&#38;Shape::draw));</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Thus, <span class="EmpStrong">mem_fn()</span> can be seen as a mapping from the object-oriented calling style to the functional one.</p>
<p class="indent">Often, lambdas provide a simple and general alternative to binders. For example:</p>
<p class="codelink"><a id="p127pro02" href="ch11_images.html#p127pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void draw_all(vector&lt;Shape*&gt;&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for_each(v.begin(),v.end(),[](Shape* p) { p-&gt;draw(); });</span><br/><span class="EmpStrong">}</span></p>
<div class="heading">
<h4 id="ch11lev2sec7">11.5.3. <span class="EmpStrong">function</span></h4>
<p class="noindent">A <span class="EmpStrong">bind()</span> can be used directly, and it can be used to initialize an <span class="EmpStrong">auto</span> variable. In that, <span class="EmpStrong">bind()</span> resembles a lambda.</p>
</div>
<p class="indent">If we want to assign the result of <span class="EmpStrong">bind()</span> to a variable with a specific type, we can use the standard-library type <span class="EmpStrong">function</span>. A <span class="EmpStrong">function</span> is specified with a specific return type and a specific argument type. For example:</p>
<p class="codelink"><a id="p127pro03" href="ch11_images.html#p127pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int f1(double);</span><br/><span class="EmpStrong">function&lt;int(double)&gt; fct {f1}; //</span> <span class="EmpItalic">initialize to f1</span><br/><span class="EmpStrong">int f2(int);</span><br/><br/><span class="EmpStrong">void user()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">fct = [](double d) { return round(d); };</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assign lambda to fct</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">fct = f1;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assign function to fct</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">fct = f2;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: incorrect argument type</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The standard-library <span class="EmpStrong">function</span> is a type that can hold any object you can invoke using the call operator <span class="EmpStrong">()</span>. That is, an object of type <span class="EmpStrong">function</span> is a function object (&#167;<a href="ch05.html#ch05lev1sec5">5.5</a>). For example:</p>
<p class="codelink"><a id="p127pro04" href="ch11_images.html#p127pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int round(double x) { return static_cast&lt;int&gt;(floor(x+0.5)); }</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">conventional 4/5 rounding</span><br/><br/><span class="EmpStrong">function&lt;int(double)&gt; f;</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">f can hold anything that can be called with a double and return an int</span><br/><br/><span class="EmpStrong">enum class Round_style { truncate, round };</span><br/><br/><span class="EmpStrong">struct Round {</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">function object carrying a state</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Round_style s;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Round(Round_style ss) :s(ss) { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int operator()(double x) const { return static_cast&lt;int&gt;((s==Round_style::round) ? (x+0.5) : x); };</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">I use <span class="EmpStrong">static_cast</span> (&#167;<a href="ch14.html#ch14lev2sec6">14.2.3</a>) to make it explicit that I want to return an <span class="EmpStrong">int</span>.</p>
<p class="codelink"><a id="page_128"/><a id="p128pro01" href="ch11_images.html#p128pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void t1()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f = round;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; f(7.6) &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call through f to the function round</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f = Round(Round_style::truncate);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; f(7.6) &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call the function object</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Round_style style = Round_style::round;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f = [style] (double x){ return static_cast&lt;int&gt;((style==Round_style::round) ? x+0.5 : x); };</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; f(7.6) &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">call the lambda</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt; v {7.6};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f = Round(Round_style::round);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">std::transform(v.begin(),v.end(),v.begin(),f);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pass to algorithm</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; v[0] &lt;&lt; '\n';</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">transformed by the lambda</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">We get <span class="EmpStrong">8</span>, <span class="EmpStrong">7</span>, <span class="EmpStrong">8</span>, and <span class="EmpStrong">8</span>.</p>
<p class="indent">Obviously, <span class="EmpStrong">function</span>s are useful for callbacks, for passing operations as arguments, etc.</p>
<div class="heading">
<h3 id="ch11lev1sec6">11.6. Type Functions</h3>
<p class="noindent">A <em>type function</em> is a function that is evaluated at compile-time given a type as its argument or returning a type. The standard library provides a variety of type functions to help library implementers and programmers in general to write code that take advantage of aspects of the language, the standard library, and code in general.</p>
</div>
<p class="indent">For numerical types, <span class="EmpStrong">numeric_limits</span> from <span class="EmpStrong">&lt;limits&gt;</span> presents a variety of useful information (&#167;<a href="ch12.html#ch12lev1sec7">12.7</a>). For example:</p>
<p class="codelink"><a id="p128pro02" href="ch11_images.html#p128pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">constexpr float min = numeric_limits&lt;float&gt;::min();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">smallest positive float</span></p>
<p class="noindent">Similarly, object sizes can be found by the built-in <span class="EmpStrong">sizeof</span> operator (&#167;<a href="ch01.html#ch01lev1sec5">1.5</a>). For example:</p>
<p class="codelink"><a id="p128pro03" href="ch11_images.html#p128pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">constexpr int szi = sizeof(int);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the number of bytes in an int</span></p>
<p class="noindent">Such type functions are part of C++&#8217;s mechanisms for compile-time computation that allow tighter type checking and better performance than would otherwise have been possible. Use of such features is often called <em>metaprogramming</em> or (when templates are involved) <em>template metaprogramming</em>. Here, I just present two facilities provided by the standard library: <span class="EmpStrong">iterator_traits</span> (&#167;<a href="ch11.html#ch11lev2sec8">11.6.1</a>) and type predicates (&#167;<a href="ch11.html#ch11lev2sec9">11.6.2</a>).</p>
<div class="heading">
<h4 id="ch11lev2sec8">11.6.1. <span class="EmpStrong">iterator_traits</span></h4>
<p class="noindent">The standard-library <span class="EmpStrong">sort()</span> takes a pair of iterators supposed to define a sequence (<a href="ch10.html#ch10">Chapter 10</a>). Furthermore, those iterators must offer random access to that sequence, that is, they must be <a id="page_129"/><em>random-access iterators</em>. Some containers, such as <span class="EmpStrong">forward_list</span>, do not offer that. In particular, a <span class="EmpStrong">forward_list</span> is a singly-linked list so subscripting would be expensive and there is no reasonable way to refer back to a previous element. However, like most containers, <span class="EmpStrong">forward_list</span> offers <em>forward iterators</em> that can be used to traverse the sequence by algorithms and <span class="EmpStrong">for</span>-statements (&#167;<a href="ch05.html#ch05lev1sec2">5.2</a>).</p>
</div>
<p class="indent">The standard library provides a mechanism, <span class="EmpStrong">iterator_traits</span> that allows us to check which kind of iterator is provided. Given that, we can improve the range <span class="EmpStrong">sort()</span> from &#167;<a href="ch10.html#ch10lev1sec7">10.7</a> to accept either a <span class="EmpStrong">vector</span> or a <span class="EmpStrong">forward_list</span>. For example:</p>
<p class="codelink"><a id="p129pro01" href="ch11_images.html#p129pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void test(vector&lt;string&gt;&#38; v, forward_list&lt;int&gt;&#38; lst)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(v);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">sort the vector</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(lst);</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">sort the singly-linked list</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The techniques needed to make that work are generally useful.</p>
<p class="indent">First, I write two helper functions that take an extra argument indicating whether they are to be used for random-access iterators or forward iterators. The version taking random-access iterator arguments is trivial:</p>
<p class="codelink"><a id="p129pro02" href="ch11_images.html#p129pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Ran&gt;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">for random-access iterators</span><br/><span class="EmpStrong">void sort_helper(Ran beg, Ran end, random_access_iterator_tag)</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">we can subscript into [beg:end)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(beg,end);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">just sort it</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The version for forward iterators simply copies the list into a <span class="EmpStrong">vector</span>, sorts, and copies back:</p>
<p class="codelink"><a id="p129pro03" href="ch11_images.html#p129pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename For&gt;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">for forward iterators</span><br/><span class="EmpStrong">void sort_helper(For beg, For end, forward_iterator_tag)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">we can traverse [beg:end)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;Value_type&lt;For&gt;&gt; v {beg,end};</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize a vector from [beg:end)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort(v.begin(),v.end());</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">copy(v.begin(),v.end(),beg);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy the elements back</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><span class="EmpStrong">Value_type&lt;For&gt;</span> is the type of <span class="EmpStrong">For</span>&#8217;s elements, called it&#8217;s <em>value type</em>. Every standard-library iterator has a member <span class="EmpStrong">value_type</span>. I get the <span class="EmpStrong">Value_type&lt;For&gt;</span> notation by defining a type alias (&#167;<a href="ch05.html#ch05lev1sec7">5.7</a>):</p>
<p class="codelink"><a id="p129pro04" href="ch11_images.html#p129pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C&gt;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">using Value_type = typename C::value_type; //</span> <span class="EmpItalic">C's value type</span></p>
<p class="noindent">Thus, <span class="EmpStrong">v</span> is a <span class="EmpStrong">vector&lt;X&gt;</span> where <span class="EmpStrong">X</span> is the element type of the input sequence.</p>
<p class="indent">The real &#8220;type magic&#8221; is in the selection of helper functions:</p>
<p class="codelink"><a id="p129pro05" href="ch11_images.html#p129pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C&gt;</span><br/><span class="EmpStrong">void sort(C&#38; c)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">using Iter = Iterator_type&lt;C&gt;;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sort_helper(c.begin(),c.end(),Iterator_categor y&lt;Iter&gt;{});</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, I use two type functions: <span class="EmpStrong">Iterator_type&lt;C&gt;</span> returns the iterator type of <span class="EmpStrong">C</span> (that is, <span class="EmpStrong">C::iterator</span>) and <a id="page_130"/>then <span class="EmpStrong">Iterator_categor y&lt;Iter&gt;{}</span> constructs a &#8220;tag&#8221; value indicating the kind of iterator provided:</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">std::random_access_iterator_tag</span> if <span class="EmpStrong">C</span>&#8217;s iterator supports random access.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">std::forward_iterator_tag</span> if <span class="EmpStrong">C</span>&#8217;s iterator supports forward iteration.</p>
<p class="noindent">Given that, we can select between the two sorting algorithms at compile time. This technique, called <em>tag dispatch</em> is one of several used in the standard library and elsewhere to improve flexibility and performance.</p>
<p class="indent">The standard-library support for techniques for using iterators, such as tag dispatch, comes in the form of a simple class template <span class="EmpStrong">iterator_traits</span> from <span class="EmpStrong">&lt;iterator&gt;</span>. This allows simple definitions of the type functions used in <span class="EmpStrong">sort()</span>:</p>
<p class="codelink"><a id="p130pro01" href="ch11_images.html#p130pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C&gt;</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;using Iterator_type = typename C::iterator;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">C's iterator type</span><br/><br/><span class="EmpStrong">template&lt;typename Iter&gt;</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;using Iterator_category = typename std::iterator_traits&lt;Iter&gt;::iterator_category;&#160;&#160;&#160;//</span> <span class="EmpItalic">Iter's category</span></p>
<p class="noindent">If you don&#8217;t want to know what kind of &#8220;compile-time type magic&#8221; is used to provide the standard-library features, you are free to ignore facilities such as <span class="EmpStrong">iterator_traits</span>. But then you can&#8217;t use the techniques they support to improve your own code.</p>
<div class="heading">
<h4 id="ch11lev2sec9">11.6.2. Type Predicates</h4>
<p class="noindent">A standard-library type predicate is a simple type function that answers a fundamental question about types. For example:</p>
</div>
<p class="codelink"><a id="p130pro02" href="ch11_images.html#p130pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">bool b1 = Is_arithmetic&lt;int&gt;();</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">yes, int is an arithmetic type</span><br/><span class="EmpStrong">bool b2 = Is_arithmetic&lt;string&gt;();</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">no, std::string is not an arithmetic type</span></p>
<p class="noindent">These predicates are found in <span class="EmpStrong">&lt;type_traits&gt;</span>. Other examples are <span class="EmpStrong">is_class</span>, <span class="EmpStrong">is_pod</span>, <span class="EmpStrong">is_literal_type</span>, <span class="EmpStrong">has_virtual_destructor</span>, and <span class="EmpStrong">is_base_of</span>. They are most useful when we write templates. For example:</p>
<p class="codelink"><a id="p130pro03" href="ch11_images.html#p130pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Scalar&gt;</span><br/><span class="EmpStrong">class complex {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Scalar re, im;</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">static_assert(Is_arithmetic&lt;Scalar&gt;(), "Sorry, I only support complex of arithmetic types");</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">To improve readability compared to using the standard library directly, I defined a type function:</p>
<p class="codelink"><a id="p130pro04" href="ch11_images.html#p130pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">constexpr bool Is_arithmetic()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return std::is_arithmetic&lt;T&gt;::value ;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Older programs use <span class="EmpStrong">::value</span> directly instead of <span class="EmpStrong">()</span>, but I consider that quite ugly and it exposes implementation details.</p>
<div class="heading">
<h3 id="ch11lev1sec7"><a id="page_131"/>11.7. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapters 33-35 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] A library doesn&#8217;t have to be large or complicated to be useful; &#167;<a href="ch11.html#ch11lev1sec1">11.1</a>.</p>
<p class="ref">[3] A resource is anything that has to be acquired and (explicitly or implicitly) released; &#167;<a href="ch11.html#ch11lev1sec2">11.2</a>.</p>
<p class="ref">[4] Use resource handles to manage resources (RAII); &#167;<a href="ch11.html#ch11lev1sec2">11.2</a>.</p>
<p class="ref">[5] Use <span class="EmpStrong">unique_ptr</span> to refer to objects of polymorphic type; &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>.</p>
<p class="ref">[6] Use <span class="EmpStrong">shared_ptr</span> to refer to shared objects; &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>.</p>
<p class="ref">[7] Prefer resource handles with specific semantics to smart pointers; &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>.</p>
<p class="ref">[8] Prefer <span class="EmpStrong">unique_ptr</span> to <span class="EmpStrong">shared_ptr</span>; &#167;<a href="ch04.html#ch04lev2sec11">4.6.4</a>, &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>.</p>
<p class="ref">[9] Prefer smart pointers to garbage collection; &#167;<a href="ch04.html#ch04lev2sec11">4.6.4</a>, &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>.</p>
<p class="ref1">[10] Use <span class="EmpStrong">array</span> where you need a sequence with a <span class="EmpStrong">constexpr</span> size; &#167;<a href="ch11.html#ch11lev2sec2">11.3.1</a>.</p>
<p class="ref1">[11] Prefer <span class="EmpStrong">array</span> over built-in arrays; &#167;<a href="ch11.html#ch11lev2sec2">11.3.1</a>.</p>
<p class="ref1">[12] Use <span class="EmpStrong">bitset</span> if you need <span class="EmpStrong">N</span> bits and <span class="EmpStrong">N</span> is not necessarily the number of bits in a built-in integer type; &#167;<a href="ch11.html#ch11lev2sec3">11.3.2</a>.</p>
<p class="ref1">[13] When using <span class="EmpStrong">pair</span>, consider <span class="EmpStrong">make_pair()</span> for type deduction; &#167;<a href="ch11.html#ch11lev2sec4">11.3.3</a>.</p>
<p class="ref1">[14] When using <span class="EmpStrong">tuple</span>, consider <span class="EmpStrong">make_tuple()</span> for type deduction; &#167;<a href="ch11.html#ch11lev2sec4">11.3.3</a>.</p>
<p class="ref1">[15] Time your programs before making claims about efficiency; &#167;<a href="ch11.html#ch11lev1sec4">11.4</a>.</p>
<p class="ref1">[16] Use <span class="EmpStrong">duration_cast</span> to report time measurements with proper units; &#167;<a href="ch11.html#ch11lev1sec4">11.4</a>.</p>
<p class="ref1">[17] Often, a lambda is an alternative to using <span class="EmpStrong">bind()</span> or <span class="EmpStrong">mem_fn()</span>; &#167;<a href="ch11.html#ch11lev1sec5">11.5</a>.</p>
<p class="ref1">[18] Use <span class="EmpStrong">bind()</span> to create variants of functions and function objects; &#167;<a href="ch11.html#ch11lev2sec5">11.5.1</a>.</p>
<p class="ref1">[19] Use <span class="EmpStrong">mem_fn()</span> to create function objects that can invoke a member function when called using the traditional function call notation; &#167;<a href="ch11.html#ch11lev2sec6">11.5.2</a>.</p>
<p class="ref1">[20] Use <span class="EmpStrong">function</span> when you need to store something that can be called; &#167;<a href="ch11.html#ch11lev2sec7">11.5.3</a>.</p>
<p class="ref1">[21] You can write code to explicitly depend on properties of types; &#167;<a href="ch11.html#ch11lev1sec6">11.6</a>.</p>
</body>
</html>
