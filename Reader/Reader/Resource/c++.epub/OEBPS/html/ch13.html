<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13. Concurrency</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch13"><a id="page_141"/><span class="pd_blue">13.</span> Concurrency</h2>
<p class="blockquote"><em>Keep it simple:<br/>as simple as possible,<br/>but no simpler.</em></p>
<p class="attribution"><em>&#8211; A. Einstein</em></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec2">Tasks and <span class="EmpStrong">thread</span>s</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec3">Passing Arguments</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec4">Returning Results</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec5">Sharing Data</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec6">Waiting for Events</a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec7">Communicating Tasks</a></p>
<p class="indenthangingBP"><a href="ch13.html#ch13lev2sec1"><span class="EmpStrong">future</span> and <span class="EmpStrong">promise</span></a>; <a href="ch13.html#ch13lev2sec2"><span class="EmpStrong">packaged_task</span></a>; <a href="ch13.html#ch13lev2sec3"><span class="EmpStrong">async()</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch13.html#ch13lev1sec8">Advice</a></p>
<div class="heading">
<h3 id="ch13lev1sec1">13.1. Introduction</h3>
<p class="noindent">Concurrency &#8211; the execution of several tasks simultaneously &#8211; is widely used to improve throughput (by using several processors for a single computation) or to improve responsiveness (by allowing one part of a program to progress while another is waiting for a response). All modern programming languages provide support for this. The support provided by the C++ standard library is a portable and type-safe variant of what has been used in C++ for more than 20 years and is almost universally supported by modern hardware. The standard-library support is primarily aimed at supporting systems-level concurrency rather than directly providing sophisticated higher-level concurrency models; those can be supplied as libraries built using the standard-library facilities.</p>
</div>
<p class="indent">The standard library directly supports concurrent execution of multiple threads in a single address space. To allow that, C++ provides a suitable memory model and a set of atomic operations. The atomic operations allows lock-free programming [Dechev,2012]. The memory model <a id="page_142"/>ensures that as long as a programmer avoids data races (uncontrolled concurrent access to mutable data), everything works as one would naively expect. However, most users will see concurrency only in terms of the standard library and libraries built on top of that. This section briefly gives examples of the main standard-library concurrency support facilities: <span class="EmpStrong">thread</span>s, <span class="EmpStrong">mutex</span>es, <span class="EmpStrong">lock()</span> operations, <span class="EmpStrong">packaged_task</span>s, and <span class="EmpStrong">future</span>s. These features are built directly upon what operating systems offer and do not incur performance penalties compared with those. Neither do they guarantee significant performance improvements compared to what the operating system offers.</p>
<p class="indent">Do not consider concurrency a panacea. If a task can be done sequentially, it is often simpler and faster to do so.</p>
<div class="heading">
<h3 id="ch13lev1sec2">13.2. Tasks and <span class="EmpStrong">thread</span>s</h3>
<p class="noindent">We call a computation that can potentially be executed concurrently with other computations a <em>task</em>. A <em>thread</em> is the system-level representation of a task in a program. A task to be executed concurrently with other tasks is launched by constructing a <span class="EmpStrong">std::thread</span> (found in <span class="EmpStrong">&lt;thread&gt;</span>) with the task as its argument. A task is a function or a function object:</p>
</div>
<p class="codelink"><a id="p142pro01" href="ch13_images.html#p142pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">function</span><br/><br/><span class="EmpStrong">struct F {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">function object</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void operator()();</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">F's call operator (&#167;5.5)</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">void user()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t1 {f};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">f() executes in separate thread</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t2 {F()};</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">F()() executes in separate thread</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t1.join();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wait for t1</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t2.join();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">wait for t2</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">join()</span>s ensure that we don&#8217;t exit <span class="EmpStrong">user()</span> until the threads have completed. To &#8220;join&#8221; a <span class="EmpStrong">thread</span> means to &#8220;wait for the thread to terminate.&#8221;</p>
<p class="indent">Threads of a program share a single address space. In this, threads differ from processes, which generally do not directly share data. Since threads share an address space, they can communicate through shared objects (&#167;<a href="ch13.html#ch13lev1sec5">13.5</a>). Such communication is typically controlled by locks or other mechanisms to prevent data races (uncontrolled concurrent access to a variable).</p>
<p class="indent">Programming concurrent tasks can be <em>very</em> tricky. Consider possible implementations of the tasks <span class="EmpStrong">f</span> (a function) and <span class="EmpStrong">F</span> (a function object):</p>
<p class="codelink"><a id="p142pro02" href="ch13_images.html#p142pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f() { cout &lt;&lt; "Hello "; }</span><br/><br/><span class="EmpStrong">struct F {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void operator()() { cout &lt;&lt; "Parallel World!\n"; }</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">This is an example of a bad error: Here, <span class="EmpStrong">f</span> and <span class="EmpStrong">F()</span> each use the object <span class="EmpStrong">cout</span> without any form of <a id="page_143"/>synchronization. The resulting output would be unpredictable and could vary between different executions of the program because the order of execution of the individual operations in the two tasks is not defined. The program may produce &#8220;odd&#8221; output, such as</p>
<p class="pre"><span class="EmpStrong">PaHerallllel o World!</span></p>
<p class="noindent">When defining tasks of a concurrent program, our aim is to keep tasks completely separate except where they communicate in simple and obvious ways. The simplest way of thinking of a concurrent task is as a function that happens to run concurrently with its caller. For that to work, we just have to pass arguments, get a result back, and make sure that there is no use of shared data in between (no data races).</p>
<div class="heading">
<h3 id="ch13lev1sec3">13.3. Passing Arguments</h3>
<p class="noindent">Typically, a task needs data to work upon. We can easily pass data (or pointers or references to the data) as arguments. Consider:</p>
</div>
<p class="codelink"><a id="p143pro01" href="ch13_images.html#p143pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(vector&lt;double&gt;&#38; v);&#160;&#160;//</span> <span class="EmpItalic">function do something with v</span><br/><br/><span class="EmpStrong">struct F {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">function object: do something with v</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt;&#38; v;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">F(vector&lt;double&gt;&#38; vv) :v{vv} { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void operator()();</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">application operator; &#167;5.5</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt; some_vec {1,2,3,4,5,6,7,8,9};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt; vec2 {10,11,12,13,14};</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t1 {f,ref(some_vec)}; //</span> <span class="EmpItalic">f(some_vec) executes in a separate thread</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t2 {F{vec2}};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">F(vec2)() executes in a separate thread</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t1.join();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t2.join();</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Obviously, <span class="EmpStrong">F{vec2}</span> saves a reference to the argument vector in <span class="EmpStrong">F</span>. <span class="EmpStrong">F</span> can now use that vector and hopefully no other task accesses <span class="EmpStrong">vec2</span> while <span class="EmpStrong">F</span> is executing. Passing <span class="EmpStrong">vec2</span> by value would eliminate that risk.</p>
<p class="indent">The initialization with <span class="EmpStrong">{f,ref(some_vec)}</span> uses a <span class="EmpStrong">thread</span> variadic template constructor that can accept an arbitrary sequence of arguments (&#167;<a href="ch05.html#ch05lev1sec6">5.6</a>). The <span class="EmpStrong">ref()</span> is a type function from <span class="EmpStrong">&lt;functional&gt;</span> that unfortunately is needed to tell the variadic template to treat <span class="EmpStrong">some_vec</span> as a reference, rather than as an object. The compiler checks that the first argument can be invoked given the following arguments and builds the necessary function object to pass to the thread. Thus, if <span class="EmpStrong">F::operator()()</span> and <span class="EmpStrong">f()</span> perform the same algorithm, the handling of the two tasks are roughly equivalent: in both cases, a function object is constructed for the <span class="EmpStrong">thread</span> to execute.</p>
<div class="heading">
<h3 id="ch13lev1sec4"><a id="page_144"/>13.4. Returning Results</h3>
<p class="noindent">In the example in &#167;<a href="ch13.html#ch13lev1sec3">13.3</a>, I pass the arguments by non-<span class="EmpStrong">const</span> reference. I only do that if I expect the task to modify the value of the data referred to (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>). That&#8217;s a somewhat sneaky, but not uncommon, way of returning a result. A less obscure technique is to pass the input data by <span class="EmpStrong">const</span> reference and to pass the location of a place to deposit the result as a separate argument:</p>
</div>
<p class="codelink"><a id="p144pro01" href="ch13_images.html#p144pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(const vector&lt;double&gt;&#38; v, double* res);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">take input from v;&#160;&#160;place result in *res</span><br/><span class="EmpStrong">class F {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">F(const vector&lt;double&gt;&#38; vv, double* p) :v{vv}, res{p} { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void operator()();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">place result in *res</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const vector&lt;double&gt;&#38; v;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">source of input</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* res;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">target for output</span><br/><span class="EmpStrong">};</span></p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt; some_vec;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;double&gt; vec2;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double res1;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double res2;</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t1 {f,cref(some_vec),&#38;res1};</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">f(some_vec,&#38;res1) executes in a separate thread</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t2 {F{vec2,&#38;res2}};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">F{vec2,&#38;res2}() executes in a separate thread</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t1.join();</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">t2.join();</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; res1 &lt;&lt; ' ' &lt;&lt; res2 &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This works and the technique is very common, but I don&#8217;t consider returning results through arguments particularly elegant, so I return to this topic in &#167;<a href="ch13.html#ch13lev2sec1">13.7.1</a>.</p>
<div class="heading">
<h3 id="ch13lev1sec5">13.5. Sharing Data</h3>
<p class="noindent">Sometimes tasks need to share data. In that case, the access has to be synchronized so that at most one task at a time has access. Experienced programmers will recognize this as a simplification (e.g., there is no problem with many tasks simultaneously reading immutable data), but consider how to ensure that at most one task at a time has access to a given set of objects.</p>
</div>
<p class="indent">The fundamental element of the solution is a <span class="EmpStrong">mutex</span>, a &#8220;mutual exclusion object.&#8221; A <span class="EmpStrong">thread</span> acquires a mutex using a <span class="EmpStrong">lock()</span> operation:</p>
<p class="codelink"><a id="page_145"/><a id="p145pro01" href="ch13_images.html#p145pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">mutex m; //</span> <span class="EmpItalic">controlling mutex</span><br/><span class="EmpStrong">int sh;&#160;&#160;//</span> <span class="EmpItalic">shared data</span><br/><br/><span class="EmpStrong">void f()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck {m}; //</span> <span class="EmpItalic">acquire mutex</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sh += 7;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">manipulate shared data</span><br/><span class="EmpStrong">}&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">release mutex implicitly</span></p>
<p class="noindent">The <span class="EmpStrong">unique_lock</span>&#8217;s constructor acquires the mutex (through a call <span class="EmpStrong">m.lock()</span>). If another thread has already acquired the mutex, the thread waits (&#8220;blocks&#8221;) until the other thread completes its access. Once a thread has completed its access to the shared data, the <span class="EmpStrong">unique_lock</span> releases the <span class="EmpStrong">mutex</span> (with a call <span class="EmpStrong">m.unlock()</span>). When a <span class="EmpStrong">mutex</span> is released, <span class="EmpStrong">thread</span>s waiting for it resume executing (&#8220;are woken up&#8221;). The mutual exclusion and locking facilities are found in <span class="EmpStrong">&lt;mutex&gt;</span>.</p>
<p class="indent">The correspondence between the shared data and a <span class="EmpStrong">mutex</span> is conventional: the programmer simply has to know which <span class="EmpStrong">mutex</span> is supposed to correspond to which data. Obviously, this is error-prone, and equally obviously we try to make the correspondence clear through various language means. For example:</p>
<p class="pre"><span class="EmpStrong">class Record {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">mutex rm;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">It doesn&#8217;t take a genius to guess that for a <span class="EmpStrong">Record</span> called <span class="EmpStrong">rec</span>, <span class="EmpStrong">rec.rm</span> is a <span class="EmpStrong">mutex</span> that you are supposed to acquire before accessing the other data of <span class="EmpStrong">rec</span>, though a comment or a better name might have helped a reader.</p>
<p class="indent">It is not uncommon to need to simultaneously access several resources to perform some action. This can lead to deadlock. For example, if <span class="EmpStrong">thread1</span> acquires <span class="EmpStrong">mutex1</span> and then tries to acquire <span class="EmpStrong">mutex2</span> while <span class="EmpStrong">thread2</span> acquires <span class="EmpStrong">mutex2</span> and then tries to acquire <span class="EmpStrong">mutex1</span>, then neither task will ever proceed further. The standard library offers help in the form of an operation for acquiring several locks simultaneously:</p>
<p class="codelink"><a id="p145pro02" href="ch13_images.html#p145pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck1 {m1,defer_lock};&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">defer_lock: don't yet try to acquire the mutex</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck2 {m2,defer_lock};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck3 {m3,defer_lock};</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">lock(lck1,lck2,lck3);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">acquire all three locks</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">... manipulate shared data ...</span><br/><span class="EmpStrong">} //</span> <span class="EmpItalic">implicitly release all mutexes</span><br/></p>
<p class="noindent">This <span class="EmpStrong">lock()</span> will proceed only after acquiring all its <span class="EmpStrong">mutex</span> arguments and will never block (&#8220;go to sleep&#8221;) while holding a <span class="EmpStrong">mutex</span>. The destructors for the individual <span class="EmpStrong">unique_lock</span>s ensure that the</p>
<p class="indent"><span class="EmpStrong">mutex</span>es are released when a <span class="EmpStrong">thread</span> leaves the scope.</p>
<p class="indent"><a id="page_146"/>Communicating through shared data is pretty low level. In particular, the programmer has to devise ways of knowing what work has and has not been done by various tasks. In that regard, use of shared data is inferior to the notion of call and return. On the other hand, some people are convinced that sharing must be more efficient than copying arguments and returns. That can indeed be so when large amounts of data are involved, but locking and unlocking are relatively expensive operations. On the other hand, modern machines are very good at copying data, especially compact data, such as <span class="EmpStrong">vector</span> elements. So don&#8217;t choose shared data for communication because of &#8220;efficiency&#8221; without thought and preferably not without measurement.</p>
<div class="heading">
<h3 id="ch13lev1sec6">13.6. Waiting for Events</h3>
<p class="noindent">Sometimes, a <span class="EmpStrong">thread</span> needs to wait for some kind of external event, such as another <span class="EmpStrong">thread</span> completing a task or a certain amount of time having passed. The simplest &#8220;event&#8221; is simply time passing. Using the time facilities found in <span class="EmpStrong">&lt;chrono&gt;</span> I can write:</p>
</div>
<p class="codelink"><a id="p146pro01" href="ch13_images.html#p146pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">using namespace std::chrono;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">see &#167;11.4</span><br/><br/><span class="EmpStrong">auto t0 = high_resolution_clock::now();</span><br/><span class="EmpStrong">this_thread::sleep_for(milliseconds{20});</span><br/><span class="EmpStrong">auto t1 = high_resolution_clock::now();</span><br/><br/><span class="EmpStrong">cout &lt;&lt; duration_cast&lt;nanoseconds&gt;(t1-t0).count() &lt;&lt; " nanoseconds passed\n";</span></p>
<p class="noindent">Note that I didn&#8217;t even have to launch a <span class="EmpStrong">thread</span>; by default, <span class="EmpStrong">this_thread</span> refers to the one and only thread.</p>
<p class="indent">I used <span class="EmpStrong">duration_cast</span> to adjust the clock&#8217;s units to the nanoseconds I wanted.</p>
<p class="indent">The basic support for communicating using external events is provided by <span class="EmpStrong">condition_variable</span>s found in <span class="EmpStrong">&lt;condition_variable&gt;</span>. A <span class="EmpStrong">condition_variable</span> is a mechanism allowing one <span class="EmpStrong">thread</span> to wait for another. In particular, it allows a <span class="EmpStrong">thread</span> to wait for some <em>condition</em> (often called an <em>event</em>) to occur as the result of work done by other <span class="EmpStrong">thread</span>s.</p>
<p class="indent">Using <span class="EmpStrong">condition_variable</span>s supports many forms of elegant and efficient sharing, but can be rather tricky. Consider the classical example of two <span class="EmpStrong">thread</span>s communicating by passing messages through a <span class="EmpStrong">queue</span>. For simplicity, I declare the <span class="EmpStrong">queue</span> and the mechanism for avoiding race conditions on that <span class="EmpStrong">queue</span> global to the producer and consumer:</p>
<p class="codelink"><a id="p146pro02" href="ch13_images.html#p146pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Message {&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">object to be communicated</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">queue&lt;Message&gt; mqueue;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the queue of messages</span><br/><span class="EmpStrong">condition_variable mcond;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the variable communicating events</span><br/><span class="EmpStrong">mutex mmutex;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">the locking mechanism</span></p>
<p class="noindent">The types <span class="EmpStrong">queue</span>, <span class="EmpStrong">condition_variable</span>, and <span class="EmpStrong">mutex</span> are provided by the standard library.</p>
<p class="indent">The <span class="EmpStrong">consumer()</span> reads and processes <span class="EmpStrong">Message</span>s:</p>
<p class="codelink"><a id="page_147"/><a id="p147pro01" href="ch13_images.html#p147pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void consumer()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">while(true) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck{mmutex};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">acquire mmutex</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (mcond.wait(lck)) /*</span> <span class="EmpItalic">do nothing</span> <span class="EmpStrong">*/;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">release lck and wait;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">re-acquire lck upon wakeup</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto m = mqueue.front();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">get the message</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">mqueue.pop();</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">lck.unlock();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">release lck</span><br/><span class="EmpStrong">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">... process m ...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, I explicitly protect the operations on the <span class="EmpStrong">queue</span> and on the <span class="EmpStrong">condition_variable</span> with a</p>
<p class="indent"><span class="EmpStrong">unique_lock</span> on the <span class="EmpStrong">mutex</span>. Waiting on <span class="EmpStrong">condition_variable</span> releases its lock argument until the wait is over (so that the queue is non-empty) and then reacquires it.</p>
<p class="indent">The corresponding <span class="EmpStrong">producer</span> looks like this:</p>
<p class="codelink"><a id="p147pro02" href="ch13_images.html#p147pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void producer()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">while(true) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Message m;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... fill the message ...</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">unique_lock&lt;mutex&gt; lck {mmutex};&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">protect operations</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">mqueue.push(m);</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">mcond.notify_one();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">notify</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">release lock (at end of scope)</span><br/><span class="EmpStrong">}</span><br/></p>
<div class="heading">
<h3 id="ch13lev1sec7">13.7. Communicating Tasks</h3>
<p class="noindent">The standard library provides a few facilities to allow programmers to operate at the conceptual level of tasks (work to potentially be done concurrently) rather than directly at the lower level of threads and locks:</p>
</div>
<p class="indent">[1] <span class="EmpStrong">future</span> and <span class="EmpStrong">promise</span> for returning a value from a task spawned on a separate thread</p>
<p class="indent">[2] <span class="EmpStrong">packaged_task</span> to help launch tasks and connect up the mechanisms for returning a result</p>
<p class="indent">[3] <span class="EmpStrong">async()</span> for launching of a task in a manner very similar to calling a function. These facilities are found in <span class="EmpStrong">&lt;future&gt;</span>.</p>
<div class="heading">
<h4 id="ch13lev2sec1">13.7.1. <span class="EmpStrong">future</span> and <span class="EmpStrong">promise</span></h4>
<p class="noindent">The important point about <span class="EmpStrong">future</span> and <span class="EmpStrong">promise</span> is that they enable a transfer of a value between two tasks without explicit use of a lock; &#8220;the system&#8221; implements the transfer efficiently. The basic idea is simple: When a task wants to pass a value to another, it puts the value into a <span class="EmpStrong">promise</span>. Somehow, the implementation makes that value appear in the corresponding <span class="EmpStrong">future</span>, from which it can be read (typically by the launcher of the task). We can represent this graphically:</p>
</div>
<div class="image"><a id="page_148"/><img src="graphics/148fig01.jpg" alt="Image"/></div>
<p class="noindent">If we have a <span class="EmpStrong">future&lt;X&gt;</span> called <span class="EmpStrong">fx</span>, we can <span class="EmpStrong">get()</span> a value of type <span class="EmpStrong">X</span> from it:</p>
<p class="codelink"><a id="p148pro01" href="ch13_images.html#p148pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">X v = fx.get(); //</span> <span class="EmpItalic">if necessary, wait for the value to get computed</span></p>
<p class="noindent">If the value isn&#8217;t there yet, our thread is blocked until it arrives. If the value couldn&#8217;t be computed,</p>
<p class="indent"><span class="EmpStrong">get()</span> might throw an exception (from the system or transmitted from the task from which we were trying to <span class="EmpStrong">get()</span> the value).</p>
<p class="indent">The main purpose of a <span class="EmpStrong">promise</span> is to provide simple &#8220;put&#8221; operations (called <span class="EmpStrong">set_value()</span> and <span class="EmpStrong">set_exception()</span>) to match <span class="EmpStrong">future</span>&#8217;s <span class="EmpStrong">get()</span>. The names &#8220;future&#8221; and &#8220;promise&#8221; are historical; please don&#8217;t blame or credit me. They are yet another fertile source of puns.</p>
<p class="indent">If you have a <span class="EmpStrong">promise</span> and need to send a result of type <span class="EmpStrong">X</span> to a <span class="EmpStrong">future</span>, you can do one of two things: pass a value or pass an exception. For example:</p>
<p class="codelink"><a id="p148pro02" href="ch13_images.html#p148pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(promise&lt;X&gt;&#38; px)&#160;&#160;&#160;//</span> <span class="EmpItalic">a task: place the result in px</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X res;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... compute a value for res ...</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">px.set_value(res);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (...) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">oops: couldn't compute res</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">px.set_exception(current_exception());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">pass the exception to the future's thread</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">current_exception()</span> refers to the caught exception.</p>
<p class="indent">To deal with an exception transmitted through a <span class="EmpStrong">future</span>, the caller of <span class="EmpStrong">get()</span> must be prepared to catch it somewhere. For example:</p>
<p class="codelink"><a id="p148pro03" href="ch13_images.html#p148pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void g(future&lt;X&gt;&#38; fx)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">a task: get the result from fx</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X v = fx.get();&#160;&#160;//</span> <span class="EmpItalic">if necessary, wait for the value to get computed</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... use v ...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (...) {</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">oops: someone couldn't compute v</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... handle error ...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_149"/>If the error doesn&#8217;t need to be handled by <span class="EmpStrong">g()</span> itself, the code reduces to the minimal:</p>
<p class="codelink"><a id="p149pro01" href="ch13_images.html#p149pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void g(future&lt;X&gt;&#38; fx)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">// a task: get the result from fx</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">X v = fx.get();</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">// if necessary, wait for the value to get computed</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... use v ...</span><br/><span class="EmpStrong">}</span></p>
<div class="heading">
<h4 id="ch13lev2sec2">13.7.2. <span class="EmpStrong">packaged_task</span></h4>
<p class="noindent">How do we get a <span class="EmpStrong">future</span> into the task that needs a result and the corresponding <span class="EmpStrong">promise</span> into the thread that should produce that result? The <span class="EmpStrong">packaged_task</span> type is provided to simplify setting up tasks connected with <span class="EmpStrong">future</span>s and <span class="EmpStrong">promise</span>s to be run on <span class="EmpStrong">thread</span> futures. A <span class="EmpStrong">packaged_task</span> provides wrapper code to put the return value or exception from the task into a <span class="EmpStrong">promise</span> (like the code shown in &#167;<a href="ch13.html#ch13lev2sec1">13.7.1</a>). If you ask it by calling <span class="EmpStrong">get_future</span>, a <span class="EmpStrong">packaged_task</span> will give you the <span class="EmpStrong">future</span> corresponding to its <span class="EmpStrong">promise</span>. For example, we can set up two tasks to each add half of the elements of a <span class="EmpStrong">vector&lt;double&gt;</span> using the standard-library <span class="EmpStrong">accumulate()</span> (&#167;<a href="ch12.html#ch12lev1sec3">12.3</a>):</p>
</div>
<p class="codelink"><a id="p149pro02" href="ch13_images.html#p149pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double accum(double* beg, double* end, double init)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">compute the sum of [beg:end) starting with the initial value init</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return accumulate(beg,end,init);</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">double comp2(vector&lt;double&gt;&#38; v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">using Task_type = double(double*,double*,double);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">type of task</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">packaged_task&lt;Task_type&gt; pt0 {accum};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">package the task (i.e., accum)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">packaged_task&lt;Task_type&gt; pt1 {accum};</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">future&lt;double&gt; f0 {pt0.get_future()};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get hold of pt0's future</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">future&lt;double&gt; f1 {pt1.get_future()};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">get hold of pt1's future</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">double* first = &#38;v[0];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t1 {move(pt0),first,first+v.size()/2,0};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">start a thread for pt0</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">thread t2 {move(pt1),first+v.size()/2,first+v.size(),0};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">start athread for pt1</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return f0.get()+f1.get();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">get the results</span><br/><span class="EmpStrong">}</span><br/></p>
<p class="noindent">The <span class="EmpStrong">packaged_task</span> template takes the type of the task as its template argument (here <span class="EmpStrong">Task_type</span>, an alias for <span class="EmpStrong">double(double</span> <code>*</code><span class="EmpStrong">, double</span> <code>*</code><span class="EmpStrong">,double)</span>) and the task as its constructor argument (here, <span class="EmpStrong">accum</span>). The <span class="EmpStrong">move()</span> operations are needed because a <span class="EmpStrong">packaged_task</span> cannot be copied. The reason that a <span class="EmpStrong">packaged_task</span> cannot be copied is that it is a resource handle: it owns its <span class="EmpStrong">promise</span> and is (indirectly) responsible for whatever resoures its task may own.</p>
<p class="indent"><a id="page_150"/>Please note the absence of explicit mention of locks in this code: we are able to concentrate on tasks to be done, rather than on the mechanisms used to manage their communication. The two tasks will be run on separate threads and thus potentially in parallel.</p>
<div class="heading">
<h4 id="ch13lev2sec3">13.7.3. <span class="EmpStrong">async()</span></h4>
<p class="noindent">The line of thinking I have pursued in this chapter is the one I believe to be the simplest yet still among the most powerful: Treat a task as a function that may happen to run concurrently with other tasks. It is far from the only model supported by the C++ standard library, but it serves well for a wide range of needs. More subtle and tricky models, e.g., styles of programming relying on shared memory, can be used as needed.</p>
</div>
<p class="indent">To launch tasks to potentially run asynchronously, we can use <span class="EmpStrong">async()</span>:</p>
<p class="codelink"><a id="p150pro01" href="ch13_images.html#p150pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double comp4(vector&lt;double&gt;&#38; v)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">spawn many tasks if v is large enough</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (v.size()&lt;10000)</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">is it worth using concurrency?</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return accum(v.begin(),v.end(),0.0);</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto v0 = &#38;v[0];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto sz = v.size();</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto f0 = async(accum,v0,v0+sz/4,0.0);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">first quarter</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">second quarter</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto f2 = async(accum,v0+sz/2,v0+sz*3/4,0.0);&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">third quarter</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">auto f3 = async(accum,v0+sz*3/4,v0+sz,0.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">fourth quarter</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return f0.get()+f1.get()+f2.get()+f3.get();</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">collect and combine the results</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Basically, <span class="EmpStrong">async()</span> separates the &#8220;call part&#8221; of a function call from the &#8220;get the result part,&#8221; and separates both from the actual execution of the task. Using <span class="EmpStrong">async()</span>, you don&#8217;t have to think about threads and locks. Instead, you think just in terms of tasks that potentially compute their results asynchronously. There is an obvious limitation: Don&#8217;t even think of using <span class="EmpStrong">async()</span> for tasks that share resources needing locking &#8211; with <span class="EmpStrong">async()</span> you don&#8217;t even know how many <span class="EmpStrong">thread</span>s will be used because that&#8217;s up to <span class="EmpStrong">async()</span> to decide based on what it knows about the system resources available at the time of a call. For example, <span class="EmpStrong">async()</span> may check whether any idle cores (processors) are available before deciding how many <span class="EmpStrong">thread</span>s to use.</p>
<p class="indent">Using a guess about the cost of computation relative to the cost of launching a <span class="EmpStrong">thread</span>, such as</p>
<p class="indent"><span class="EmpStrong">v.size()&lt;10000</span>, is very primitive and prone to gross mistakes about performance. However, this is not the place for a proper disussion about how to manage <span class="EmpStrong">thread</span>s. Don&#8217;t take this estimate as more than a simple and probably poor guess.</p>
<p class="indent">Please note that <span class="EmpStrong">async()</span> is not just a mechanism specialized for parallel computation for increased performance. For example, it can also be used to spawn a task for getting information from a user, leaving the &#8220;main program&#8221; active with something else (&#167;<a href="ch13.html#ch13lev2sec3">13.7.3</a>).</p>
<div class="heading">
<h3 id="ch13lev1sec8"><a id="page_151"/>13.8. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapters 41-42 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Use concurrency to improve responsiveness or to improve throughput; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[3] Work at the highest level of abstraction that you can afford; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[4] Consider processes as an alternative to threads; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[5] The standard-library concurrency facilities are type safe; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[6] The memory model exists to save most programmers from having to think about the machine architecture level of computers; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[7] The memory model makes memory appear roughly as naively expected; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[8] Atomics allow for lock-free programming; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref">[9] Leave lock-free programming to experts; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref1">[10] Sometimes, a sequential solution is simpler and faster than a concurrent solution; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>.</p>
<p class="ref1">[11] Avoid data races; &#167;<a href="ch13.html#ch13lev1sec1">13.1</a>, &#167;<a href="ch13.html#ch13lev1sec2">13.2</a>.</p>
<p class="ref1">[12] A <span class="EmpStrong">thread</span> is a type-safe interface to a system thread; &#167;<a href="ch13.html#ch13lev1sec2">13.2</a>.</p>
<p class="ref1">[13] Use <span class="EmpStrong">join()</span> to wait for a <span class="EmpStrong">thread</span> to complete; &#167;<a href="ch13.html#ch13lev1sec2">13.2</a>.</p>
<p class="ref1">[14] Avoid explicitly shared data whenever you can; &#167;<a href="ch13.html#ch13lev1sec2">13.2</a>.</p>
<p class="ref1">[15] Use <span class="EmpStrong">unique_lock</span> to manage mutexes; &#167;<a href="ch13.html#ch13lev1sec5">13.5</a>.</p>
<p class="ref1">[16] Use <span class="EmpStrong">lock()</span> to acquire multiple locks; &#167;<a href="ch13.html#ch13lev1sec5">13.5</a>.</p>
<p class="ref1">[17] Use <span class="EmpStrong">condition_variable</span>s to manage communication among <span class="EmpStrong">thread</span>s; &#167;<a href="ch13.html#ch13lev1sec6">13.6</a>.</p>
<p class="ref1">[18] Think in terms of tasks that can be executed concurrently, rather than directly in terms of</p>
<p class="refP"><span class="EmpStrong">thread</span>s; &#167;<a href="ch13.html#ch13lev1sec7">13.7</a>.</p>
<p class="ref1">[19] Value simplicity; &#167;<a href="ch13.html#ch13lev1sec7">13.7</a>.</p>
<p class="ref1">[20] Prefer <span class="EmpStrong">packaged_task</span> and <span class="EmpStrong">future</span>s over direct use of <span class="EmpStrong">thread</span>s and <span class="EmpStrong">mutex</span>es; &#167;<a href="ch13.html#ch13lev1sec7">13.7</a>.</p>
<p class="ref1">[21] Return a result using a <span class="EmpStrong">promise</span> and get a result from a <span class="EmpStrong">future</span>; &#167;<a href="ch13.html#ch13lev2sec1">13.7.1</a>.</p>
<p class="ref1">[22] Use <span class="EmpStrong">packaged_task</span>s to handle exceptions thrown by tasks and to arrange for value return; &#167;<a href="ch13.html#ch13lev2sec2">13.7.2</a>.</p>
<p class="ref1">[23] Use a <span class="EmpStrong">packaged_task</span> and a <span class="EmpStrong">future</span> to express a request to an external service and wait for its response; &#167;<a href="ch13.html#ch13lev2sec2">13.7.2</a>.</p>
<p class="ref1">[24] Use <span class="EmpStrong">async()</span> to launch simple tasks; &#167;<a href="ch13.html#ch13lev2sec3">13.7.3</a>.</p>
</body>
</html>
