<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5. Templates</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch05"><a id="page_59"/><span class="pd_blue">5.</span> Templates</h2>
<p class="blockquote"><em>Your quote here.</em></p>
<p class="attribution"><em>&#8211; B. Stroustrup</em></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec2">Parameterized Types</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec3">Function Templates</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec4">Concepts and Generic Programming</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec5">Function Objects</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec6">Variadic Templates</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec7">Aliases</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec8">Template Compilation Model</a></p>
<p class="indenthangingB">&#8226; <a href="ch05.html#ch05lev1sec9">Advice</a></p>
<div class="heading">
<h3 id="ch05lev1sec1">5.1. Introduction</h3>
<p class="noindent">Someone who wants a vector is unlikely always to want a vector of <span class="EmpStrong">double</span>s. A vector is a general concept, independent of the notion of a floating-point number. Consequently, the element type of a vector ought to be represented independently. A <em>template</em> is a class or a function that we parameterize with a set of types or values. We use templates to represent concepts that are best understood as something very general from which we can generate specific types and functions by specifying arguments, such as the element type <span class="EmpStrong">double</span>.</p>
</div>
<div class="heading">
<h3 id="ch05lev1sec2">5.2. Parameterized Types</h3>
<p class="noindent">We can generalize our vector-of-doubles type to a vector-of-anything type by making it a <span class="EmpStrong">template</span> and replacing the specific type <span class="EmpStrong">double</span> with a parameter. For example:</p>
</div>
<p class="codelink"><a id="page_60"/><a id="p060pro01" href="ch05_images.html#p060pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T* elem;</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">elem points to an array of sz elements of type T</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">explicit Vector(int s);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">constructor: establish invariant, acquire resources</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong"><sup>~</sup>Vector() { delete[] elem; }</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">destructor: release resources</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">... copy and move operations ...</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T&#38; operator[](int i);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const T&#38; operator[](int i) const;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() const { return sz; }</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The <span class="EmpStrong">template&lt;typename T&gt;</span> prefix makes <span class="EmpStrong">T</span> a parameter of the declaration it prefixes. It is C++&#8217;s version of the mathematical &#8220;for all T&#8221; or more precisely &#8220;for all types T.&#8221; Using <span class="EmpStrong">class</span> to introduce a type parameter is equivalent to using <span class="EmpStrong">typename</span>, and in older code we often see <span class="EmpStrong">template&lt;class T&gt;</span> as the prefix.</p>
<p class="indent">The member functions might be defined similarly:</p>
<p class="codelink"><a id="p060pro02" href="ch05_images.html#p060pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">Vector&lt;T&gt;::Vector(int s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (s&lt;0)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw Negative_size{};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">elem = new T[s];</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">sz = s;</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">const T&#38; Vector&lt;T&gt;::operator[](int i) const</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">if (i&lt;0 || size()&lt;=i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">throw out_of_range{"Vector::operator[]"};</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return elem[i];</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Given these definitions, we can define <span class="EmpStrong">Vector</span>s like this:</p>
<p class="codelink"><a id="p060pro03" href="ch05_images.html#p060pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector&lt;char&gt; vc(200);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">vector of 200 characters</span><br/><span class="EmpStrong">Vector&lt;string&gt; vs(17);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">vector of 17 strings</span><br/><span class="EmpStrong">Vector&lt;list&lt;int&gt;&gt; vli(45);</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">vector of 45 lists of integers</span></p>
<p class="noindent">The <span class="EmpStrong">&gt;&gt;</span> in <span class="EmpStrong">Vector&lt;list&lt;int&gt;&gt;</span> terminates the nested template arguments; it is not a misplaced input operator. It is not (as in C++98) necessary to place a space between the two <span class="EmpStrong">&gt;</span>s.</p>
<p class="indent">We can use <span class="EmpStrong">Vector</span>s like this:</p>
<p class="codelink"><a id="page_61"/><a id="p061pro01" href="ch05_images.html#p061pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void write(const Vector&lt;string&gt;&#38; vs)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Vector of some strings</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i = 0; i!=vs.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; vs[i] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">To support the range-<span class="EmpStrong">for</span> loop for our <span class="EmpStrong">Vector</span>, we must define suitable <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span> functions:</p>
<p class="codelink"><a id="p061pro02" href="ch05_images.html#p061pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">T* begin(Vector&lt;T&gt;&#38; x)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return x.size() ? &#38;x[0] : nullptr;</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pointer to first element or nullptr</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">T* end(Vector&lt;T&gt;&#38; x)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return begin(x)+x.size();</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pointer to one-past-last element</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Given those, we can write:</p>
<p class="codelink"><a id="p061pro03" href="ch05_images.html#p061pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f2(Vector&lt;string&gt;&#38; vs)</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">Vector of some strings</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto&#38; s : vs)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; s &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Similarly, we can define lists, vectors, maps (that is, associative arrays), unordered maps (that is, hash tables), etc., as templates (<a href="ch09.html#ch09">Chapter 9</a>).</p>
<p class="indent">Templates are a compile-time mechanism, so their use incurs no run-time overhead compared to hand-crafted code. In fact, the code generated for <span class="EmpStrong">Vector&lt;double&gt;</span> is identical to the code generated for the version of <span class="EmpStrong">Vector</span> from <a href="ch04.html#ch04">Chapter 4</a>. Furthermore, the code generated for the standard-library <span class="EmpStrong">vector&lt;double&gt;</span> is likely to be better (because more effort has gone into its implementation).</p>
<p class="indent">In addition to type arguments, a template can take value arguments. For example:</p>
<p class="codelink"><a id="p061pro04" href="ch05_images.html#p061pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T, int N&gt;</span><br/><span class="EmpStrong">struct Buffer {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">using value_type = T;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">constexpr int size() { return N; }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T[N];</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The alias (<span class="EmpStrong">value_type</span>) and the <span class="EmpStrong">constexpr</span> function are provided to allow users (read-only) access to the template arguments.</p>
<p class="indent">Value arguments are useful in many contexts. For example, <span class="EmpStrong">Buffer</span> allows us to create arbitrarily sized buffers with no overheads from the use of free store (dynamic memory):</p>
<p class="codelink"><a id="page_62"/><a id="p062pro01" href="ch05_images.html#p062pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Buffer&lt;char,1024&gt; glob;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">global buffer of characters (statically allocated)</span><br/><br/><span class="EmpStrong">void fct()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Buffer&lt;int,10&gt; buf; //</span> <span class="EmpItalic">local buffer of integers (on the stack)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A template value argument must be a constant expression.</p>
<div class="heading">
<h3 id="ch05lev1sec3">5.3. Function Templates</h3>
<p class="noindent">Templates have many more uses than simply parameterizing a container with an element type. In particular, they are extensively used for parameterization of both types and algorithms in the standard library (&#167;<a href="ch09.html#ch09lev1sec6">9.6</a>, &#167;<a href="ch10.html#ch10lev1sec6">10.6</a>). For example, we can write a function that calculates the sum of the element values of any container like this:</p>
</div>
<p class="codelink"><a id="p062pro02" href="ch05_images.html#p062pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Container, typename Value&gt;</span><br/><span class="EmpStrong">Value sum(const Container&#38; c, Value v)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto x : c)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v+=x;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return v;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The <span class="EmpStrong">Value</span> template argument and the function argument <span class="EmpStrong">v</span> are there to allow the caller to specify the type and initial value of the accumulator (the variable in which to accumulate the sum):</p>
<p class="codelink"><a id="p062pro03" href="ch05_images.html#p062pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void user(Vector&lt;int&gt;&#38; vi, std::list&lt;double&gt;&#38; ld, std::vector&lt;complex&lt;double&gt;&gt;&#38; vc)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int x = sum(vi,0);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the sum of a vector of ints (add ints)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double d = sum(vi,0.0);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the sum of a vector of ints (add doubles)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double dd = sum(ld,0.0);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the sum of a list of doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">auto z = sum(vc,complex&lt;double&gt;{0.0,0.0});</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the sum of a vector of complex&lt;double&gt;S</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The point of adding <span class="EmpStrong">int</span>s in a <span class="EmpStrong">double</span> would be to gracefully handle a number larger than the largest <span class="EmpStrong">int</span>. Note how the types of the template arguments for <span class="EmpStrong">sum&lt;T,V&gt;</span> are deduced from the function arguments. Fortunately, we do not need to explicitly specify those types.</p>
<p class="indent">This <span class="EmpStrong">sum()</span> is a simplified version of the standard-library <span class="EmpStrong">accumulate()</span> (&#167;<a href="ch12.html#ch12lev1sec3">12.3</a>).</p>
<p class="indent">A function template can be a member function, but not a <span class="EmpStrong">virtual</span> member. The compiler would not know all instantiations of such a template in a program so it could not generate a <span class="EmpStrong">vtbl</span> (&#167;<a href="ch04.html#ch04lev1sec4">4.4</a>).</p>
<div class="heading">
<h3 id="ch05lev1sec4">5.4. Concepts and Generic Programming</h3>
<p class="noindent">What are templates for? In other words, what programming techniques are effective when you use templates? Templates offer:</p>
</div>
<p class="indenthangingB">&#8226; The ability to pass types (as well as values and templates) as arguments without loss of information. This implies excellent opportunities for inlining, of which current <a id="page_63"/>implementations take great advantage.</p>
<p class="indenthangingB">&#8226; Delayed type checking (done at instantiation time). This implies opportunities to weave together information from different contexts.</p>
<p class="indenthangingB">&#8226; The ability to pass constant values as arguments. This implies the ability to do compile-time computation.</p>
<p class="noindent">In other words, templates provide a powerful mechanism for compile-time computation and type manipulation that can lead to very compact and efficient code. Remember that types (classes) can contain both code and values.</p>
<p class="indent">The first and most common use of templates is to support <em>generic programming</em>, that is, programming focused on the design, implementation, and use of general algorithms. Here, &#8220;general&#8221; means that an algorithm can be designed to accept a wide variety of types as long as they meet the algorithm&#8217;s requirements on its arguments. The template is C++&#8217;s main support for generic programming. Templates provide (compile-time) parametric polymorphism.</p>
<p class="indent">Consider the <span class="EmpStrong">sum()</span> from &#167;<a href="ch05.html#ch05lev1sec3">5.3</a>. It can be invoked for any data structure that supports <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span> so that the range-<span class="EmpStrong">for</span> will work. Such structures include the standard-library <span class="EmpStrong">vector</span>, <span class="EmpStrong">list</span>, and <span class="EmpStrong">map.</span> Furthermore, the element type of the data structure is limited only by its use: it must be a type that we can add to the <span class="EmpStrong">Value</span> argument. Examples are <span class="EmpStrong">int</span>s, <span class="EmpStrong">double</span>s, and <span class="EmpStrong">Matrix</span>es (for any reasonable definition of <span class="EmpStrong">Matrix</span>). We could say that the <span class="EmpStrong">sum()</span> algorithm is generic in two dimensions: the type of the data structure used to store elements (&#8220;the container&#8221;) and the type of elements.</p>
<p class="indent">So, <span class="EmpStrong">sum()</span> requires that its first template argument is some kind of container and its second template argument is some kind of number. We call such requirements <em>concepts</em>. Unfortunately, concepts cannot be expressed directly in C++11. All we can say is that the template argument for <span class="EmpStrong">sum()</span> must be types. There are techniques for checking concepts and proposals for direct language support for concepts [Stroustrup,2013] [Sutton,2012], but both are beyond the scope of this thin book.</p>
<p class="indent">Good, useful concepts are fundamental and are discovered more than they are designed. Examples are integer and floating-point number (as defined even in Classic C), more general mathematical concepts such as field and vector space, and container. They represent the fundamental concepts of a field of application. Identifying and formalizing to the degree necessary for effective generic programming can be a challenge.</p>
<p class="indent">For basic use, consider the concept <em>Regular</em>. A type is regular when it behaves much like an <span class="EmpStrong">int</span> or a <span class="EmpStrong">vector</span>. An object of a regular type</p>
<p class="indenthangingB">&#8226; can be default constructed.</p>
<p class="indenthangingB">&#8226; can be copied (with the usual semantics of copy yielding two objects that are independent and compare equal) using a constructor or an assignment.</p>
<p class="indenthangingB">&#8226; can be compared using <span class="EmpStrong">==</span> and <span class="EmpStrong">!=</span>.</p>
<p class="indenthangingB">&#8226; doesn&#8217;t suffer technical problems from overly clever programming tricks.</p>
<p class="indent">A <span class="EmpStrong">string</span> is another example of a regular type. Like <span class="EmpStrong">int</span>, <span class="EmpStrong">string</span> is also <em>Ordered</em>. That is, two strings can be compared using <span class="EmpStrong">&lt;</span>, <span class="EmpStrong">&lt;=</span>, <span class="EmpStrong">&gt;</span>, and <span class="EmpStrong">&gt;=</span> with the appropriate semantics. Concepts is not just a syntactic notion, it is fundamentally about semantics. For example, don&#8217;t define <span class="EmpStrong">+</span> to divide; that would not match the requirements for any reasonable number.</p>
<div class="heading">
<h3 id="ch05lev1sec5"><a id="page_64"/>5.5. Function Objects</h3>
<p class="noindent">One particularly useful kind of template is the <em>function object</em> (sometimes called a <em>functor</em>), which is used to define objects that can be called like functions. For example:</p>
</div>
<p class="codelink"><a id="p064pro01" href="ch05_images.html#p064pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">class Less_than {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const T val;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">value to compare against</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Less_than(const T&#38; v) :val(v) { }</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bool operator()(const T&#38; x) const { return x&lt;val; } //</span> <span class="EmpItalic">call operator</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The function called <span class="EmpStrong">operator()</span> implements the &#8220;function call,&#8221; &#8220;call,&#8221; or &#8220;application&#8221; operator <span class="EmpStrong">()</span>.</p>
<p class="indent">We can define named variables of type <span class="EmpStrong">Less_than</span> for some argument type:</p>
<p class="codelink"><a id="p064pro02" href="ch05_images.html#p064pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Less_than&lt;int&gt; lti {42};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">lti(i) will compare i to 42 using &lt; (i&lt;42)</span><br/><span class="EmpStrong">Less_than&lt;string&gt; lts {"Backus"}; //</span> <span class="EmpItalic">lts(s) will compare s to "Backus" using &lt; (s&lt;"Backus")</span></p>
<p class="noindent">We can call such an object, just as we call a function:</p>
<p class="codelink"><a id="p064pro03" href="ch05_images.html#p064pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void fct(int n, const string &#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bool b1 = lti(n);</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">true if n&lt;42</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">bool b2 = lts(s);</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">true if s&lt;"Backus"</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Such function objects are widely used as arguments to algorithms. For example, we can count the occurrences of values for which a predicate returns <span class="EmpStrong">true</span>:</p>
<p class="codelink"><a id="p064pro04" href="ch05_images.html#p064pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C, typename P&gt;</span><br/><span class="EmpStrong">int count(const C&#38; c, P pred)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int cnt = 0;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (const auto&#38; x : c)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (pred(x))</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">++cnt;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return cnt;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A <em>predicate</em> is something that we can invoke to return <span class="EmpStrong">true</span> or <span class="EmpStrong">false</span>. For example:</p>
<p class="codelink"><a id="p064pro05" href="ch05_images.html#p064pro05a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(const Vector&lt;int&gt;&#38; vec, const list&lt;string&gt;&#38; lst, int x, const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "number of values less than " &lt;&lt; x</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; ": " &lt;&lt; count(vec,Less_than&lt;int&gt;{x})</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; '\n';</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "number of values less than " &lt;&lt; s</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; ": " &lt;&lt; count(lst,Less_than&lt;string&gt;{s})</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Here, <span class="EmpStrong">Less_than&lt;int&gt;{x}</span> constructs an object for which the call operator compares to the <span class="EmpStrong">int</span> called <span class="EmpStrong">x</span>; <a id="page_65"/><span class="EmpStrong">Less_than&lt;string&gt;{s}</span> constructs an object that compares to the <span class="EmpStrong">string</span> called <span class="EmpStrong">s</span>. The beauty of these function objects is that they carry the value to be compared against with them. We don&#8217;t have to write a separate function for each value (and each type), and we don&#8217;t have to introduce nasty global variables to hold values. Also, for a simple function object like <span class="EmpStrong">Less_than</span> inlining is simple, so that a call of <span class="EmpStrong">Less_than</span> is far more efficient than an indirect function call. The ability to carry data plus their efficiency make function objects particularly useful as arguments to algorithms.</p>
<p class="indent">Function objects used to specify the meaning of key operations of a general algorithm (such as <span class="EmpStrong">Less_than</span> for <span class="EmpStrong">count()</span>) are often referred to as <em>policy objects</em>.</p>
<p class="indent">We have to define <span class="EmpStrong">Less_than</span> separately from its use. That could be seen as inconvenient. Consequently, there is a notation for implicitly generating function objects:</p>
<p class="codelink"><a id="p065pro01" href="ch05_images.html#p065pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(const Vector&lt;int&gt;&#38; vec, const list&lt;string&gt;&#38; lst, int x, const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "number of values less than " &lt;&lt; x</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; ": " &lt;&lt; count(vec,[&#38;](int a){ return a&lt;x; })</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; '\n';</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "number of values less than " &lt;&lt; s</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; ": " &lt;&lt; count(lst,[&#38;](const string&#38; a){ return a&lt;s; })</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">&lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The notation <span class="EmpStrong">[&#38;](int a){ return a&lt;x; }</span> is called a <em>lambda expression</em>. It generates a function object exactly like <span class="EmpStrong">Less_than&lt;int&gt;{x}</span>. The <span class="EmpStrong">[&#38;]</span> is a <em>capture list</em> specifying that local names used (such as <span class="EmpStrong">x</span>) will be accessed through references. Had we wanted to &#8220;capture&#8221; only <span class="EmpStrong">x</span>, we could have said so: <span class="EmpStrong">[&#38;x]</span>. Had we wanted to give the generated object a copy of <span class="EmpStrong">x</span>, we could have said so: <span class="EmpStrong">[=x]</span>. Capture nothing is <span class="EmpStrong">[ ]</span>, capture all local names used by reference is <span class="EmpStrong">[&#38;]</span>, and capture all local names used by value is <span class="EmpStrong">[=]</span>.</p>
<p class="indent">Using lambdas can be convenient and terse, but also obscure. For nontrivial actions (say, more than a simple expression), I prefer to name the operation so as to more clearly state its purpose and to make it available for use in several places in a program.</p>
<p class="indent">In &#167;<a href="ch04.html#ch04lev2sec7">4.5.4</a>, we noted the annoyance of having to write many functions to perform operations on elements of <span class="EmpStrong">vector</span>s of pointers and <span class="EmpStrong">unique_ptr</span>s, such as <span class="EmpStrong">draw_all()</span> and <span class="EmpStrong">rotate_all()</span>. Function objects (in particular, lambdas) can help by allowing us to separate the traversal of the container from the specification of what is to be done with each element.</p>
<p class="indent">First, we need a function that applies an operation to each object pointed to by the elements of a container of pointers:</p>
<p class="codelink"><a id="p065pro02" href="ch05_images.html#p065pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C, typename Oper&gt;</span><br/><span class="EmpStrong">void for_all(C&#38; c, Oper op)</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">assume that C is a container of pointers</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto&#38; x : c)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">op(x);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pass op() a reference to each element pointed to</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Now, we can write a version of <span class="EmpStrong">user()</span> from &#167;<a href="ch04.html#ch04lev1sec5">4.5</a> without writing a set of <span class="EmpStrong">_all</span> functions:</p>
<p class="codelink"><a id="page_66"/><a id="p066pro01" href="ch05_images.html#p066pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void user()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">vector&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">while (cin)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.push_back(read_shape(cin));</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for_all(v,[](Shape&#38; s){ s.draw(); });</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">draw_all()</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for_all(v,[](Shape&#38; s){ s.rotate(45); });</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">rotate_all(45)</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">I pass a reference to <span class="EmpStrong">Shape</span> to a lambda so that the lambda doesn&#8217;t have to care exactly how the objects are stored in the container. In particular, those <span class="EmpStrong">for_all()</span> calls would still work if I changed <span class="EmpStrong">v</span> to a <span class="EmpStrong">vector&lt;Shape</span> <code>*</code><span class="EmpStrong">&gt;</span>.</p>
<div class="heading">
<h3 id="ch05lev1sec6">5.6. Variadic Templates</h3>
<p class="noindent">A template can be defined to accept an arbitrary number of arguments of arbitrary types. Such a template is called a <em>variadic template</em>. For example:</p>
</div>
<p class="codelink"><a id="p066pro02" href="ch05_images.html#p066pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f() { }</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">do nothing</span><br/><br/><span class="EmpStrong">template&lt;typename T, typename... Tail&gt;</span><br/><span class="EmpStrong">void f(T head, Tail... tail)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">g(head);</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">do something to head</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(tail...); //</span> <span class="EmpItalic">try again with tail</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The key to implementing a variadic template is to note that when you pass a list of arguments to it, you can separate the first argument from the rest. Here, we do something to the first argument (the <span class="EmpStrong">head</span>) and then recursively call <span class="EmpStrong">f()</span> with the rest of the arguments (the <span class="EmpStrong">tail</span>). The ellipsis, <span class="EmpStrong">...</span>, is used to indicate &#8220;the rest&#8221; of a list. Eventually, of course, <span class="EmpStrong">tail</span> will become empty and we need a separate function to deal with that.</p>
<p class="indent">We can call this <span class="EmpStrong">f()</span> like this:</p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "first: ";</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(1,2.2,"hello");</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "\nsecond: ";</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">f(0.2,'c',"yuck!",0,1,2);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "\n";</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This would call <span class="EmpStrong">f(1,2.2,"hello")</span>, which will call <span class="EmpStrong">f(2.2,"hello")</span>, which will call <span class="EmpStrong">f("hello")</span>, which will call <span class="EmpStrong">f()</span>. What might the call <span class="EmpStrong">g(head)</span> do? Obviously, in a real program it will do whatever we wanted done to each argument. For example, we could make it write its argument (here, <span class="EmpStrong">head</span>) to output:</p>
<p class="pre"><a id="page_67"/><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">void g(T x)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; x &lt;&lt; " ";</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Given that, the output will be:</p>
<p class="pre"><span class="EmpStrong">first: 1 2.2 hello</span><br/><span class="EmpStrong">second: 0.2 c yuck! 0 1 2</span></p>
<p class="noindent">It seems that <span class="EmpStrong">f()</span> is a simple variant of <span class="EmpStrong">printf()</span> printing arbitrary lists or values &#8211; implemented in three lines of code plus their surrounding declarations.</p>
<p class="indent">The strength of variadic templates (sometimes just called <em>variadics</em>) is that they can accept any arguments you care to give them. The weakness is that the type checking of the interface is a possibly elaborate template program.</p>
<p class="indent">Because of their flexibility, variadic templates are widely used in the standard library.</p>
<div class="heading">
<h3 id="ch05lev1sec7">5.7. Aliases</h3>
<p class="noindent">Surprisingly often, it is useful to introduce a synonym for a type or a template. For example, the standard header <span class="EmpStrong">&lt;cstddef&gt;</span> contains a definition of the alias <span class="EmpStrong">size_t</span>, maybe:</p>
</div>
<p class="pre"><span class="EmpStrong">using size_t = unsigned int;</span></p>
<p class="noindent">The actual type named <span class="EmpStrong">size_t</span> is implementation-dependent, so in another implementation <span class="EmpStrong">size_t</span> may be an <span class="EmpStrong">unsigned long</span>. Having the alias <span class="EmpStrong">size_t</span> allows the programmer to write portable code.</p>
<p class="indent">It is very common for a parameterized type to provide an alias for types related to their template arguments. For example:</p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">using value_type = T;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">In fact, every standard-library container provides <span class="EmpStrong">value_type</span> as the name of its value type (<a href="ch09.html#ch09">Chapter 9</a>). This allows us to write code that will work for every container that follows this convention. For example:</p>
<p class="codelink"><a id="p067pro01" href="ch05_images.html#p067pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename C&gt;</span><br/><span class="EmpStrong">using Element_type = typename C::value_type;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the type of C's elements</span><br/><br/><span class="EmpStrong">template&lt;typename Container&gt;</span><br/><span class="EmpStrong">void algo(Container&#38; c)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector&lt;Element_type&lt;Container&gt;&gt; vec;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">keep results here</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent"><a id="page_68"/>The aliasing mechanism can be used to define a new template by binding some or all template arguments. For example:</p>
<p class="codelink"><a id="p068pro01" href="ch05_images.html#p068pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename Key, typename Value&gt;</span><br/><span class="EmpStrong">class Map {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">template&lt;typename Value&gt;</span><br/><span class="EmpStrong">using String_map = Map&lt;string,Value&gt;;</span><br/><br/><span class="EmpStrong">String_map&lt;int&gt; m;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">m is a Map&lt;string,int&gt;</span></p>
<div class="heading">
<h3 id="ch05lev1sec8">5.8. Template Compilation Model</h3>
<p class="noindent">The type checking provided for templates checks the use of arguments in the template definition rather than against an explicit interface (in a template declaration). This provides a compile-time variant of what is often called <em>duck typing</em> (&#8220;If it walks like a duck and it quacks like a duck, it&#8217;s a duck&#8221;). Or &#8211; using more technical terminology &#8211; we operate on values, and the presence and meaning of an operation depend solely on its operand values. This differs from the alternative view that objects have types, which determine the presence and meaning of operations. Values &#8220;live&#8221; in objects. This is the way objects (e.g., variables) work in C++, and only values that meet an object&#8217;s requirements can be put into it. What is done at compile time using templates does not involve objects, only values.</p>
</div>
<p class="indent">The practical effect of this is that to use a template, its definition (not just its declaration) must be in scope. For example, the standard header <span class="EmpStrong">&lt;vector&gt;</span> holds the definition of <span class="EmpStrong">vector</span>. An unfortunate side effect is that a type error can be found uncomfortably late in the compilation process and can yield spectacularly bad error messages because the compiler found the problem by combining information from several places in the program.</p>
<div class="heading">
<h3 id="ch05lev1sec9">5.9. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapters 20-29 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Use templates to express algorithms that apply to many argument types; &#167;<a href="ch05.html#ch05lev1sec1">5.1</a>.</p>
<p class="ref">[3] Use templates to express containers; &#167;<a href="ch05.html#ch05lev1sec2">5.2</a>.</p>
<p class="ref">[4] Use templates to raise the level of abstraction of code; &#167;<a href="ch05.html#ch05lev1sec2">5.2</a>.</p>
<p class="ref">[5] When defining a template, first design and debug a non-template version; later generalize by adding parameters.</p>
<p class="ref">[6] Templates are type-safe, but checking happens too late; &#167;<a href="ch05.html#ch05lev1sec4">5.4</a>.</p>
<p class="ref">[7] A template can pass argument types without loss of information.</p>
<p class="ref">[8] Use function templates to deduce class template argument types; &#167;<a href="ch05.html#ch05lev1sec3">5.3</a>.</p>
<p class="ref">[9] Templates provide a general mechanism for compile-time programming; &#167;<a href="ch05.html#ch05lev1sec4">5.4</a>.</p>
<p class="ref1"><a id="page_69"/>[10] When designing a template, carefully consider the concepts (requirements) assumed for its template arguments; &#167;<a href="ch05.html#ch05lev1sec4">5.4</a>.</p>
<p class="ref1">[11] Use concepts as a design tool; &#167;<a href="ch05.html#ch05lev1sec4">5.4</a>.</p>
<p class="ref1">[12] Use function objects as arguments to algoritms; &#167;<a href="ch05.html#ch05lev1sec5">5.5</a>.</p>
<p class="ref1">[13] Use a lambda if you need a simple function object in one place only; &#167;<a href="ch05.html#ch05lev1sec5">5.5</a>.</p>
<p class="ref1">[14] A virtual function member cannot be a template member function.</p>
<p class="ref1">[15] Use template aliases to simplify notation and hide implementation details; &#167;<a href="ch05.html#ch05lev1sec7">5.7</a>.</p>
<p class="ref1">[16] Use variadic templates when you need a function that takes a variable number of arguments of a variety of types; &#167;<a href="ch05.html#ch05lev1sec6">5.6</a>.</p>
<p class="ref1">[17] Don&#8217;t use variadic templates for homogeneous argument lists (prefer initializer lists for that); &#167;<a href="ch05.html#ch05lev1sec6">5.6</a>.</p>
<p class="ref1">[18] To use a template, make sure its definition (not just its declaration) is in scope; &#167;<a href="ch05.html#ch05lev1sec8">5.8</a>.</p>
<p class="ref1">[19] Templates offer compile-time &#8220;duck typing&#8221;; &#167;<a href="ch05.html#ch05lev1sec8">5.8</a>.</p>
<p class="ref1">[20] There is no separate compilation of templates: <span class="EmpStrong">#include</span> template definitions in every translation unit that uses them.</p>
</body>
</html>