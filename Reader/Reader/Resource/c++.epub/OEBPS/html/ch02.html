<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2. User-Defined Types</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch02"><a id="page_15"/><span class="pd_blue">2.</span> User-Defined Types</h2>
<p class="blockquote"><em>Don&#8217;t Panic!</em></p>
<p class="attribution"><em>&#8211; Douglas Adams</em></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec2">Structures</a></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec3">Classes</a></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec4">Unions</a></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec5">Enumerations</a></p>
<p class="indenthangingB">&#8226; <a href="ch02.html#ch02lev1sec6">Advice</a></p>
<div class="heading">
<h3 id="ch02lev1sec1">2.1. Introduction</h3>
<p class="noindent">We call the types that can be built from the fundamental types (&#167;<a href="ch01.html#ch01lev1sec5">1.5</a>), the <span class="EmpStrong">const</span> modifier (&#167;<a href="ch01.html#ch01lev1sec7">1.7</a>), and the declarator operators (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>) <em>built-in types</em>. C++&#8217;s set of built-in types and operations is rich, but deliberately low-level. They directly and efficiently reflect the capabilities of conventional computer hardware. However, they don&#8217;t provide the programmer with high-level facilities to conveniently write advanced applications. Instead, C++ augments the built-in types and operations with a sophisticated set of <em>abstraction mechanisms</em> out of which programmers can build such high-level facilities. The C++ abstraction mechanisms are primarily designed to let programmers design and implement their own types, with suitable representations and operations, and for programmers to simply and elegantly use such types. Types built out of the built-in types using C++&#8217;s abstraction mechanisms are called <em>user-defined types</em>. They are referred to as classes and enumerations. Most of this book is devoted to the design, implementation, and use of user-defined types. The rest of this chapter presents the simplest and most fundamental facilities for that. <a href="ch04.html#ch04">Chapters 4</a>-<a href="ch05.html#ch05">5</a> are a more complete description of the abstraction mechanisms and the programming styles they support. <a href="ch06.html#ch06">Chapters 6</a>-<a href="ch13.html#ch13">13</a> present an overview of the standard library, and since the standard library mainly consists of user-defined types, they provide examples of what can be built using the language facilities and programming techniques presented in <a href="ch01.html#ch01">Chapters 1</a>-<a href="ch05.html#ch05">5</a>.</p>
</div>
<div class="heading">
<h3 id="ch02lev1sec2"><a id="page_16"/>2.2. Structures</h3>
<p class="noindent">The first step in building a new type is often to organize the elements it needs into a data structure, a <span class="EmpStrong">struct</span>:</p>
</div>
<p class="codelink"><a id="p016pro01" href="ch02_images.html#p016pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">struct Vector {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">number of elements</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem; //</span> <span class="EmpItalic">pointer to elements</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">This first version of <span class="EmpStrong">Vector</span> consists of an <span class="EmpStrong">int</span> and a <span class="EmpStrong">double</span>*.</p>
<p class="indent">A variable of type <span class="EmpStrong">Vector</span> can be defined like this:</p>
<p class="pre"><span class="EmpStrong">Vector v;</span></p>
<p class="noindent">However, by itself that is not of much use because <span class="EmpStrong">v</span>&#8217;s <span class="EmpStrong">elem</span> pointer doesn&#8217;t point to anything. To be useful, we must give <span class="EmpStrong">v</span> some elements to point to. For example, we can construct a <span class="EmpStrong">Vector</span> like this:</p>
<p class="codelink"><a id="p016pro02" href="ch02_images.html#p016pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void vector_init(Vector&#38; v, int s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.elem = new double[s];</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">allocate an array of s doubles</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">v.sz = s;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">That is, <span class="EmpStrong">v</span>&#8217;s <span class="EmpStrong">elem</span> member gets a pointer produced by the <span class="EmpStrong">new</span> operator and <span class="EmpStrong">v</span>&#8217;s <span class="EmpStrong">sz</span> member gets the number of elements. The <span class="EmpStrong">&#38;</span> in <span class="EmpStrong">Vector&#38;</span> indicates that we pass <span class="EmpStrong">v</span> by non-<span class="EmpStrong">const</span> reference (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>); that way, <span class="EmpStrong">vector_init()</span> can modify the vector passed to it.</p>
<p class="indent">The <span class="EmpStrong">new</span> operator allocates memory from an area called <em>the free store</em> (also known as <em>dynamic memory</em> and <em>heap</em>). Objects allocated on the free store are independent of the scope from which they are created and &#8220;live&#8221; until they are destroyed using the <span class="EmpStrong">delete</span> operator (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>).</p>
<p class="indent">A simple use of <span class="EmpStrong">Vector</span> looks like this:</p>
<p class="codelink"><a id="p016pro03" href="ch02_images.html#p016pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double read_and_sum(int s)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read s integers from cin and return their sum; s is assumed to be positive</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">vector_init(v,s);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">allocate s elements for v</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=s; ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cin&gt;&gt;v.elem[i];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read into elements</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">double sum = 0;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=s; ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sum+=v.elem[i];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">take the sum of the elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return sum;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">There is a long way to go before our <span class="EmpStrong">Vector</span> is as elegant and flexible as the standard-library <span class="EmpStrong">vector</span>. In particular, a user of <span class="EmpStrong">Vector</span> has to know every detail of <span class="EmpStrong">Vector</span>&#8217;s representation. The rest of this chapter and the next two gradually improve <span class="EmpStrong">Vector</span> as an example of language features and techniques. <a href="ch09.html#ch09">Chapter 9</a> presents the standard-library <span class="EmpStrong">vector</span>, which contains many nice improvements.</p>
<p class="indent"><a id="page_17"/>I use <span class="EmpStrong">vector</span> and other standard-library components as examples</p>
<p class="indenthangingB">&#8226; to illustrate language features and design techniques, and</p>
<p class="indenthangingB">&#8226; to help you learn and use the standard-library components.</p>
<p class="noindent">Don&#8217;t reinvent standard-library components, such as <span class="EmpStrong">vector</span> and <span class="EmpStrong">string</span>; use them.</p>
<p class="indent">We use <span class="EmpStrong">.</span> (dot) to access <span class="EmpStrong">struct</span> members through a name (and through a reference) and <span class="EmpStrong">-&gt;</span> to access <span class="EmpStrong">struct</span> members through a pointer. For example:</p>
<p class="codelink"><a id="p017pro01" href="ch02_images.html#p017pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(Vector v, Vector&#38; rv, Vector* pv)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i1 = v.sz;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">access through name</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i2 = rv.sz;</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">access through reference</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i4 = pv-&gt;sz;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">access through pointer</span><br/><span class="EmpStrong">}</span></p>
<div class="heading">
<h3 id="ch02lev1sec3">2.3. Classes</h3>
<p class="noindent">Having the data specified separately from the operations on it has advantages, such as the ability to use the data in arbitrary ways. However, a tighter connection between the representation and the operations is needed for a user-defined type to have all the properties expected of a &#8220;real type.&#8221; In particular, we often want to keep the representation inaccessible to users, so as to ease use, guarantee consistent use of the data, and allow us to later improve the representation. To do that we have to distinguish between the interface to a type (to be used by all) and its implementation (which has access to the otherwise inaccessible data). The language mechanism for that is called a <em>class</em>. A class is defined to have a set of <em>members</em>, which can be data, function, or type members. The interface is defined by the <span class="EmpStrong">public</span> members of a class, and <span class="EmpStrong">private</span> members are accessible only through that interface. For example:</p>
</div>
<p class="codelink"><a id="p017pro02" href="ch02_images.html#p017pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">class Vector {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector(int s) :elem{new double[s]}, sz{s} { }</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">construct a Vector</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double&#38; operator[](int i) { return elem[i]; }</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">element access: subscripting</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size() { return sz; }</span><br/><span class="EmpStrong">private:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">double* elem;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">pointer to the elements</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int sz;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">the number of elements</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Given that, we can define a variable of our new type <span class="EmpStrong">Vector</span>:</p>
<p class="codelink"><a id="p017pro03" href="ch02_images.html#p017pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Vector v(6); &#160;&#160;//</span> <span class="EmpItalic">a Vector with 6 elements</span></p>
<p class="noindent">We can illustrate a <span class="EmpStrong">Vector</span> object graphically:</p>
<div class="image"><img src="graphics/017fig01.jpg" alt="Image"/></div>
<p class="noindent"><a id="page_18"/>Basically, the <span class="EmpStrong">Vector</span> object is a &#8220;handle&#8221; containing a pointer to the elements (<span class="EmpStrong">elem</span>) plus the number of elements (<span class="EmpStrong">sz</span>). The number of elements (6 in the example) can vary from <span class="EmpStrong">Vector</span> object to <span class="EmpStrong">Vector</span> object, and a <span class="EmpStrong">Vector</span> object can have a different number of elements at different times (&#167;<a href="ch04.html#ch04lev2sec3">4.2.3</a>). However, the <span class="EmpStrong">Vector</span> object itself is always the same size. This is the basic technique for handling varying amounts of information in C++: a fixed-size handle referring to a variable amount of data &#8220;elsewhere&#8221; (e.g., on the free store allocated by <span class="EmpStrong">new</span>; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>). How to design and use such objects is the main topic of <a href="ch04.html#ch04">Chapter 4</a>.</p>
<p class="indent">Here, the representation of a <span class="EmpStrong">Vector</span> (the members <span class="EmpStrong">elem</span> and <span class="EmpStrong">sz</span>) is accessible only through the interface provided by the <span class="EmpStrong">public</span> members: <span class="EmpStrong">Vector()</span>, <span class="EmpStrong">operator[]()</span>, and <span class="EmpStrong">size()</span>. The <span class="EmpStrong">read_and_sum()</span> example from &#167;<a href="ch02.html#ch02lev1sec2">2.2</a> simplifies to:</p>
<p class="codelink"><a id="p018pro01" href="ch02_images.html#p018pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">double read_and_sum(int s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">Vector v(s);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">make a vector of s elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=v.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cin&gt;&gt;v[i];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">read into elements</span><br/><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">double sum = 0;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i=0; i!=v.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">sum+=v[i];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">take the sum of the elements</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">return sum;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">A &#8220;function&#8221; with the same name as its class is called a <em>constructor</em>, that is, a function used to construct objects of a class. So, the constructor, <span class="EmpStrong">Vector()</span>, replaces <span class="EmpStrong">vector_init()</span> from &#167;<a href="ch02.html#ch02lev1sec2">2.2</a>. Unlike an ordinary function, a constructor is guaranteed to be used to initialize objects of its class. Thus, defining a constructor eliminates the problem of uninitialized variables for a class.</p>
<p class="indent"><span class="EmpStrong">Vector(int)</span> defines how objects of type <span class="EmpStrong">Vector</span> are constructed. In particular, it states that it needs an integer to do that. That integer is used as the number of elements. The constructor initializes the <span class="EmpStrong">Vector</span> members using a member initializer list:</p>
<p class="indent"><span class="EmpStrong">:elem{new double[s]}, sz{s}</span></p>
<p class="noindent">That is, we first initialize <span class="EmpStrong">elem</span> with a pointer to <span class="EmpStrong">s</span> elements of type <span class="EmpStrong">double</span> obtained from the free store. Then, we initialize <span class="EmpStrong">sz</span> to <span class="EmpStrong">s</span>.</p>
<p class="indent">Access to elements is provided by a subscript function, called <span class="EmpStrong">operator[]</span>. It returns a reference to the appropriate element (a <span class="EmpStrong">double&#38;</span>).</p>
<p class="indent">The <span class="EmpStrong">size()</span> function is supplied to give users the number of elements.</p>
<p class="indent">Obviously, error handling is completely missing, but we&#8217;ll return to that in &#167;<a href="ch03.html#ch03lev1sec4">3.4</a>. Similarly, we did not provide a mechanism to &#8220;give back&#8221; the array of <span class="EmpStrong">double</span>s acquired by <span class="EmpStrong">new</span>; &#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a> shows how to use a destructor to elegantly do that.</p>
<p class="indent">There is no fundamental difference between a <span class="EmpStrong">struct</span> and a <span class="EmpStrong">class</span>; a <span class="EmpStrong">struct</span> is simply a <span class="EmpStrong">class</span> with members <span class="EmpStrong">public</span> by default. For example, you can define constructors and other member functions for a <span class="EmpStrong">struct</span>.</p>
<div class="heading">
<h3 id="ch02lev1sec4"><a id="page_19"/>2.4. Unions</h3>
<p class="noindent">A <span class="EmpStrong">union</span> is a <span class="EmpStrong">struct</span> in which all members are allocated at the same address so that the <span class="EmpStrong">union</span> occupies only as much space as its largest member. Naturally, a <span class="EmpStrong">union</span> can hold a value for only one member at a time. For example, consider a symbol table entry that holds a name and a value:</p>
</div>
<p class="codelink"><a id="p019pro01" href="ch02_images.html#p019pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">enum Type { str, num };</span><br/><br/><span class="EmpStrong">struct Entry {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">char* name;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Type t;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">char* s; //</span> <span class="EmpItalic">use s if t==str</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i;</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use i if t==num</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">void f(Entry* p)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (p-&gt;t == str)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; p-&gt;s;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The members <span class="EmpStrong">s</span> and <span class="EmpStrong">i</span> can never be used at the same time, so space is wasted. It can be easily recovered by specifying that both should be members of a <span class="EmpStrong">union</span>, like this:</p>
<p class="pre"><span class="EmpStrong">union Value {</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">char* s;</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">int i;</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The language doesn&#8217;t keep track of which kind of value is held by a <span class="EmpStrong">union</span>, so the programmer must do that:</p>
<p class="codelink"><a id="p019pro02" href="ch02_images.html#p019pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">struct Entry {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">char* name;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Type t;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">Value v; //</span> <span class="EmpItalic">use v.s if t==str; use v.i if t==num</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">void f(Entry* p)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (p-&gt;t == str)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; p-&gt;v.s;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Maintaining the correspondence between a <em>type field</em> (here, <span class="EmpStrong">t</span>) and the type held in a <span class="EmpStrong">union</span> is error-prone. To avoid errors, one can encapsulate a <span class="EmpStrong">union</span> so that the correspondence between a type field and access to the <span class="EmpStrong">union</span> members is guaranteed. At the application level, abstractions relying on such <em>tagged unions</em> are common and useful, but use of &#8220;naked&#8221; <span class="EmpStrong">union</span>s is best minimized.</p>
<div class="heading">
<h3 id="ch02lev1sec5"><a id="page_20"/>2.5. Enumerations</h3>
<p class="noindent">In addition to classes, C++ supports a simple form of user-defined type for which we can enumerate the values:</p>
</div>
<p class="codelink"><a id="p020pro01" href="ch02_images.html#p020pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">enum class Color { red, blue, green };</span><br/><span class="EmpStrong">enum class Traffic_light { green, yellow, red };</span><br/><br/><span class="EmpStrong">Color col = Color::red;</span><br/><span class="EmpStrong">Traffic_light light = Traffic_light::red;</span></p>
<p class="noindent">Note that enumerators (e.g., <span class="EmpStrong">red</span>) are in the scope of their <span class="EmpStrong">enum class</span>, so that they can be used repeatedly in different <span class="EmpStrong">enum class</span>es without confusion. For example, <span class="EmpStrong">Color::red</span> is <span class="EmpStrong">Color</span>&#8217;s <span class="EmpStrong">red</span> which is different from <span class="EmpStrong">Traffic_light::red</span>.</p>
<p class="indent">Enumerations are used to represent small sets of integer values. They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used.</p>
<p class="indent">The <span class="EmpStrong">class</span> after the <span class="EmpStrong">enum</span> specifies that an enumeration is strongly typed and that its enumerators are scoped. Being separate types, <span class="EmpStrong">enum class</span>es help prevent accidental misuses of constants. In particular, we cannot mix <span class="EmpStrong">Traffic_light</span> and <span class="EmpStrong">Color</span> values:</p>
<p class="codelink"><a id="p020pro02" href="ch02_images.html#p020pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Color x = red;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">error: which red?</span><br/><span class="EmpStrong">Color y = Traffic_light::red;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">error: that red is not a Color</span><br/><span class="EmpStrong">Color z = Color::red;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">OK</span></p>
<p class="noindent">Similarly, we cannot implicitly mix <span class="EmpStrong">Color</span> and integer values:</p>
<p class="codelink"><a id="p020pro03" href="ch02_images.html#p020pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int i = Color::red;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">error: Color::red is not an int</span><br/><span class="EmpStrong">Color c = 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//</span> <span class="EmpItalic">error: 2 is not a Color</span></p>
<p class="noindent">By default, an <span class="EmpStrong">enum class</span> has only assignment, initialization, and comparisons (e.g., <span class="EmpStrong">==</span> and <span class="EmpStrong">&lt;</span>; &#167;<a href="ch01.html#ch01lev1sec5">1.5</a>) defined. However, an enumeration is a user-defined type so we can define operators for it:</p>
<p class="codelink"><a id="p020pro04" href="ch02_images.html#p020pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">Traffic_light&#38; operator++(Traffic_light&#38; t)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">// prefix increment: ++</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">switch (t) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case Traffic_light::green:&#160;&#160;&#160;&#160;return t=Traffic_light::yellow;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case Traffic_light::yellow:&#160;&#160;&#160;return t=Traffic_light::red;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case Traffic_light::red:&#160;&#160;&#160;&#160;&#160;&#160;return t=Traffic_light::green;</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span><br/><br/><span class="EmpStrong">Traffic_light next = ++light;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">next becomes Traffic_light::green</span></p>
<p class="noindent">If you don&#8217;t want to explicitly qualify enumerator names and want enumerator values to be <span class="EmpStrong">int</span>s (without the need for an explicit conversion), you can remove the <span class="EmpStrong">class</span> from <span class="EmpStrong">enum class</span> to get a &#8220;plain&#8221; <span class="EmpStrong">enum</span>. The enumerators from a &#8220;plain&#8221; <span class="EmpStrong">enum</span> are entered into the same scope as the name of their <span class="EmpStrong">enum</span> and implicitly converts to their integer value. For example:</p>
<p class="codelink"><a id="page_21"/><a id="p021pro01" href="ch02_images.html#p021pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">enum Color { red, green, blue };</span><br/><span class="EmpStrong">int col = green;</span></p>
<p class="noindent">Here <span class="EmpStrong">col</span> gets the value <span class="EmpStrong">1</span>. By default, the integer values of enumerators starts with <span class="EmpStrong">0</span> and increases by one for each additional enumerator. The &#8220;plain&#8221; <span class="EmpStrong">enum</span>s have been in C++ (and C) from the earliest days, so even though they are less well behaved, they are common in current code.</p>
<div class="heading">
<h3 id="ch02lev1sec6">2.6. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in <a href="ch08.html#ch08">Chapter 8</a> of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] Organize related data into structures (<span class="EmpStrong">struct</span>s or <span class="EmpStrong">class</span>es); &#167;<a href="ch02.html#ch02lev1sec2">2.2</a>.</p>
<p class="ref">[3] Represent the distinction between an interface and an implementation using a <span class="EmpStrong">class</span>; &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>.</p>
<p class="ref">[4] A <span class="EmpStrong">struct</span> is simply a <span class="EmpStrong">class</span> with its members <span class="EmpStrong">public</span> by default; &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>.</p>
<p class="ref">[5] Define constructors to guarantee and simplify initialization of <span class="EmpStrong">class</span>es; &#167;<a href="ch02.html#ch02lev1sec3">2.3</a>.</p>
<p class="ref">[6] Avoid &#8220;naked&#8221; <span class="EmpStrong">union</span>s; wrap them in a class together with a type field; &#167;<a href="ch02.html#ch02lev1sec4">2.4</a>.</p>
<p class="ref">[7] Use enumerations to represent sets of named constants; &#167;<a href="ch02.html#ch02lev1sec5">2.5</a>.</p>
<p class="ref">[8] Prefer <span class="EmpStrong">enum classes</span> over &#8220;plain&#8221; <span class="EmpStrong">enum</span>s to minimize surprises; &#167;<a href="ch02.html#ch02lev1sec5">2.5</a>.</p>
<p class="ref">[9] Define operations on enumerations for safe and simple use; &#167;<a href="ch02.html#ch02lev1sec5">2.5</a>.</p>
</body>
</html>
