<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9. Containers</title>
<link rel="stylesheet" type="text/css" href="9780133549003.css"/>
</head>
<body>
<h2 id="ch09"><a id="page_95"/><span class="pd_blue">9.</span> Containers</h2>
<p class="blockquote"><em>It was new.<br/>It was singular.</em><br/><em>It was simple.<br/>It must succeed!</em></p>
<p class="attribution"><em>&#8211; H. Nelson</em></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec1">Introduction</a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec2"><span class="EmpStrong">vector</span></a></p>
<p class="indenthangingBP"><a href="ch09.html#ch09lev2sec1">Elements</a>; <a href="ch09.html#ch09lev2sec2">Range Checking</a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec3"><span class="EmpStrong">list</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec4"><span class="EmpStrong">map</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec5"><span class="EmpStrong">unordered_map</span></a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec6">Container Overview</a></p>
<p class="indenthangingB">&#8226; <a href="ch09.html#ch09lev1sec7">Advice</a></p>
<div class="heading">
<h3 id="ch09lev1sec1">9.1. Introduction</h3>
<p class="noindent">Most computing involves creating collections of values and then manipulating such collections. Reading characters into a <span class="EmpStrong">string</span> and printing out the <span class="EmpStrong">string</span> is a simple example. A class with the main purpose of holding objects is commonly called a <em>container</em>. Providing suitable containers for a given task and supporting them with useful fundamental operations are important steps in the construction of any program.</p>
</div>
<p class="indent">To illustrate the standard-library containers, consider a simple program for keeping names and telephone numbers. This is the kind of program for which different approaches appear &#8220;simple and obvious&#8221; to people of different backgrounds. The <span class="EmpStrong">Entry</span> class from &#167;<a href="ch08.html#ch08lev1sec5">8.5</a> can be used to hold a simple phone book entry. Here, we deliberately ignore many real-world complexities, such as the fact that many phone numbers do not have a simple representation as a 32-bit <span class="EmpStrong">int</span>.</p>
<div class="heading">
<h3 id="ch09lev1sec2"><a id="page_96"/>9.2. <span class="EmpStrong">vector</span></h3>
<p class="noindent">The most useful standard-library container is <span class="EmpStrong">vector</span>. A <span class="EmpStrong">vector</span> is a sequence of elements of a given type. The elements are stored contiguously in memory. A typical implementation of <span class="EmpStrong">vector</span> (&#167;<a href="ch04.html#ch04lev2sec2">4.2.2</a>, &#167;<a href="ch04.html#ch04lev1sec6">4.6</a>) will consist of a handle holding pointers to the first element, one-past-the-last element, and one-past-the-last allocated space (&#167;<a href="ch10.html#ch10lev1sec1">10.1</a>) (or the equivalent information represented as a pointer plus offsets):</p>
</div>
<div class="image"><img src="graphics/096fig01.jpg" alt="Image"/></div>
<p class="noindent">In addition, it holds an allocator (here, <span class="EmpStrong">alloc</span>), from which the <span class="EmpStrong">vector</span> can acquire memory for its elements. The default allocator uses <span class="EmpStrong">new</span> and <span class="EmpStrong">delete</span> to acquire and release memory.</p>
<p class="indent">We can initialize a <span class="EmpStrong">vector</span> with a set of values of its element type:</p>
<p class="codelink"><a id="p096pro01" href="ch09_images.html#p096pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">vector&lt;Entry&gt;phone_book = {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"David Hume",123456},</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Karl Popper",234567},</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Bertrand Arthur William Russell",345678}</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">Elements can be accessed through subscripting:</p>
<p class="codelink"><a id="p096pro02" href="ch09_images.html#p096pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void print_book(const vector&lt;Entry&gt;&#38; book)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (int i = 0; i!=book.size(); ++i)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; book[i] &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">As usual, indexing starts at <span class="EmpStrong">0</span> so that <span class="EmpStrong">book[0]</span> holds the entry for <span class="EmpStrong">David Hume</span>. The <span class="EmpStrong">vector</span> member function <span class="EmpStrong">size()</span> gives the number of elements.</p>
<p class="indent">The elements of a <span class="EmpStrong">vector</span> constitute a range, so we can use a range-<span class="EmpStrong">for</span> loop (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>):</p>
<p class="codelink"><a id="p096pro03" href="ch09_images.html#p096pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void print_book(const vector&lt;Entry&gt;&#38; book)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (const auto&#38; x : book)</span>&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">for "auto" see &#167;1.5</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; x &lt;&lt; '\n';</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">When we define a <span class="EmpStrong">vector</span>, we give it an initial size (initial number of elements):</p>
<p class="codelink"><a id="p096pro04" href="ch09_images.html#p096pro04a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">vector&lt;int&gt; v1 = {1, 2, 3, 4};</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">size is 4</span><br/><span class="EmpStrong">vector&lt;string&gt; v2;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">size is 0</span><br/><span class="EmpStrong">vector&lt;Shape*&gt; v3(23);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">size is 23; initial element value: nullptr</span><br/><span class="EmpStrong">vector&lt;double&gt; v4(32,9.9);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">size is 32; initial element value: 9.9</span></p>
<p class="noindent">An explicit size is enclosed in ordinary parentheses, for example, <span class="EmpStrong">(23)</span>, and by default the elements <a id="page_97"/>are initialized to the element type&#8217;s default value (e.g., <span class="EmpStrong">nullptr</span> for pointers and <span class="EmpStrong">0</span> for numbers). If you don&#8217;t want the default value, you can specify one as a second argument (e.g., <span class="EmpStrong">9.9</span> for the <span class="EmpStrong">32</span> elements of <span class="EmpStrong">v4</span>).</p>
<p class="indent">The initial size can be changed. One of the most useful operations on a <span class="EmpStrong">vector</span> is <span class="EmpStrong">push_back()</span>, which adds a new element at the end of a <span class="EmpStrong">vector</span>, increasing its size by one. For example:</p>
<p class="codelink"><a id="p097pro01" href="ch09_images.html#p097pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void input()</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (Entry e; cin&gt;&gt;e;)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">phone_book.push_back(e);</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This reads <span class="EmpStrong">Entry</span>s from the standard input into <span class="EmpStrong">phone_book</span> until either the end-of-input (e.g., the end of a file) is reached or the input operation encounters a format error.</p>
<p class="indent">The standard-library <span class="EmpStrong">vector</span> is implemented so that growing a <span class="EmpStrong">vector</span> by repeated <span class="EmpStrong">push_back()</span>s is efficient. To show how, consider an elaboration of the simple <span class="EmpStrong">Vector</span> from (<a href="ch04.html#ch04">Chapter 4</a> and <a href="ch05.html#ch05">Chapter 5</a>) using the representation indicated in the diagram above:</p>
<p class="codelink"><a id="p097pro02" href="ch09_images.html#p097pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">class Vector {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T* elem;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pointer to first element</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T* space;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pointer to first unused (and uninitialized) slot</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T* last;</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">pointer to last slot</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int size();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">number of elements (space-elem)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int capacity();</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">number of slots available for elements (last-elem)</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void reserve(int newsz);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">increase capacity() to newsz</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void push_back(const T&#38; t);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">copy t into Vector</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">void push_back(T&#38;&#38; t);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">move t into Vector</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">The standard-libray <span class="EmpStrong">vector</span> has members <span class="EmpStrong">capacity()</span>, <span class="EmpStrong">reserve()</span>, and <span class="EmpStrong">push_back()</span>. The <span class="EmpStrong">reserve()</span> is used by users of <span class="EmpStrong">vector</span> and other <span class="EmpStrong">vector</span> members to make room for more elements. It may have to allocate new memory and when it does it moves the elements to the new allocation.</p>
<p class="indent">Given <span class="EmpStrong">capacity()</span> and <span class="EmpStrong">reserve()</span>, implementing <span class="EmpStrong">push_back()</span> is trivial:</p>
<p class="codelink"><a id="p097pro03" href="ch09_images.html#p097pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">void Vector&lt;T&gt;::push_back(const T&#38; t)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (capacity()&lt;size()+1)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">make sure we have space for t</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">reserve(size()==0?8:2*size());</span>&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">double the capacity</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">new(space)T{t};</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">initialize*space to t</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">++space;</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">Now allocation and relocation of elements happens only infrequently. I used to use <span class="EmpStrong">reserve()</span> to try to improve performance, but that turned out to be a waste of effort: The heuristic used by <span class="EmpStrong">vector</span> is <a id="page_98"/>better than my guesses, so now I only use <span class="EmpStrong">reserve()</span> to avoid rellocation of elements when I want to use pointers to elements.</p>
<p class="indent">A <span class="EmpStrong">vector</span> can be copied in assignments and initializations. For example:</p>
<p class="codelink"><a id="p098pro01" href="ch09_images.html#p098pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">vector&lt;Entry&gt; book2 = phone_book;</span></p>
<p class="noindent">Copying and moving of <span class="EmpStrong">vector</span>s are implemented by constructors and assignment operators as described in &#167;<a href="ch04.html#ch04lev1sec6">4.6</a>. Assigning a <span class="EmpStrong">vector</span> involves copying its elements. Thus, after the initialization of <span class="EmpStrong">book2</span>, <span class="EmpStrong">book2</span> and <span class="EmpStrong">phone_book</span> hold separate copies of every <span class="EmpStrong">Entry</span> in the phone book. When a <span class="EmpStrong">vector</span> holds many elements, such innocent-looking assignments and initializations can be expensive. Where copying is undesirable, references or pointers (&#167;<a href="ch01.html#ch01lev1sec8">1.8</a>) or move operations (&#167;<a href="ch04.html#ch04lev2sec9">4.6.2</a>) should be used.</p>
<p class="indent">The standard-library <span class="EmpStrong">vector</span> is very flexible and efficient. Use it as your default container; that is, use it unless you have a solid reason to use some other container. If your reason is &#8220;efficiency,&#8221; measure. Our intuition is most fallible in matters of the performance of container uses.</p>
<div class="heading">
<h4 id="ch09lev2sec1">9.2.1. Elements</h4>
<p class="noindent">Like all standard-library containers, <span class="EmpStrong">vector</span> is a container of elements of some type <span class="EmpStrong">T</span>, that is, a <span class="EmpStrong">vector&lt;T&gt;</span>. Just about any type qualifies as an element type: built-in numeric types (such as <span class="EmpStrong">char</span>, <span class="EmpStrong">int</span>, and <span class="EmpStrong">double</span>), user-defined types (such as <span class="EmpStrong">string</span>, <span class="EmpStrong">Entry</span>, <span class="EmpStrong">list&lt;int&gt;</span>, and <span class="EmpStrong">Matrix&lt;double, 2&gt;</span>), and pointers (such as <span class="EmpStrong">const char</span> <code>*</code>, <span class="EmpStrong">Shape</span> <code>*</code>, and <span class="EmpStrong">double</span> <code>*</code>). When you insert a new element, its value is copied into the container. For example, when you put an integer with the value <span class="EmpStrong">7</span> into a container, the resulting element really has the value <span class="EmpStrong">7</span>. The element is not a reference or a pointer to some object containing <span class="EmpStrong">7</span>. This makes for nice, compact containers with fast access. For people who care about memory sizes and run-time performance this is critical.</p>
</div>
<p class="indent">If you have a class hierachy (&#167;<a href="ch04.html#ch04lev1sec5">4.5</a>) that relies on <span class="EmpStrong">virtual</span> functions to get polymorphic behavior, do not store objects directly in a container. Instead store a pointer (or a smart pointer; &#167;<a href="ch11.html#ch11lev2sec1">11.2.1</a>). For example:</p>
<p class="codelink"><a id="p098pro02" href="ch09_images.html#p098pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">vector&lt;Shape&gt; vs;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">No, don't - there is no room for a Circle or a Smiley</span><br/><span class="EmpStrong">vector&lt;Shape*&gt;vps;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">better, but see &#167;4.5.4</span><br/><span class="EmpStrong">vector&lt;unique_ptr&lt;Shape&gt;&gt; vups;</span>&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">OK</span></p>
<div class="heading">
<h4 id="ch09lev2sec2">9.2.2. Range Checking</h4>
<p class="noindent">The standard-library <span class="EmpStrong">vector</span> does not guarantee range checking. For example:</p>
</div>
<p class="codelink"><a id="p098pro03" href="ch09_images.html#p098pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void silly(vector&lt;Entry&gt;&#38; book)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int i = book[book.size()].number;</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">book.size() is out of range</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">That initialization is likely to place some random value in <span class="EmpStrong">i</span> rather than giving an error. This is undesirable, and out-of-range errors are a common problem. Consequently, I often use a simple range-checking adaptation of <span class="EmpStrong">vector</span>:</p>
<p class="codelink"><a id="page_99"/><a id="p099pro01" href="ch09_images.html#p099pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">template&lt;typename T&gt;</span><br/><span class="EmpStrong">class Vec : public std::vector&lt;T&gt; {</span><br/><span class="EmpStrong">public:</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">using vector&lt;T&gt;::vector;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use the constructors from vector (under the name Vec)</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">T&#38; operator[](int i)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">range check</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{ return vector&lt;T&gt;::at(i); }</span><br/><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">const T&#38; operator[](int i) const</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">range check const objects; &#167;4.2.1</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{ return vector&lt;T&gt;::at(i); }</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent"><span class="EmpStrong">Vec</span> inherits everything from <span class="EmpStrong">vector</span> except for the subscript operations that it redefines to do range checking. The <span class="EmpStrong">at()</span> operation is a <span class="EmpStrong">vector</span> subscript operation that throws an exception of type <span class="EmpStrong">out_of_range</span> if its argument is out of the <span class="EmpStrong">vector</span>&#8217;s range (&#167;<a href="ch03.html#ch03lev2sec1">3.4.1</a>).</p>
<p class="indent">For <span class="EmpStrong">Vec</span>, an out-of-range access will throw an exception that the user can catch. For example:</p>
<p class="codelink"><a id="p099pro02" href="ch09_images.html#p099pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void checked(Vec&lt;Entry&gt;&#38; book)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">book[book.size()] = {"Joe",999999};</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">will throw an exception</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">catch (out_of_range) {</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cout &lt;&lt; "range error\n";</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The exception will be thrown, and then caught (&#167;<a href="ch03.html#ch03lev2sec1">3.4.1</a>). If the user doesn&#8217;t catch an exception, the program will terminate in a well-defined manner rather than proceeding or failing in an undefined manner. One way to minimize surprises from uncaught exceptions is to use a <span class="EmpStrong">main()</span> with a <span class="EmpStrong">try-</span> block as its body. For example:</p>
<p class="codelink"><a id="p099pro03" href="ch09_images.html#p099pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int main()</span><br/><span class="EmpStrong">try {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">your code</span><br/><span class="EmpStrong">}</span><br/><span class="EmpStrong">catch (out_of_range) {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "range error\n";</span><br/><span class="EmpStrong">}</span><br/><span class="EmpStrong">catch (...) {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">cerr &lt;&lt; "unknown exception thrown\n";</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">This provides default exception handlers so that if we fail to catch some exception, an error message is printed on the standard error-diagnostic output stream <span class="EmpStrong">cerr</span> (&#167;<a href="ch08.html#ch08lev1sec2">8.2</a>).</p>
<p class="indent">Some implementations save you the bother of defining <span class="EmpStrong">Vec</span> (or equivalent) by providing a range-checked version of <span class="EmpStrong">vector</span> (e.g., as a compiler option).</p>
<div class="heading">
<h3 id="ch09lev1sec3"><a id="page_100"/>9.3. <span class="EmpStrong">list</span></h3>
<p class="noindent">The standard library offers a doubly-linked list called <span class="EmpStrong">list</span>:</p>
</div>
<div class="image"><img src="graphics/100fig01.jpg" alt="Image"/></div>
<p class="noindent">We use a <span class="EmpStrong">list</span> for sequences where we want to insert and delete elements without moving other elements. Insertion and deletion of phone book entries could be common, so a <span class="EmpStrong">list</span> could be appropriate for representing a simple phone book. For example:</p>
<p class="codelink"><a id="p100pro01" href="ch09_images.html#p100pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">list&lt;Entry&gt; phone_book = {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"David Hume",123456},</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Karl Popper",234567},</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Bertrand Arthur William Russell",345678}</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">When we use a linked list, we tend not to access elements using subscripting the way we commonly do for vectors. Instead, we might search the list looking for an element with a given value. To do this, we take advantage of the fact that a <span class="EmpStrong">list</span> is a sequence as described in <a href="ch10.html#ch10">Chapter 10</a>:</p>
<p class="codelink"><a id="p100pro02" href="ch09_images.html#p100pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int get_number(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (const auto&#38; x : phone_book)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (x.name==s)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return x.number;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return 0;</span>&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">use 0 to represent "number not found"</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The search for <span class="EmpStrong">s</span> starts at the beginning of the list and proceeds until <span class="EmpStrong">s</span> is found or the end of <span class="EmpStrong">phone_book</span> is reached.</p>
<p class="indent">Sometimes, we need to identify an element in a <span class="EmpStrong">list</span>. For example, we may want to delete it or insert a new entry before it. To do that we use an <em>iterator</em>: a <span class="EmpStrong">list</span> iterator identifies an element of a <span class="EmpStrong">list</span> and can be used to iterate through a <span class="EmpStrong">list</span> (hence its name). Every standard-library container provides the functions <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span>, which return an iterator to the first and to one-past-the-last element, respectively (<a href="ch10.html#ch10">Chapter 10</a>). Using iterators explicitly, we can &#8211; less elegantly &#8211; write the <span class="EmpStrong">get_number()</span> function like this:</p>
<p class="codelink"><a id="p100pro03" href="ch09_images.html#p100pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int get_number(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for (auto p = phone_book.begin(); p!=phone_book.end(); ++p)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if (p-&gt;name==s)</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return p-&gt;number;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return 0; //</span> <span class="EmpItalic">use 0 to represent "number not found"</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">In fact, this is roughly the way the terser and less error-prone range-<span class="EmpStrong">for</span> loop is implemented by the <a id="page_101"/>compiler. Given an iterator <span class="EmpStrong">p</span>, <code>*</code><span class="EmpStrong">p</span> is the element to which it refers, <span class="EmpStrong">++p</span> advances <span class="EmpStrong">p</span> to refer to the next element, and when <span class="EmpStrong">p</span> refers to a class with a member <span class="EmpStrong">m</span>, then <span class="EmpStrong">p-&gt;m</span> is equivalent to <span class="EmpStrong">(</span> <code>*</code><span class="EmpStrong">p).m</span>.</p>
<p class="indent">Adding elements to a <span class="EmpStrong">list</span> and removing elements from a <span class="EmpStrong">list</span> is easy:</p>
<p class="codelink"><a id="p101pro01" href="ch09_images.html#p101pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">void f(const Entry&#38; ee, list&lt;Entry&gt;::iterator p, list&lt;Entry&gt;::iterator q)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">phone_book.insert(p,ee);</span>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">add ee before the element referred to by p</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">phone_book.erase(q);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">remove the element referred to by q</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">For a <span class="EmpStrong">list</span>, <span class="EmpStrong">insert(p,elem)</span> inserts an element with a copy of the value <span class="EmpStrong">elem</span> before the element pointed to by <span class="EmpStrong">p</span>. Similarly, <span class="EmpStrong">erase(p)</span> removes the element pointed to by <span class="EmpStrong">p</span> and destroys it. In both cases, <span class="EmpStrong">p</span> may be an iterator pointing one-beyond-the-end of the <span class="EmpStrong">List</span>.</p>
<p class="indent">These <span class="EmpStrong">list</span> examples could be written identically using <span class="EmpStrong">vector</span> and (surprisingly, unless you understand machine architecture) perform better with a small <span class="EmpStrong">vector</span> than with a small <span class="EmpStrong">list</span>. When all we want is a sequence of elements, we have a choice between using a <span class="EmpStrong">vector</span> and a <span class="EmpStrong">list</span>. Unless you have a reason not to, use a <span class="EmpStrong">vector</span>. A <span class="EmpStrong">vector</span> performs better for traversal (e.g., <span class="EmpStrong">find()</span> and <span class="EmpStrong">count()</span>) and for sorting and searching (e.g., <span class="EmpStrong">sort()</span> and <span class="EmpStrong">binary_search()</span>).</p>
<div class="heading">
<h3 id="ch09lev1sec4">9.4. <span class="EmpStrong">map</span></h3>
<p class="noindent">Writing code to look up a name in a list of <em>(name,number)</em> pairs is quite tedious. In addition, a linear search is inefficient for all but the shortest lists. The standard library offers a search tree (a red-black tree) called <span class="EmpStrong">map</span>:</p>
</div>
<div class="image"><img src="graphics/101fig01.jpg" alt="Image"/></div>
<p class="noindent">In other contexts, a <span class="EmpStrong">map</span> is known as an associative array or a dictionary. It is implemented as a balanced binary tree.</p>
<p class="indent">The standard-library <span class="EmpStrong">map</span> is a container of pairs of values optimized for lookup. We can use the same initializer as for <span class="EmpStrong">vector</span> and <span class="EmpStrong">list</span> (&#167;<a href="ch09.html#ch09lev1sec2">9.2</a>, &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>):</p>
<p class="codelink"><a id="p101pro02" href="ch09_images.html#p101pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">map&lt;string,int&gt; phone_book {</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"David Hume",123456},</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Karl Popper",234567},</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Bertrand Arthur William Russell",345678}</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent"><a id="page_102"/>When indexed by a value of its first type (called the <em>key</em>), a <span class="EmpStrong">map</span> returns the corresponding value of the second type (called the <em>value</em> or the <em>mapped type</em>). For example:</p>
<p class="codelink"><a id="p102pro01" href="ch09_images.html#p102pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int get_number(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return phone_book[s];</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">In other words, subscripting a <span class="EmpStrong">map</span> is essentially the lookup we called <span class="EmpStrong">get_number()</span>. If a <span class="EmpStrong">key</span> isn&#8217;t found, it is entered into the <span class="EmpStrong">map</span> with a default value for its <span class="EmpStrong">value</span>. The default value for an integer type is <span class="EmpStrong">0</span>; the value I just happened to choose represents an invalid telephone number.</p>
<p class="indent">If we wanted to avoid entering invalid numbers into our phone book, we could use <span class="EmpStrong">find()</span> and <span class="EmpStrong">insert()</span> instead of <span class="EmpStrong">[ ]</span>.</p>
<div class="heading">
<h3 id="ch09lev1sec5">9.5. <span class="EmpStrong">unordered_map</span></h3>
<p class="noindent">The cost of a <span class="EmpStrong">map</span> lookup is <span class="EmpStrong">O(log(n))</span> where <span class="EmpStrong">n</span> is the number of elements in the <span class="EmpStrong">map</span>. That&#8217;s pretty good. For example, for a <span class="EmpStrong">map</span> with 1,000,000 elements, we perform only about 20 comparisons and indirections to find an element. However, in many cases, we can do better by using a hashed lookup rather than comparison using an ordering function, such as <span class="EmpStrong">&lt;</span>. The standard-library hashed containers are referred to as &#8220;unordered&#8221; because they don&#8217;t require an ordering function:</p>
</div>
<div class="image"><img src="graphics/102fig01.jpg" alt="Image"/></div>
<p class="noindent">For example, we can use an <span class="EmpStrong">unordered_map</span> from <span class="EmpStrong">&lt;unordered_map&gt;</span> for our phone book:</p>
<p class="codelink"><a id="p102pro02" href="ch09_images.html#p102pro02a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">unordered_map&lt;string,int&gt; phone_book {</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"David Hume",123456},</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Karl Popper",234567},</span><br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">{"Bertrand Arthur William Russell",345678}</span><br/><span class="EmpStrong">};</span></p>
<p class="noindent">As for a <span class="EmpStrong">map</span>, we can subscript an <span class="EmpStrong">unordered_map</span>:</p>
<p class="codelink"><a id="p102pro03" href="ch09_images.html#p102pro03a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">int get_number(const string&#38; s)</span><br/><span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return phone_book[s];</span><br/><span class="EmpStrong">}</span></p>
<p class="noindent">The standard-library provides a default hash function for <span class="EmpStrong">string</span>s as well as for other built-in and standard-library types. If necessary, you can provide your own. Possibly, the most common need for a &#8220;custom&#8221; hash function comes when we want an unordered container of one of our own types. A hash function is often provided as a function object (&#167;<a href="ch05.html#ch05lev1sec5">5.5</a>). For example:</p>
<p class="codelink"><a id="page_103"/><a id="p103pro01" href="ch09_images.html#p103pro01a">Click here to view code image</a></p>
<p class="pre"><span class="EmpStrong">struct Record {</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">string name;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">int product_code;</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">...</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">struct Rhash {</span>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">//</span> <span class="EmpItalic">a hash function for Record</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">size_t operator()(const Record&#38; r) const</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">{</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return hash&lt;string&gt;()(r.name) &#94; hash&lt;int&gt;()(r.product_code);</span><br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">}</span><br/><span class="EmpStrong">};</span><br/><br/><span class="EmpStrong">unordered_set&lt;Record,Rhash&gt; my_set; //</span> <span class="EmpItalic">set of Recoreds using Rhash for lookup</span></p>
<p class="noindent">Creaing a new hash function by combining existing hash functions using exclusive or (<span class="EmpStrong">^</span>) is simple and often very effective. We often prefer a <span class="EmpStrong">set</span> to a <span class="EmpStrong">map</span> when the key is already part of the data.</p>
<div class="heading">
<h3 id="ch09lev1sec6">9.6. Container Overview</h3>
<p class="noindent">The standard library provides some of the most general and useful container types to allow the programmer to select a container that best serves the needs of an application:</p>
</div>
<div class="image"><img src="graphics/103tab01.jpg" alt="Image"/></div>
<p class="noindent">The unordered containers are optimized for lookup with a key (often a string); in other words, they are implemented using hash tables.</p>
<p class="indent">The containers are defined in namespace <span class="EmpStrong">std</span> and presented in headers <span class="EmpStrong">&lt;vector&gt;</span>, <span class="EmpStrong">&lt;list&gt;</span>, <span class="EmpStrong">&lt;map&gt;</span>, etc. (&#167;<a href="ch06.html#ch06lev1sec3">6.3</a>). In addition, the standard library provides container adaptors <span class="EmpStrong">queue&lt;T&gt;</span>, <span class="EmpStrong">stack&lt;T&gt;</span>, and <span class="EmpStrong">priority_queue&lt;T&gt;</span>. Look them up if you need them. The standard library also provides more specialized container-like types, such as a fixed-size array <span class="EmpStrong">array&lt;T,N&gt;</span> (&#167;<a href="ch11.html#ch11lev2sec2">11.3.1</a>) and <span class="EmpStrong">bitset&lt;N&gt;</span> (&#167;<a href="ch11.html#ch11lev2sec3">11.3.2</a>).</p>
<p class="indent">The standard containers and their basic operations are designed to be similar from a notational point of view. Furthermore, the meanings of the operations are equivalent for the various <a id="page_104"/>containers. Basic operations apply to every kind of container for which they make sense and can be efficiently implemented. For example:</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">begin()</span> and <span class="EmpStrong">end()</span> give iterators to the first and one-beyond-the-last elements, respectively.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">push_back()</span> can be used (efficiently) to add elements to the end of a <span class="EmpStrong">vector</span>, <span class="EmpStrong">list</span>, and other containers.</p>
<p class="indenthangingB">&#8226; <span class="EmpStrong">size()</span> returns the number of elements.</p>
<p class="noindent">This notational and semantic uniformity enables programmers to provide new container types that can be used in a very similar manner to the standard ones. The range-checked vector, <span class="EmpStrong">Vector</span> (&#167;<a href="ch03.html#ch03lev2sec2">3.4.2</a>, <a href="ch04.html#ch04">Chapter 4</a>), is an example of that. The uniformity of container interfaces allows us to specify algorithms independently of individual container types. However, each has strengths and weaknesses. For example, subscripting and traversing a <span class="EmpStrong">vector</span> is cheap and easy. On the other hand, <span class="EmpStrong">vector</span> elements are moved when we insert or remove elements; <span class="EmpStrong">list</span> has exactly the opposite properties. Please note that a <span class="EmpStrong">vector</span> is usually more efficient than a <span class="EmpStrong">list</span> for short sequences of small elements (even for <span class="EmpStrong">insert()</span> and <span class="EmpStrong">erase()</span>). I recommend the standard-library <span class="EmpStrong">vector</span> as the default type for sequences of elements: you need a reason to choose another.</p>
<p class="indent">Consider the singly-linked list, <span class="EmpStrong">forward_list</span>, a container optimized for the empty sequence (which occupies just one word) because the number of elements are zero or very low; such sequences are surprisingly useful.</p>
<div class="heading">
<h3 id="ch09lev1sec7">9.7. Advice</h3>
<p class="ref">[1] The material in this chapter roughly corresponds to what is described in much greater detail in Chapter 31 of [Stroustrup,2013].</p>
</div>
<p class="ref">[2] An STL container defines a sequence; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref">[3] STL containers are resource handles; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>, &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>, &#167;<a href="ch09.html#ch09lev1sec4">9.4</a>, &#167;<a href="ch09.html#ch09lev1sec5">9.5</a>.</p>
<p class="ref">[4] Use <span class="EmpStrong">vector</span> as your default container; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>, &#167;<a href="ch09.html#ch09lev1sec6">9.6</a>.</p>
<p class="ref">[5] For simple traversals of a container, use a range-<span class="EmpStrong">for</span> loop or a begin/end pair of iterators; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>, &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>.</p>
<p class="ref">[6] Use <span class="EmpStrong">reserve()</span> to avoid invalidating pointers and iterators to elements; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref">[7] Don&#8217;t assume performance benefits from <span class="EmpStrong">reserve()</span> without measurement; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref">[8] Use <span class="EmpStrong">push_back()</span> or <span class="EmpStrong">resize()</span> on a container rather than <span class="EmpStrong">realloc()</span> on an array; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref">[9] Don&#8217;t use iterators into a resized <span class="EmpStrong">vector</span>; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[10] Do not assume that <span class="EmpStrong">[ ]</span> range checks; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[11] Use <span class="EmpStrong">at()</span> when you need guaranteed range checks; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[12] Elements are copied into a container; &#167;<a href="ch09.html#ch09lev2sec1">9.2.1</a>.</p>
<p class="ref1">[13] To preserve polymorphic behavior of elements, store pointers; &#167;<a href="ch09.html#ch09lev2sec1">9.2.1</a>.</p>
<p class="ref1">[14] Insertion operators, such as <span class="EmpStrong">insert()</span> and <span class="EmpStrong">push_back()</span> are often surprisingly efficient on a</p>
<p class="refP"><span class="EmpStrong">vector</span>; &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>.</p>
<p class="ref1">[15] Use <span class="EmpStrong">forward_list</span> for sequences that are usually empty; &#167;<a href="ch09.html#ch09lev1sec6">9.6</a>.</p>
<p class="ref1">[16] When it comes to performance, don&#8217;t trust your intuition: measure; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[17] A <span class="EmpStrong">map</span> is usually implemented as a red-black tree; &#167;<a href="ch09.html#ch09lev1sec4">9.4</a>.</p>
<p class="ref1">[18] An <span class="EmpStrong">unordered_map</span> is a hash table; &#167;<a href="ch09.html#ch09lev1sec5">9.5</a>.</p>
<p class="ref1"><a id="page_105"/>[19] Pass a container by reference and return a container by value; &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[20] For a container, use the <span class="EmpStrong">()</span>-initializer syntax for sizes and the <span class="EmpStrong">{}</span>-initializer syntax for lists of elements; &#167;<a href="ch04.html#ch04lev2sec3">4.2.3</a>, &#167;<a href="ch09.html#ch09lev1sec2">9.2</a>.</p>
<p class="ref1">[21] Prefer compact and contiguous data structures; &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>.</p>
<p class="ref1">[22] A <span class="EmpStrong">list</span> is relatively expensive to traverse; &#167;<a href="ch09.html#ch09lev1sec3">9.3</a>.</p>
<p class="ref1">[23] Use unordered containers if you need fast lookup for large amounts of data; &#167;<a href="ch09.html#ch09lev1sec5">9.5</a>.</p>
<p class="ref1">[24] Use ordered associative containers (e.g., <span class="EmpStrong">map</span> and <span class="EmpStrong">set</span>) if you need to iterate over their elements in order; &#167;<a href="ch09.html#ch09lev1sec4">9.4</a>.</p>
<p class="ref1">[25] Use unordered containers for element types with no natural order (e.g., no reasonable <span class="EmpStrong">&lt;</span>); &#167;<a href="ch09.html#ch09lev1sec4">9.4</a>.</p>
<p class="ref1">[26] Experiment to check that you have an acceptable hash function; &#167;<a href="ch09.html#ch09lev1sec5">9.5</a>.</p>
<p class="ref1">[27] Hash function obtained by combining standard hash functions for elements using exclusive or are often good; &#167;<a href="ch09.html#ch09lev1sec5">9.5</a>.</p>
<p class="ref1">[28] Know your standard-library containers and prefer them to hand-crafted data structures; &#167;<a href="ch09.html#ch09lev1sec6">9.6</a>.</p>
</body>
</html>