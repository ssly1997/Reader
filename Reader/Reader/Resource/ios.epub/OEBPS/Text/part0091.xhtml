<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">10.3 UINavigationController的导航功能</h2>

  <p class="calibre1">　　前面已经为Homepwner加入了一个UINavigationController对象，并创建了BNRItemsViewController和BNRDetailViewController这两个UIViewController子类。下面将这些对象组合在一起以实现其功能：当用户点击BNRItemsViewController对象的表格视图中的某一行时，Homepwner会创建一个BNRDetailViewController对象，然后将该对象的视图推入窗口，显示当前选中的BNRItem对象的各项属性。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">将视图控制器压入栈</h3>

  <p class="calibre1">　　要完成上述任务，就必须创建BNRDetailViewController对象。问题是该在何处创建该对象？本章之前的应用都会在application:didFinishLaunchingWithOptions:中创建所有的视图控制器。例如，第6章在application:didFinishLaunchingWithOptions:中创建了两个视图控制器并将它们加入了UITabBarController对象的viewControllers数组。</p>

  <p class="calibre1">　　但是，在使用UINavigationController时，不能简单地将所有可能用到的视图控制器都压入UINavigationController对象的栈。该对象的viewControllers数组是动态的：一开始只有一个根视图控制器，应用需要根据情况推入新的视图控制器。因此，Homepwner需要某个对象（除UINavigationController对象外）来负责创建BNRDetailViewController对象，并将新创建的对象压入UINavigationController对象的栈。</p>

  <p class="calibre1">　　这个负责创建BNRDetailViewController对象的对象需要满足两个条件：首先，该对象要知道在什么时候将BNRDetailViewController对象压入栈。其次，该对象需要拥有一个指向UINavigationController对象的指针，以便向UINavigationController对象发送pushViewController:animated:消息。</p>

  <p class="calibre1">　　BNRItemsViewController对象满足上述两个条件。首先，因为该对象是UITableView对象的委托对象，所以，当用户点击UITableView对象的某个表格行时，BNRItemsViewController对象会收到tableView:didSelectRowAtIndexPath:消息。其次，凡是加入了某个UINavigationController对象的栈的视图控制器，都可以向自己发送navigationController消息，以得到指向该对象的指针。因为应用会将BNRItemsViewController对象设置为UINavigationController对象的根视图控制器，所以BNRItemsViewController对象会一直留在UINavigationController对象的栈中，从而使BNRItemsViewController对象总能得到指向相应UINavigationController对象的指针。</p>

  <p class="calibre1">　　因此，应该由BNRItemsViewController对象负责创建BNRDetailViewController对象并将其加入UINavigationController对象的栈。在BNRItemsViewController.h顶部导入BNRDetailViewController的头文件。</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRDetailViewController.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　@interface BNRItemsViewController : UITableViewController</p>

  <p class="calibre1">　　当用户点击UITableView对象中的某个表格行时，该对象会向其委托对象发送tableView:didSelectRowAtIndexPath:消息并传入选中的行的索引信息。在BNRItemsViewController.m中实现tableView:didSelectRowAtIndexPath:，创建BNRDetailViewController对象，然后将新创建的对象压入UINavigationController对象的栈，代码如下：</p>

  <p class="calibre1">　　@implementation BNRItemsViewController</p>

  <p class="calibre1"><span class="calibre10">　　- （void）tableView:（UITableView *）tableView</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　didSelectRowAtIndexPath:（NSIndexPath *）indexPath</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRDetailViewController *detailViewController =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[BNRDetailViewController alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 将新创建的BNRDetailViewController对象压入UINavigationController对象的栈</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.navigationController pushViewController:detailViewController</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　animated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　构建并运行应用，添加一新行并选中之。Homepwner应该会以动画的形式，将BNRDetailViewController对象的视图从屏幕右侧推入。此外，位于窗口顶部的UINavigationBar对象会在其左端显示一个标题为“Back（返回）”的按钮。点击这个按钮，UINavigationController对象会弹出位于栈顶的BNRDetailViewController对象，退回至BNRItemsViewController对象。</p>

  <p class="calibre1">　　因为UINavigationController对象的栈是一个数组，会拥有其包含的所有视图控制器，所以当应用执行完tableView:didSelectRowAtIndexPath:方法后，该对象将成为新创建的BNRDetailViewController对象的唯一拥有者。一旦UINavigationController对象将某个BNRDetailViewController对象弹出栈，弹出的这个对象就会立刻被释放。当用户再次选中某个表格行时，应用会创建新的BNRDetailViewController对象。</p>

  <p class="calibre1">　　使用UINavigationController对象时，经常会由当前处于栈顶的视图控制器来负责压入另一个视图控制器，这是常见的使用模式。也就是说，UINavigationController对象的根视图控制器会负责创建并压入下一个视图控制器，而下一个视图控制器会负责创建并压入再下一个视图控制器，依此类推。有些应用的视图控制器可以根据用户的输入创建并压入不同类型的视图控制器。以iOS自带的照片（Photos）应用为例，照片应用会根据用户选中的媒体类型将视频视图控制器或图片视图控制器压入UINavigationController对象的栈。</p>

  <p class="calibre1">　　只能用于iPad的UISplitViewController类，使用的是另一种模式。iPad拥有更大的屏幕，可以同时显示垂直界面中的两个视图控制器，从而不需要将后者压入栈。第22章会对UISplitViewController作更多的介绍。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">视图控制器之间的数据传递</h3>

  <p class="calibre1">　　下面为UITextField对象设置显示内容。为此，需要通过某种途径将选中的BNRItem对象从BNRItemsViewController对象传入BNRDetailViewController对象。</p>

  <p class="calibre1">　　首先为BNRDetailViewController添加一个属性，用来保存指定的BNRItem对象。当用户点击UITableView对象中的某个表格行时，BNRItemsViewController对象应该将选中的BNRItem对象传给即将被压入栈的BNRDetailViewController对象。得到BNRItem对象后，BNRDetailViewController对象就可以针对相应的BNRItem属性设置所有的UITextField对象。当用户修改了某个UITextField对象后，BNRDetailViewController对象也会将新的值赋给相应的BNRItem对象属性。</p>

  <p class="calibre1">　　在BNRDetailViewController.h中，先在文件顶部用@class指令来前置声明BNRItem，然后为BNRDetailViewController类添加一个属性，代码如下：</p>

  <p class="calibre1">　　#import &lt;UIKit/UIKit.h&gt;</p>

  <p class="calibre1"><span class="calibre10">　　@class BNRItem;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@interface BNRDetailViewController : UIViewController</p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, strong） BNRItem *item;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　在BNRDetailViewController.m中，导入BNRItem的头文件：</p>

  <p class="calibre1"><span class="calibre10">　　#import “BNRItem.h”</span><br class="calibre2"/></p>

  <p class="calibre1">　　当应用要显示BNRDetailViewController对象的视图时，该对象需要根据item的各个属性设置其视图的子视图。在BNRDetailViewController.m中覆盖viewWillAppear:，将BNRItem对象的各个属性赋给相应的UITextField对象，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillAppear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillAppear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRItem *item = self.item;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.nameField.text = item.itemName;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.serialNumberField.text = item.serialNumber;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.valueField.text =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[NSString stringWithFormat:@“%d”, item.valueInDollars];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 创建NSDateFormatter对象，用于将NSDate对象转换成简单的日期字符串</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　static NSDateFormatter *dateFormatter = nil;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （！dateFormatter） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　dateFormatter = [[NSDateFormatter alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　dateFormatter.dateStyle = NSDateFormatterMediumStyle;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　dateFormatter.timeStyle = NSDateFormatterNoStyle;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 将转换后得到的日期字符串设置为dateLabel的标题</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.dateLabel.text = [dateFormatter stringFromDate:item.dateCreated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　接下来在BNRItemsViewController.m的tableView:didSelectRowAtIndexPath:方法中添加以下代码，以便在BNRDetailViewController对象收到viewWillAppear:消息前将其item属性设置为相应的BNRItem对象。</p>

  <p class="calibre1">　　- （void）tableView:（UITableView *）tableView</p>

  <p class="calibre1">　　didSelectRowAtIndexPath:（NSIndexPath *）indexPath</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　BNRDetailViewController *detailViewController =</p>

  <p class="calibre1">　　[[BNRDetailViewController alloc] init];</p>

  <p class="calibre1"><span class="calibre10">　　NSArray *items = [[BNRItemStore sharedStore] allItems];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRItem *selectedItem = items[indexPath.row];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 将选中的BNRItem对象赋给DetailViewController对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　detailViewController.item = selectedItem;</span><br class="calibre2"/></p>

  <p class="calibre1">　　[self.navigationController pushViewController:detailViewController</p>

  <p class="calibre1">　　animated:YES];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　当要在多个视图控制器之间传递数据时，很多刚接触iOS开发的初学者可能会无从下手。Homepwner使用了一种简单高效的解决方案：由根视图控制器保存所有的数据，然后将数据的子集传给下一个视图控制器。</p>

  <p class="calibre1">　　构建并运行应用，添加一新的表格行并选中。Homepwner会显示BNRDetailViewController对象的视图，其中包含选中的BNRItem对象的详细信息。虽然用户可以编辑这些信息，但是当屏幕返回至BNRItemsViewController对象后，UITableView对象不会根据用户做出的修改来更新显示内容。要解决这个问题，需要编写代码，根据用户的输入来修改BNRItem对象的相应属性。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">视图的显示和消失</h3>

  <p class="calibre1">　　当UINavigationController对象切换视图时，其包含的两个UIViewController对象会分别收到viewWillDisappear:消息和viewWillAppear:消息。即将出栈的UIViewController对象会收到viewWillDisappear:消息，即将入栈的UIViewController对象会收到viewWillAppear:消息。</p>

  <p class="calibre1">　　当某个BNRDetailViewController对象退出栈时，应该将各个UITextField对象的值赋给BNRItem对象的相应属性。覆盖viewWillDisappear:和viewWillAppear:时，必须先调用父类的实现，以完成必要的工作。在BNRDetailViewController.m中实现viewWillDisappear:，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillDisappear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillDisappear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 取消当前的第一响应对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.view endEditing:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 将修改“保存”至BNRItem对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　BNRItem *item = self.item;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　item.itemName = self.nameField.text;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　item.serialNumber = self.serialNumberField.text;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　item.valueInDollars = [self.valueField.text intValue];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　这段代码使用了UIView的endEditing:方法。当某个视图收到endEditing:消息时，如果该视图（或者其下的任何子视图）是当前的第一响应对象，就会取消自己的第一响应对象状态，而且虚拟键盘也会关闭（传入的参数代表是否需要强制取消第一响应对象状态。某些第一响应对象可能会拒绝退出状态，传入YES可以强制其退出）。</p>

  <p class="calibre1">　　更新代码后，当用户点击UINavigationBar对象上的Back（返回）按钮时，BNRDetailViewController对象就会更新相应的BNRItem对象。当BNRItemsView- Controller对象的视图再次出现在屏幕上时，它就会收到viewWillAppear:消息。这时应该刷新UITableView对象，使用户能够立刻看到更新后的数据。在BNRItemsViewController.m中覆盖viewWillAppear:，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）viewWillAppear:（BOOL）animated</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super viewWillAppear:animated];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.tableView reloadData];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　构建并运行应用。现在应该可以在BNRItemsViewController对象和BNRDetail- ViewController对象之间来回切换并修改数据，UITableView对象会及时刷新，以显示更新后的BNRItem对象。</p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
