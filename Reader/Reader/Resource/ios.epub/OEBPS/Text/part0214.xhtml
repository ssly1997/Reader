<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">24.6 编码状态数据</h2>

  <p class="calibre1">　　为了保存状态信息，UIViewController需要持久化状态数据，持久化的方式与第18章介绍的归档（archiving）类似，也是使用NSCoder对象对数据进行编码（encoding）。下面就演示如何编码需要的状态数据。</p>

  <p class="calibre1">　　打开BNRDetailViewController.m，编码当前BNRItem对象的itemKey属性，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）encodeRestorableStateWithCoder:（NSCoder *）coder</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[coder encodeObject:self.item.itemKey</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　forKey:@“item.itemKey”];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super encodeRestorableStateWithCoder:coder];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　对应地，还需要实现解码（decoding）方法，通过itemKey在BNRItemStore中查找相应的BNRItem对象：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）decodeRestorableStateWithCoder:（NSCoder *）coder</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSString *itemKey =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[coder decodeObjectForKey:@“item.itemKey”];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　for （BNRItem *item in [[BNRItemStore sharedStore] allItems]） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （[itemKey isEqualToString:item.itemKey]） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.item = item;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　break;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[super decodeRestorableStateWithCoder:coder];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　构建并运行应用，进入某一个BNRItem对象的详细界面，然后触发状态恢复。这次BNRDetailViewController可以正确显示之前选择的BNRItem。</p>

  <p class="calibre1">　　现在还有一个问题：BNRDetailViewController在恢复状态时会将BNRItem的各项属性分别赋给对应的UITextField对象，如果用户之前在UITextField对象中输入过新值，那么这些新值就会丢失。为了解决该问题，需要在用户离开应用时将新值赋给BNRItem的对应属性，并保存修改后的BNRItem。由于encodeRestorableStateWithCoder:会在应用进入后台运行状态时调用，因此修改并保存BNRItem的代码同样可以写在该方法中。</p>

  <p class="calibre1">　　在BNRDetailViewController.m中修改编码方法，代码如下：</p>

  <p class="calibre1">　　- （void）encodeRestorableStateWithCoder:（NSCoder *）coder</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　[coder encodeObject:self.item.itemKey</p>

  <p class="calibre1">　　forKey:@“item.itemKey”];</p>

  <p class="calibre1"><span class="calibre10">　　// 保存UITextField对象中的文本</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.item.itemName = self.nameField.text;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.item.serialNumber = self.serialNumberField.text;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.item.valueInDollars = [self.valueField.text intValue];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 保存修改</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[BNRItemStore sharedStore] saveChanges];</span><br class="calibre2"/></p>

  <p class="calibre1">　　[super encodeRestorableStateWithCoder:coder];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　现在BNRDetailViewController可以很好地保存和恢复自身状态。下一节将为BNRItemsViewController添加状态恢复功能。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
