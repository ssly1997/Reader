<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">17.3 UIPopoverController</h2>

  <p class="calibre1">　　为了有效利用充足的屏幕空间，Apple针对iPad应用提供了UIPopoverController。在iPhone应用中，如果要让用户做一个选择（例如在照片库中选择一张照片），或者针对屏幕上的某些元素显示相关摘要信息（例如向用户解释某一项数据的具体含义），则可能会使用模态视图控制器或警告视图；而在iPad应用中，这些场景更适合使用UIPopoverController。对于Homepwner应用，当用户在详细界面点击相机按钮时，就可以使用UIPopover- Controller来显示UIImagePickerController。</p>

  <p class="calibre1">　　UIPopoverController能够在一个带边框的窗口中显示一个指定的视图控制器的视图。此外，这个窗口会“悬浮”在其他界面的前面。创建UIPopoverController对象时需要设置contentViewController属性，指向需要显示的视图控制器。</p>

  <p class="calibre1">　　本节要完成的任务为：当用户按下相机按钮时，通过UIPopoverController对象来显示UIImagePickerController对象（见图17-2）。</p>

  <p class="calibre7"><img alt="tu17-2" src="../Images/image00594.jpeg" class="calibre8"/></p>

  <p class="calibre7">图17-2 UIPopoverController</p>

  <p class="calibre1">　　在BNRDetailViewController.m的类扩展中，将BNRDetailViewController声明为遵守UIPopoverControllerDelegate协议，代码如下：</p>

  <p class="calibre1">　　@interface BNRDetailViewController （）</p>

  <p class="calibre1">　　&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate,</p>

  <p class="calibre1">　　UITextFieldDelegate, <span class="calibre10">UIPopoverControllerDelegate&gt;</span></p>

  <p class="calibre1">　　再添加一个属性，用于保存UIPopoverController对象，代码如下：</p>

  <p class="calibre1">　　@interface BNRDetailViewController （）</p>

  <p class="calibre1">　　&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate,</p>

  <p class="calibre1">　　UITextFieldDelegate, UIPopoverControllerDelegate&gt;</p>

  <p class="calibre1"><span class="calibre10">　　@property （strong, nonatomic） UIPopoverController *imagePickerPopover;</span><br class="calibre2"/></p>

  <p class="calibre1">　　@property （weak, nonatomic） IBOutlet UITextField *nameField;</p>

  <p class="calibre1">　　然后在takePicture:方法的末端添加以下代码：</p>

  <p class="calibre1">　　imagePicker.delegate = self;</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">[self presentViewController:imagePicker animated:YES completion:nil];</span></del></p>

  <p class="calibre1"><span class="calibre10">　　// 显示UIImagePickerController对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 创建UIPopoverController对象前先检查当前设备是否是iPad</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （[UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 创建UIPopoverController对象，用于显示UIImagePickerController对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imagePickerPopover = [[UIPopoverController alloc]</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　initWithContentViewController:imagePicker];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imagePickerPopover.delegate = self;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 显示UIPopoverController对象，</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// sender指向的是代表相机按钮的UIBarButtonItem对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.imagePickerPopover</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　presentPopoverFromBarButtonItem:sender</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　permittedArrowDirections:UIPopoverArrowDirectionAny</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　animated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　} else {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self presentViewController:imagePicker animated:YES completion:nil];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　这段代码在创建UIPopoverController对象前，要先检查设备的类型，这点很重要。只有当iOS应用是在iPad系设备上运行的时候，才能创建UIPopoverController对象，否则应用会抛出异常。</p>

  <p class="calibre1">　　针对iPad模拟器或iPad构建并运行应用。选中UITableView对象中的某一行，显示BNRDetailViewController对象的视图并按下相机按钮。Homepwner会显示一个UIPopoverController对象并显示UIImagePickerController对象的视图。从UIImagePicke- Controller对象所显示的照片中挑选一张，Homepwner会关闭UIPopoverController对象，并在BNRDetailViewController对象的视图中显示选中的照片。</p>

  <p class="calibre1">　　触摸屏幕的其他区域可以关闭UIPopoverController对象。如果某个UIPopoverController对象是通过这种方式关闭的，那么该对象会向自己的委托对象发送popoverControllerDidDismissPopover:消息。在BNRDetailViewController.m中实现popoverControllerDidDismissPopover:，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）popoverControllerDidDismissPopover:</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　（UIPopoverController *）popoverController</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSLog（@“User dismissed popover”）；</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imagePickerPopover = nil;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　为了放弃针对UIPopoverController对象的拥有权，这段代码在popoverController- DidDismissPopover:中将imagePickerPopover赋为了nil。每当用户按下拍照按钮时，Homepwner都会创建一个新的UIPopoverController对象。</p>

  <p class="calibre1">　　当用户在UIImagePickerController对象中选择一张图片后，也要关闭UIPopoverController对象。在BNRDetailViewController.m中的imagePickerController: didFinishPickingMediaWithInfo:末尾关闭UIPopoverController对象，代码如下：</p>

  <p class="calibre1">　　self.imageView.image = image;</p>

  <p class="calibre1">　　<span class="calibre10">[self dismissViewControllerAnimated:YES completion:nil];</span></p>

  <p class="calibre1"><span class="calibre10">　　// 判断UIPopoverController对象是否存在</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （self.imagePickerPopover） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 关闭UIPopoverController对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.imagePickerPopover dismissPopoverAnimated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imagePickerPopover = nil;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　} else {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 关闭以模态形式显示的UIImagePickerController对象</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self dismissViewControllerAnimated:YES completion:nil];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　要“主动地”关闭UIPopoverController对象，可以向需要关闭的UIPopoverController对象发送dismissPopoverAnimated:消息。如果UIPopoverController对象是通过这种方式关闭的，就不会向其委托对象发送popoverControllerDidDismissPopover:消息。为了应对这种情况，还需要在关闭UIPopoverController对象之后将其设置为nil。</p>

  <p class="calibre1">　　以上代码有一个小问题需要修正。在用户按下拍照按钮打开UIPopoverController对象后，如果再次按下拍照按钮，Homepwner就会崩溃。这是因为当用户再次按下按钮时，触发的takePicture:会创建新的UIPopoverController对象，并将新创建的对象赋给imagePickerPopover，从而导致当前可见的UIPopoverController对象失去其最后的一个拥有方并被释放。要解决这个问题，只要在创建并显示新的UIPopoverController对象前，检查imagePickerPopover是否指向有效的UIPopoverController对象。如果是有效的，并且该对象的视图是可见的，就关闭这个对象，而不是重新创建新的，代码如下：</p>

  <p class="calibre1">　　- （IBAction）takePicture:（id）sender</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1"><span class="calibre10">　　if （[self.imagePickerPopover isPopoverVisible]） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 如果imagePickerPopover指向的是有效的UIPopoverController对象，</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 并且该对象的视图是可见的，就关闭这个对象，并将其设置为nil</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[imagePickerPopover dismissPopoverAnimated:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　imagePickerPopover = nil;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　return;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　UIImagePickerController *imagePicker =</p>

  <p class="calibre1">　　[[UIImagePickerController alloc] init];</p>

  <p class="calibre1">　　构建并运行应用。按下拍照按钮并显示UIPopoverController对象，然后再次按下拍照按钮，之前显示的UIPopoverController对象就会消失。</p>

  <p class="calibre1"><br class="calibre2"/></p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
