<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">20.5 修改BNRItemCell</h2>

  <p class="calibre1">　　现在UITableView的行高已经可以根据首选字体大小动态改变了，但是BNRItemCell中UILabel对象的文字大小还不会发生任何变化。本节将修改BNRItemCell，支持动态字体。首先查看BNRItemCell各个子视图的现有约束：UIImageView对象位于contentView左边，并保持垂直居中；nameLabel始终位于顶部，serialNumberLabel始终位于底部；valueLabel位于contentView右边，也保持垂直居中（见图20-5）。</p>

  <p class="calibre7"><img alt="tu20-5" src="../Images/image00635.jpeg" class="calibre8"/></p>

  <p class="calibre7">图20-5 BNRItemCell各个子视图的现有约束</p>

  <p class="calibre1">　　下面根据用户首选字体设置UILabel对象的font属性，读者可以参考之前在BNRDetailViewController或BNRItemsViewController中添加的代码。</p>

  <p class="calibre1">　　打开BNRItemCell.m，添加下列方法：</p>

  <p class="calibre1"><span class="calibre10">　　- （void）updateInterfaceForDynamicTypeSize</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.nameLabel.font = font;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.serialNumberLabel.font = font;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.valueLabel.font = font;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　- （void）awakeFromNib</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self updateInterfaceForDynamicTypeSize];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[nc addObserver:self</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　selector:@selector（updateInterfaceForDynamicTypeSize）</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　name:UIContentSizeCategoryDidChangeNotification</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　object:nil];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　- （void）dealloc</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[nc removeObserver:self];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　以上代码只有awakeFromNib与之前有所区别。当NIB文件解档某个对象后，该对象就会收到awakeFromNib消息，可以在awakeFromNib中设置该对象，或者执行其他需要的初始化操作。例如，以上代码在awakeFromNib中设置了UILabel对象的font属性，并将BNRItemCell对象注册为UIContentSizeCategoryDidChangeNotification的观察者。构建并运行应用，现在BNRItemCell可以根据用户首选字体改变界面中的文字大小了。</p>

  <p class="calibre1">　　接下来需要解决BNRItemCell中的一些自动布局问题。</p>

  <p class="calibre1">　　与之前BNRDetailViewController中的问题类似，第19章限定了nameLabel和serialNumberLabel的高度，自动布局系统将无法修改两个UILabel对象的高度。</p>

  <p class="calibre1">　　打开BNRItemCell.xib，删除两个UILabel对象的高度约束，这时Interface Builder会提示视图位置错误。打开Resolve Auto Layout Issues菜单，选择Update All Frames in Homepwner Item Cell。构建并运行应用，现在UILabel对象会根据用户首选字体自动调整高度。</p>

  <p class="calibre1">　　最后还剩下UIImageView对象。下面将修改UIImageView对象的约束，使UIImageView对象可以根据用户首选字体自动调整大小。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">为约束添加插座变量</h3>

  <p class="calibre1">　　如果需要修改某个视图的大小或位置，无论是修改为固定值还是修改与其他视图之间的相对关系，都应该修改视图的约束，而不是硬编码视图的frame；否则，当界面需要重新布局时，自动布局系统仍然会根据之前的约束修改视图的frame，从而覆盖硬编码的frame。</p>

  <p class="calibre1">　　为了在运行时根据用户首选字体动态修改UIImageView对象的宽度和高度约束，需要为两个约束添加相应的插座变量。约束是NSLayoutConstraint类的对象，添加插座变量的过程与其他视图对象是相同的。</p>

  <p class="calibre1">　　在BNRItemCell.m的类扩展中，添加并关联宽度和高度约束的插座变量，代码如下：</p>

  <p class="calibre1"><span class="calibre10">　　@interface BNRItemCell （）</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, weak） IBOutlet NSLayoutConstraint</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　*imageViewHeightConstraint;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@property （nonatomic, weak） IBOutlet NSLayoutConstraint</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　*imageViewWidthConstraint;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　@end</span><br class="calibre2"/></p>

  <p class="calibre1">　　现在可以在代码中动态修改UIImageView对象的两个约束了。在BNRItemCell.m中，修改updateInterfaceForDynamicTypeSize，获取用户首选字体大小，然后修改宽度和高度约束的限定值（设置NSLayoutConstraint对象的constant属性）。</p>

  <p class="calibre1">　　- （void）updateInterfaceForDynamicTypeSize</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];</p>

  <p class="calibre1">　　self.nameLabel.font = font;</p>

  <p class="calibre1">　　self.serialNumberLabel.font = font;</p>

  <p class="calibre1">　　self.valueLabel.font = font;</p>

  <p class="calibre1"><span class="calibre10">　　static NSDictionary *imageSizeDictionary;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　if （！imageSizeDictionary） {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　imageSizeDictionary = @{</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryExtraSmall : @40,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategorySmall : @40,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryMedium : @40,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryLarge : @40,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryExtraLarge : @45,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryExtraExtraLarge : @55,</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　UIContentSizeCategoryExtraExtraExtraLarge : @65</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　};</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSString *userSize =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[UIApplication sharedApplication] preferredContentSizeCategory];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　NSNumber *imageSize = imageSizeDictionary[userSize];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imageViewHeightConstraint.constant = imageSize.floatValue;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　self.imageViewWidthConstraint.constant = imageSize.floatValue;</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，修改用户首选字体，这时UIImageView对象会根据用户首选字体自动调整大小。同时，由于之前限定了nameLabel和serialNumberLabel左边与UIImageView对象右边的距离，因此当UIImageView对象的大小发生变化时，nameLabel和serialNumberLabel也会自动调整位置，保持与UIImageView对象的间距。如果之前限定的是两个UILabel对象左边与父视图的距离，那么UIImageView对象就可能遮住两个UILabel对象，或者留下大片空白。</p>

  <p class="calibre1">　　现在BNRItemCell可以很好地支持动态字体了，但是还需要做最后一处修改。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">占位符约束</h3>

  <p class="calibre1">　　以上代码同时修改了UIImageView对象的宽度和高度约束，虽然这样做没有问题，但是还有一种更好的解决方案：只修改UIImageView对象的高度约束，然后添加另一个约束，限定UIImageView对象的宽度与高度相同。该约束无法在Interface Builder中添加，必须通过代码创建。回到BNRItemCell.m，在awakeFromNib中为UIImageView对象（thumbnailView属性）添加该约束，代码如下：</p>

  <p class="calibre1">　　- （void）awakeFromNib</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　[self updateInterfaceForDynamicTypeSize];</p>

  <p class="calibre1">　　NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</p>

  <p class="calibre1">　　[nc addObserver:self</p>

  <p class="calibre1">　　selector:@selector（updateInterfaceForDynamicTypeSize）</p>

  <p class="calibre1">　　name:UIContentSizeCategoryDidChangeNotification</p>

  <p class="calibre1">　　object:nil];</p>

  <p class="calibre1"><span class="calibre10">　　NSLayoutConstraint *constraint =</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[NSLayoutConstraint constraintWithItem:self.thumbnailView</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　attribute:NSLayoutAttributeHeight</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　relatedBy:NSLayoutRelationEqual</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　toItem:self.thumbnailView</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　attribute:NSLayoutAttributeWidth</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　multiplier:1</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　constant:0];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[self.thumbnailView addConstraint:constraint];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　现在可以删除imageViewWidthConstraint属性和相关代码：</p>

  <p class="calibre1">　　@interface BNRItemCell （）</p>

  <p class="calibre1">　　@property （nonatomic, weak） IBOutlet NSLayoutConstraint</p>

  <p class="calibre1">　　*imageViewHeightConstraint;</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">@property （nonatomic, weak） IBOutlet NSLayoutConstraint</span></del></p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">*imageViewWidthConstraint;</span></del></p>

  <p class="calibre1">　　@end</p>

  <p class="calibre1">　　@implementation</p>

  <p class="calibre1">　　- （void）updateInterfaceForDynamicTypeSize</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　// 这里省略了其他代码……</p>

  <p class="calibre1">　　NSNumber *imageSize = imageSizeDictionary[userSize];</p>

  <p class="calibre1">　　self.imageViewHeightConstraint.constant = imageSize.floatValue;</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">self.imageViewWidthConstraint.constant = imageSize.floatValue;</span></del></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　打开BNRItemCell.xib，删除UIImageView对象与imageViewWidthConstraint的关联。</p>

  <p class="calibre1">　　最后还有一个问题：UIImageView对象现在有两个宽度约束。除了以上代码创建的之外，XIB文件中也添加过宽度约束。如果在运行时UIImageView对象的宽度发生变化，就会造成约束冲突。</p>

  <p class="calibre1">　　为了解决该问题，需要删除Interface Builder中添加的宽度约束，但是这么做会导致Interface Builder提示视图位置错误或者布局有歧义。因此，更好的方法是将宽度约束设置为占位符约束（placeholder constraint）。自动布局系统会在构建时移除占位符约束，占位符约束并不会真正对视图起作用。</p>

  <p class="calibre1">　　在BNRItemCell.xib中选中UIImageView对象的宽度约束，然后打开属性检视面板，选中标题为Placeholder的选择框。Placeholder选择框后面的描述也解释了“Placeholder”的含义：Remove at build time（在构建时移除），如图20-6所示。构建并运行应用，界面不会有任何变化，但是现在UIImageView对象的宽度约束是根据高度约束定义的。</p>

  <p class="calibre7"><img alt="tu20-6" src="../Images/image00636.jpeg" class="calibre8"/></p>

  <p class="calibre7">图20-6 占位符约束</p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
