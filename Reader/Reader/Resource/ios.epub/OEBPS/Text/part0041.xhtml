<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">4.4 在drawRect:方法中自定义绘图</h2>

  <p class="calibre1">　　前面编写了一个名为BNRHypnosisView的UIView子类，创建了两个BNRHypnosisView对象，设置了它们的frame属性和backgroundColor属性，并将这两个对象加入了Hypnosister的视图层次结构。本节开始学习如何在drawRect:方法中为BNRHypnosisView编写自定义的绘图代码。</p>

  <p class="calibre1">　　视图根据drawRect:方法将自己绘制到图层上。UIView的子类可以覆盖drawRect:，完成自定义的绘图任务。例如，UIButton的drawRect:方法默认会在frame表示的矩形区域中心画出一行浅蓝色的文字。</p>

  <p class="calibre1">　　覆盖drawRect:后首先应该获取视图从UIView继承而来的bounds属性，该属性定义了一个矩形范围，表示视图的绘制区域。</p>

  <p class="calibre1">　　视图在绘制自己时，会参考一个坐标系，bounds表示的矩形位于自己的坐标系，而frame表示的矩形位于父视图的坐标系，但是两个矩形的大小是相同的。</p>

  <p class="calibre1">　　读者可能会疑惑，在表示的矩形大小相同的情况下，为什么除了frame属性之外，还要定义bounds属性？</p>

  <p class="calibre1">　　frame和bounds表示的矩形用法不同。frame用于确定与视图层次结构中其他视图的相对位置，从而将自己的图层与其他视图的图层正确组合成屏幕上的图像。而bounds属性用于确定绘制区域，避免将自己绘制到图层边界之外（见图4-14）。</p>

  <p class="calibre7"><img alt="tu4-14" src="../Images/image00427.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-14 bounds和frame</p>

  <p class="calibre1">　　在BNRAppDelegate.m文件中，将UIWindow对象的bounds属性赋给firstView的frame属性，这样可以让firstView充满屏幕。</p>

  <p class="calibre1">　　- (BOOL)application:(UIApplication *)application</p>

  <p class="calibre1">　　didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　self.window = [[UIWindow alloc] initWithFrame:</p>

  <p class="calibre1">　　　　　　　　　[[UIScreen mainScreen] bounds]];</p>

  <p class="calibre1">　　// 在这里添加应用启动后的初始化代码</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">CGRect firstFrame = CGRectMake(160, 240, 100, 150);</span></del></p>

  <p class="calibre1"><span class="calibre10">　　CGRect firstFrame = self.window.bounds;</span></p>

  <p class="calibre1">　　BNRHypnosisView *firstView = [[BNRHypnosisView alloc]</p>

  <p class="calibre1">　　　　　　　　　　　　　　　　initWithFrame:firstFrame];</p>

  <p class="calibre1">　　[self.window addSubview:firstView];</p>

  <p class="calibre1">　　self.window.backgroundColor = [UIColor whiteColor];</p>

  <p class="calibre1">　　[self.window makeKeyAndVisible];</p>

  <p class="calibre1">　　return YES;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，屏幕上会显示一个充满屏幕的红色视图。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">绘制圆形</h3>

  <p class="calibre1">　　接下来在BNRHypnosisView.m的drawRect:方法中添加绘图代码，画出一个尽可能大的圆形，但是不超过视图的绘制区域。</p>

  <p class="calibre1">　　首先需要根据视图的bounds属性找到绘制区域的中心点，代码如下：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1"><span class="calibre10">　　CGRect bounds = self.bounds;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　// 根据bounds计算中心点</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　CGPoint center;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　center.x = bounds.origin.x + bounds.size.width / 2.0;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　center.y = bounds.origin.y + bounds.size.height / 2.0;</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　然后比较视图的宽和高，将较小值的二分之一设置为圆形的半径（使用较小值可以保证无论设备处于横握还是竖握模式都能画出不超过绘制区域的圆形），代码如下：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　CGRect bounds = self.bounds;</p>

  <p class="calibre1">　　// 根据bounds计算中心点</p>

  <p class="calibre1">　　CGPoint center;</p>

  <p class="calibre1">　　center.x = bounds.origin.x + bounds.size.width / 2.0;</p>

  <p class="calibre1">　　center.y = bounds.origin.y + bounds.size.height / 2.0;</p>

  <p class="calibre1">　　// 根据视图宽和高中的较小值计算圆形的半径</p>

  <p class="calibre1"><span class="calibre10">　　float radius = (MIN(bounds.size.width, bounds.size.height) / 2.0);</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">UIBezierPath</h3>

  <p class="calibre1">　　现在可以开始使用UIBezierPath类绘制圆形了。UIBezierPath用来绘制直线或曲线，从而组成各种形状，例如圆形。</p>

  <p class="calibre1">　　首先需要创建一个UIBezierPath对象，代码如下：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　...</p>

  <p class="calibre1">　　// 根据视图宽和高中的较小值计算圆形的半径</p>

  <p class="calibre1">　　float radius = (MIN(bounds.size.width, bounds.size.height) / 2.0);</p>

  <p class="calibre1"><span class="calibre10">　　UIBezierPath *path = [[UIBezierPath alloc] init];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　接下来定义UIBezierPath对象需要绘制的路径。如何定义一个可以绘制圆形的路径？解决问题的最佳方式就是查看Apple提供的开发者文档。文档中详细介绍了UIBezierPath的使用方法。</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">使用开发者文档</h3>

  <p class="calibre1">　　在Xcode菜单中选择Help→Documentation and API Reference（文档和API参考手册）。也可以使用键盘快捷键Option-Command-?（其实还需要按住Shift，以便选择“？”）。</p>

  <p class="calibre1">　　（查看文档时，Xcode可能会从Apple服务器上获取最新内容，有时会要求读者输入Apple ID和密码。）</p>

  <p class="calibre1">　　这时Xcode会打开文档浏览器，在搜索框中输入UIBezierPath，然后在搜索结果中选择UIBezierPath Class Reference（UIBezierPath参考手册），如图4-15所示。</p>

  <p class="calibre7"><img alt="tu4-15" src="../Images/image00428.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-15 在文档中搜索UIBezierPath</p>

  <p class="calibre1">　　UIBezierPath参考手册打开时会显示类的概览页面，但是关于定义绘制路径的内容位于Task部分。Task部分位于参考手册左边的内容列表中，（如果没有看到内容列表，请点击浏览器左上角的按钮。）可以根据需要实现的功能在Task部分查找对应的方法。</p>

  <p class="calibre1">　　第一个Task是Creating a UIBezierPath Object（创建UIBezierPath对象），之前的代码中已经完成了。第二个是Constructing a Path（构建路径），选择该Task，查看UIBezierPath中与之相关的一系列方法（见图4-16）。</p>

  <p class="calibre7"><img alt="tu4-16" src="../Images/image00429.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-16 与构建路径有关的方法</p>

  <p class="calibre1">　　请注意addArcWithCenter:radius:startAngle:endAngle:clockwise:方法，可以根据角度和半径定义弧形路径的方法定义圆形路径。点击该方法查看参数使用说明，之前已经计算出了圆形的圆心和半径，圆形的起止角度分别是0和M_PI * 2（startAngle和endAngle参数值的单位是弧度）。</p>

  <p class="calibre1">　　（如果读者对弧度和角度的转换有疑问，可以先简单地传入这两个值，或者在方法文档中找到Discussion部分，点击Figure 1链接，查看圆形中有关弧度的示意图。）</p>

  <p class="calibre1">　　最后，由于我们绘制的是一个整圆，顺时针还是逆时针都是可以的，因此为clockwise传入YES或NO。</p>

  <p class="calibre1">　　在BNRHypnosisView.m中，向UIBezierPath对象发送消息，定义绘制路径：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　CGRect bounds = self.bounds;</p>

  <p class="calibre1">　　// 根据bounds计算中心点</p>

  <p class="calibre1">　　CGPoint center;</p>

  <p class="calibre1">　　center.x = bounds.origin.x + bounds.size.width / 2.0;</p>

  <p class="calibre1">　　center.y = bounds.origin.y + bounds.size.height / 2.0;</p>

  <p class="calibre1">　　// 根据视图宽和高中的较小值计算圆形的半径</p>

  <p class="calibre1">　　float radius = (MIN(bounds.size.width, bounds.size.height) / 2.0);</p>

  <p class="calibre1">　　UIBezierPath *path = [[UIBezierPath alloc] init];</p>

  <p class="calibre1"><span class="calibre10">　　// 以中心点为圆心、radius的值为半径，定义一个0到M_PI * 2.0弧度的路径(整圆)</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[path addArcWithCenter:center</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　radius:radius</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　startAngle:0.0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　endAngle:M_PI * 2.0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　clockwise:YES];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　路径已经定义好了，但是只定义路径不会进行实际的绘制。回到UIBezierPath参考手册，在Task中选择Drawing Paths（绘制路径）。在可以绘制路径的方法中，选择stroke。（其他绘制方法会为图形填充颜色或者需要其他参数，例如CGBlendMode。）</p>

  <p class="calibre1">　　现在向UIBezierPath对象发送消息，绘制之前定义的路径，代码如下：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　...</p>

  <p class="calibre1">　　UIBezierPath *path = [[UIBezierPath alloc] init];</p>

  <p class="calibre1">　　// 以中心点为圆心、radius的值为半径，定义一个0到M_PI * 2.0弧度的路径(整圆)</p>

  <p class="calibre1">　　[path addArcWithCenter:center</p>

  <p class="calibre1">　　radius:radius</p>

  <p class="calibre1">　　　　　　startAngle:0.0</p>

  <p class="calibre1">　　endAngle:M_PI * 2.0</p>

  <p class="calibre1">　　　　clockwise:YES];</p>

  <p class="calibre1"><span class="calibre10">　　// 绘制路径！</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[path stroke];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，可以看到一个由黑色细线构成的圆形，其直径和屏幕宽度相同（如果设备处于横握状态，那么圆形的直径和屏幕高度相同），如图4-17所示。</p>

  <p class="calibre7"><img alt="tu4-17" src="../Images/image00430.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-17 BNRHypnosisView中画出了一个圆形</p>

  <p class="calibre1">　　根据Hypnosister应用最初的设计方案，构成圆形的轮廓线应该比现在更粗，同时颜色是浅灰色而不是黑色。</p>

  <p class="calibre1">　　为了改变线条的粗细和颜色，请回到UIBezierPath参考手册，在内容列表中找到Properties（属性）部分。在属性列表中找到lineWidth属性，该属性是CGFloat类型，默认值为1.0。</p>

  <p class="calibre1">　　在BNRHypnosisView.m中，设置线条的宽度为10点，代码如下：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　...</p>

  <p class="calibre1">　　// 以中心点为圆心、radius的值为半径，定义一个0到M_PI * 2.0弧度的路径(整圆)</p>

  <p class="calibre1">　　[path addArcWithCenter:center</p>

  <p class="calibre1">　　radius:radius</p>

  <p class="calibre1">　　　　　　startAngle:0.0</p>

  <p class="calibre1">　　endAngle:M_PI * 2.0</p>

  <p class="calibre1">　　　　clockwise:YES];</p>

  <p class="calibre1"><span class="calibre10">　　// 设置线条宽度为10点</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　path.lineWidth = 10;</span><br class="calibre2"/></p>

  <p class="calibre1">　　// 绘制路径！</p>

  <p class="calibre1">　　[path stroke];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，现在圆形的轮廓线应该比之前更粗。</p>

  <p class="calibre1">　　UIBezierPath中没有设置线条颜色的属性，但是UIBezierPath参考手册中的Overview部分介绍了设置线条颜色的方法。点击内容列表中的Overview，在第五段（随着Apple修订文档可能会有变动）中有一句话：“You set the stroke and fill color using the UIColor class.（请您使用UIColor类设置线条颜色和填充颜色。）”</p>

  <p class="calibre1">　　可以点击UIColor链接进入UIColor参考手册，在UIColor的Task部分，选择Drawing Operations，查看与绘制操作相关的方法。可以使用set或setStroke方法设置线条颜色，请读者选择用法更加明确的setStroke方法。</p>

  <p class="calibre1">　　setStroke方法是一个实例方法，因此需要创建一个UIColor对象。前面提到过，UIColor有一系列对应于常见颜色的简便方法，可以在UIColor参考手册中的Class Methods部分找到这些方法，其中包括lightGrayColor。</p>

  <p class="calibre1">　　现在可以设置线条颜色了，在BNRHypnosisView.m中，创建一个表示浅灰色的UIColor对象并向其发送setStroke消息，这样就可以画出一个浅灰色轮廓的圆形。</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　...</p>

  <p class="calibre1">　　// 设置线条宽度为10点</p>

  <p class="calibre1">　　path.lineWidth = 10;</p>

  <p class="calibre1"><span class="calibre10">　　// 设置绘制颜色为浅灰色</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[[UIColor lightGrayColor] setStroke];</span><br class="calibre2"/></p>

  <p class="calibre1">　　// 绘制路径！</p>

  <p class="calibre1">　　[path stroke];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，可以看到圆形的轮廓线已经变成浅灰色了。</p>

  <p class="calibre1">　　读者可能已经注意到，视图的backgroundColor属性不会受drawRect:中代码的影响，通常应该将重写了drawRect:方法的视图的背景颜色设置为透明（对应于clearColor），这样可以让视图只显示drawRect:方法中绘制的内容。</p>

  <p class="calibre1">　　在BNRAppDelegate.m中，删除设置视图背景颜色的代码：</p>

  <p class="calibre1">　　BNRHypnosisView *firstView = [[BNRHypnosisView alloc]</p>

  <p class="calibre1">　　　　　　　　　　　　　　　　initWithFrame:firstFrame];</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">firstView.backgroundColor = [UIColor redColor];</span></del></p>

  <p class="calibre1">　　[self.window addSubview:view];</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <p class="calibre1">　　然后，在BNRHypnosisView.m的initWithFrame:方法中，设置BNRHypnosisView对象的背景颜色为透明：</p>

  <p class="calibre1">　　- (instancetype)initWithFrame:(CGRect)frame</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　self = [super initWithFrame:frame];</p>

  <p class="calibre1">　　if (self) {</p>

  <p class="calibre1"><span class="calibre10">　　　　// 设置BNRHypnosisView对象的背景颜色为透明</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　self.backgroundColor = [UIColor clearColor];</span><br class="calibre2"/></p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　return self;</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，可以看到一个透明背景的圆形，如图4-18所示。</p>

  <p class="calibre7"><img alt="tu4-18" src="../Images/image00431.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-18 透明背景的圆形</p>

  <p class="calibre1"><br class="calibre2"/></p>

  <h3 class="sigil_not_in_toc">绘制同心圆</h3>

  <p class="calibre1">　　在BNRHypnosisView中绘制多个同心圆有两个方法，第一个方法是创建多个UIBezierPath对象，每个对象代表一个圆形；第二个方法是使用一个UIBezierPath对象绘制多个圆形，为每个圆形定义一个绘制路径。显然，第二个方法更好，只创建一个UIBezierPath对象可以减少内存占用。</p>

  <p class="calibre1">　　首先需要确定最外层圆形的直径，然后从这个直径递减，确定其他圆形的直径。请注意直径必须大于零。</p>

  <p class="calibre1">　　这里使用视图的对角线作为最外层圆形的直径，使最外层圆形成为视图的外接圆——只能在视图的四个角上看到该圆形的浅灰色轮廓。</p>

  <p class="calibre1">　　在BNRHypnosisView.m中，删除绘制单个圆形的代码，改为绘制多个同心圆：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　CGRect bounds = self.bounds;</p>

  <p class="calibre1">　　// 根据bounds计算中心点</p>

  <p class="calibre1">　　CGPoint center;</p>

  <p class="calibre1">　　center.x = bounds.origin.x + bounds.size.width / 2.0;</p>

  <p class="calibre1">　　center.y = bounds.origin.y + bounds.size.height / 2.0;</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">// 根据视图宽和高中的较小值计算圆形的半径</span></del></p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">float radius = (MIN(bounds.size.width, bounds.size.height) / 2.0);</span></del></p>

  <p class="calibre1"><span class="calibre10">　　// 使最外层圆形成为视图的外接圆</span></p>

  <p class="calibre1"><span class="calibre10">　　float maxRadius = hypot(bounds.size.width, bounds.size.height) / 2.0;</span></p>

  <p class="calibre1">　　UIBezierPath *path = [[UIBezierPath alloc] init];</p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">// 以中心点为圆心，radius的值为半径，</span></del></p>

  <p class="calibre1">　　 <del class="calibre11"><span class="calibre10">// 定义一个0到M_PI * 2.0弧度的路径(整圆)</span></del></p>

  <p class="calibre1">　　<del class="calibre11"><span class="calibre10">[path addArcWithCenter:center</span></del></p>

  <p class="calibre1">　　　　　　<del class="calibre11"><span class="calibre10">radius:radius</span></del></p>

  <p class="calibre1">　　　　 <del class="calibre11"><span class="calibre10">startAngle:0.0</span></del></p>

  <p class="calibre1">　　　　　　 <del class="calibre11"><span class="calibre10">endAngle:M_PI * 2.0</span></del></p>

  <p class="calibre1">　　　　 <del class="calibre11"><span class="calibre10">clockwise:YES];</span></del></p>

  <p class="calibre1"><span class="calibre10">　　for (float currentRadius = maxRadius; currentRadius &gt; 0;</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　currentRadius -= 20) {</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　[path addArcWithCenter:center</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　radius:currentRadius // 半径为currentRadius！</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　　　startAngle:0.0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　　　endAngle:M_PI * 2.0</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　　　　　　　&gt;clockwise:YES];</span><br class="calibre2"/></p>

  <p class="calibre1"><span class="calibre10">　　}</span><br class="calibre2"/></p>

  <p class="calibre1">　　// 设置线条宽度为10点</p>

  <p class="calibre1">　　path.lineWidth = 10;</p>

  <p class="calibre1">　　// 设置绘制颜色为浅灰色</p>

  <p class="calibre1">　　[[UIColor lightGrayColor] setStroke];</p>

  <p class="calibre1">　　// 绘制路径！</p>

  <p class="calibre1">　　[path stroke];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，虽然BNRHypnosisView画出了一系列同心圆，但是屏幕右边多出了一条奇怪的直线，如图4-19所示。</p>

  <p class="calibre7"><img alt="tu4-19" src="../Images/image00432.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-19 BNRHypnosisView绘制了不正确的同心圆</p>

  <p class="calibre1">　　这是因为单个UIBezierPath对象将多个路径（每个路径可以画出一个圆形）连接起来，形成了一个完整的路径。可以将UIBezierPath对象想象为一支在纸上画画的铅笔——在绘制完某个圆后去绘制另一个圆时，铅笔并没有抬起，仍然停留在纸上，因此会继续留下笔迹。正确的做法是每次绘制新的圆形之前，必须抬起笔。</p>

  <p class="calibre1">　　在drawRect:方法的for循环中，当绘制下一个圆形时，抬起笔并移动到正确的位置：</p>

  <p class="calibre1">　　- (void)drawRect:(CGRect)rect</p>

  <p class="calibre1">　　{</p>

  <p class="calibre1">　　CGRect bounds = self.bounds;</p>

  <p class="calibre1">　　// 根据bounds计算中心点</p>

  <p class="calibre1">　　CGPoint center;</p>

  <p class="calibre1">　　center.x = bounds.origin.x + bounds.size.width / 2.0;</p>

  <p class="calibre1">　　center.y = bounds.origin.y + bounds.size.height / 2.0;</p>

  <p class="calibre1">　　// 使最外层圆形成为视图的外接圆</p>

  <p class="calibre1">　　float maxRadius = hypot(bounds.size.width, bounds.size.height) / 2.0;</p>

  <p class="calibre1">　　UIBezierPath *path = [[UIBezierPath alloc] init];</p>

  <p class="calibre1">　　for (float currentRadius = maxRadius; currentRadius &gt; 0; currentRadius -= 20) {</p>

  <p class="calibre1"><span class="calibre10">　　[path moveToPoint:CGPointMake(center.x + currentRadius, center.y)];</span><br class="calibre2"/></p>

  <p class="calibre1">　　[path addArcWithCenter:center</p>

  <p class="calibre1">　　　　　　　　　　radius:currentRadius // 半径为currentRadius！</p>

  <p class="calibre1">　　　　　　　　　　startAngle:0.0</p>

  <p class="calibre1">　　　　　　　　　　endAngle:M_PI * 2.0</p>

  <p class="calibre1">　　　　　　　　　　clockwise:YES];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　// 设置线条宽度为10点</p>

  <p class="calibre1">　　path.lineWidth = 10.0;</p>

  <p class="calibre1">　　// 绘制路径</p>

  <p class="calibre1">　　[path stroke];</p>

  <p class="calibre1">　　}</p>

  <p class="calibre1">　　构建并运行应用，现在绘制的同心圆完全正确，如图4-20所示。</p>

  <p class="calibre7"><img alt="tu4-20" src="../Images/image00433.jpeg" class="calibre8"/></p>

  <p class="calibre7">图4-20 绘制同心圆</p>

  <p class="calibre1">　　Hypnosister只使用了UIBezierPath的少数功能，读者可以查看UIBezierPath参考手册完成本章后面的练习，学习使用圆弧、直线和曲线组合起来画出更多有创意的图案。</p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
