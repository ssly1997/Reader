<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <h2 class="calibre9">6.11 深入学习：Retina显示屏</h2>

  <p class="calibre1">　　随着iPhone 4的发布，Apple公司推出了针对iPhone和iPod Touch的Retina显示屏。Retina显示屏拥有很高的分辨率——其中4英寸屏幕是640像素×1136像素，3.5英寸屏幕是640像素×960像素（之前的屏幕分辨率是320像素×480像素）。下面介绍如何让图像在两种设备上都有最好的显示效果。</p>

  <p class="calibre1">　　对于矢量图像，不用做任何处理就能在两种设备上有最好的显示效果。以BNRHypnosisView的drawRect:和其绘制的文字为例，只需要编写同一段代码，就能让视图以当前设备允许的最大分辨率渲染图像。如果应用是通过Core Graphics函数绘图的，那么画出的图像在不同的设备上会有不同的显示效果。Core Graphics以点为单位描述线、曲线和文字等。对于非Retina显示屏，1个点是1个像素。对于Retina显示屏，1个点是2像素×2像素（见图6-19）。</p>

  <p class="calibre7"><img alt="tu6-19" src="../Images/image00461.jpeg" class="calibre8"/></p>

  <p class="calibre7">图6-19 不同分辨率下的绘图效果</p>

  <p class="calibre1">　　鉴于以上这些差别，如果位图图片（例如JPEG或PNG文件）不适合当前设备的屏幕类型，显示效果就会大打折扣。例如，假设某个应用有一个25像素×25像素的小图片，并且要画出的图片尺寸是25点×25点（注意，这里的单位是点）。在Retina显示屏上显示该图片时，系统必须拉伸该图片才能覆盖50像素×50像素的区域。这时系统会用一种称为抗锯齿（anti-aliasing）的平均算法，使放大后的图片看上去更圆滑。处理后的图片虽然圆滑，但是看上去较模糊（见图6-20）。</p>

  <p class="calibre7"><img alt="tu6-20" src="../Images/image00462.jpeg" class="calibre8"/></p>

  <p class="calibre7">图6-20 图片放大后变模糊了</p>

  <p class="calibre1">　　也不能使用更大的图片：为非Retina屏幕缩小图片时，平均算法一样会产生问题。唯一的解决方案是在应用程序包里放入两套图：一套针对非Retina显示屏，像素分辨率和相应的屏幕点数相同；另一套针对Retina显示屏，像素尺寸比前一套大1倍。</p>

  <p class="calibre1">　　好在不需要编写任何额外的代码，应用就能根据当前的设备载入相应版本的图片。开发者唯一需要做的就是为高分辨率的图片文件加上后缀名@2x。当应用使用UIImage的imageNamed:载入图片时，imageNamed:会在程序包里查找并获取适合特定设备的文件。</p>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
